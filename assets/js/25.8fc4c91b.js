(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{344:function(t,s,a){"use strict";a.r(s);var n=a(6),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"effective-c"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#effective-c"}},[t._v("#")]),t._v(" Effective C++")]),t._v(" "),a("h2",{attrs:{id:"习惯c"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#习惯c"}},[t._v("#")]),t._v(" 习惯C++")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("C++是一个语言联邦， 有多种编程范式: procedural （面向过程）, OOP（面向对象）， GP（泛型编程）,  Functional Programming（函数式编程），metaprograming(元编程），但差不多有四个主要的部分：")]),t._v(" "),a("ol",[a("li",[t._v("C：数组， 指针， 预处理， 程序员的自我修养")]),t._v(" "),a("li",[t._v("Object oriented C++： classs, encapsulation, ingeritance, polymorphism,  virtual function的动态绑定；（模板， 异常， 重载）")]),t._v(" "),a("li",[t._v("Template C++ (template metaprogramming, 模板元编程)")]),t._v(" "),a("li",[t._v("STL： container, iterator, algorithms, function objects")])])]),t._v(" "),a("li",[a("p",[t._v("用const， enum， inline代替 #define")])]),t._v(" "),a("li",[a("p",[t._v("该用const的地方，尽可能使用const")]),t._v(" "),a("p",[t._v("函数的参数， 传引用的时候， 使用const修饰， 会明示参数是否被改变（引用不改变， 要加const表示出来）")]),t._v(" "),a("p",[t._v("成员函数后是否要加const， 确定成员函数是否会修改类内的值，")]),t._v(" "),a("p",[t._v("以及"),a("strong",[t._v("返回值是否要成为const")]),t._v("（为什么？）， 返回值类型上不允许变动（避免成为左值被修改）")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get_data")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])])]),t._v(" "),a("li",[a("p",[t._v("对象在使用之前要初始化")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("读取没有初始化的值， 导致不明确的行为， 变量里面包含的内容都是半随机状态")])]),t._v(" "),a("li",[a("p",[t._v("在初始化列表里面， 列出所有的成员变量， 免得遗漏， 除非记得住哪些不用初始值；")])]),t._v(" "),a("li",[a("p",[t._v("成员变量是const或者reference， 就一定要初始化， 因为后面不能再被赋值了；")])]),t._v(" "),a("li",[a("p",[t._v("实在太多的话， 用一个private函数包一下能够赋值处理的， 也可以；")])]),t._v(" "),a("li",[a("p",[t._v("初始化的顺序总是按照声明顺序来， 不是按照初始化列表的顺序")])]),t._v(" "),a("li",[a("p",[t._v("如果有一个外部的static对象， 没有办法保证是否使用的时候已经初始化， 那就在本地搞一个static函数把这个对象包起来，返回一个指向这个对象的reference， 这样， 外部的static对象就变成了本地的static对象， 这也是singleton模式的一个常见实现手法（这种手法叫做reference returning）")])]),t._v(" "),a("li",[a("p",[t._v("和more effective c++里面， 限制对象数目的方式， 好像是一样的"),a("img",{attrs:{src:"/1_Effective_C++.assets/image-20230525105443119.png",alt:"image-20230525105443119"}})])]),t._v(" "),a("li",[a("p",[t._v("任何一种non const static 对象，在多线程环境下， 都会有线程安全的问题；")])])])])]),t._v(" "),a("h2",{attrs:{id:"构造-析构-和重载赋值运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构造-析构-和重载赋值运算符"}},[t._v("#")]),t._v(" 构造，析构， 和重载赋值运算符")]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[a("p",[t._v("C++ 自动生成的构造，析构， 拷贝赋值函数（op=重载），(big three, 除此之外还有移动构造， 移动赋值， 不过这需要自己的写）")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("默认的构造， 析构函数， 只能是浅复制， 值的复制， 如果有指针， 只能指向同一个地址， 而不能有两份内存出来；")])]),t._v(" "),a("li",[a("p",[t._v("对const成员变量， reference变量， 自动生成的copy assignment是不能对这些东西进行赋值和拷贝操作的")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Timekeeper")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Timekeeper")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("virtual")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("TimeKeeper")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])])]),t._v(" "),a("li",[a("p",[t._v("经验： class里面如果有一个virtual的函数， 就为这个类弄一个virtual的析构函数；")])]),t._v(" "),a("li",[a("p",[t._v("纯虚函数？纯虚函数会带来一个抽象基类， 抽象基类不能实例化；但是抽象基类也可以有一个纯虚的析构函数，需要单独提供一份定义；")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AWOV")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("virtual")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("AWOV")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AMOV")]),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("AMOV")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 单独提供一份定义")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])])])])]),t._v(" "),a("li",[a("p",[t._v("如何拒绝使用这些自动生成的函数，")]),t._v(" "),a("ol",[a("li",[t._v("使用=delete来禁止使用拷贝构造， 拷贝赋值，")]),t._v(" "),a("li",[t._v("以前在没有=delete关键字的时候， 可以把这些函数放在private里面")])])]),t._v(" "),a("li",[a("p",[t._v("多态基类的析构函数最好弄成virtual的；")]),t._v(" "),a("ol",[a("li",[t._v("如果析构函数不是virtual的， 那么delete基类指针来进行析构的话。derived部分偶尔会被遗漏掉；")]),t._v(" "),a("li",[t._v("为什么不是构造函数？因为我们构造的时候， 基本上都是用derived类来进行构造的；")])])]),t._v(" "),a("li",[a("p",[t._v("析构函数不要吐出异常（别让异常逃离析构函数）, "),a("strong",[t._v("为什么?")])]),t._v(" "),a("ol",[a("li",[t._v("如果不处理异常， 会带来一些不明确的行为")]),t._v(" "),a("li",[t._v("如果吐出异常，可能会导致程序半路断掉；")]),t._v(" "),a("li",[t._v("所以要好好善后；")])])]),t._v(" "),a("li",[a("p",[t._v("析构和构造函数中， 不要调用virtual函数， "),a("strong",[t._v("为什么?")])]),t._v(" "),a("ol",[a("li",[t._v("构造的时候， derived对象还没有生成， 所以这个时候还用不到自身特化的virtual function， 只能用base class里面的版本；")]),t._v(" "),a("li",[t._v("析构的时候， 只要一开始析构， 对象内的derived class成员变量就是未定义值， 所以这个时候virtual function还是会跑到父类里面去；")])])]),t._v(" "),a("li",[a("p",[t._v("operator= 最好是返回一个 reference to *this,")]),t._v(" "),a("ol",[a("li",[t._v("因为这样可以拥有连续赋值的特性， 例如： x = y = z = 15")])])]),t._v(" "),a("li",[a("p",[t._v("operator=里面， 要判断是否是自我赋值；")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("Widget"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" Widget"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("operator")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Widget"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" rhs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("rhs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),t._v(" pb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tpb "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Bitmap")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("rhs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("rhs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br")])])]),t._v(" "),a("li",[a("p",[t._v("自定义拷贝构造函数的时候， 要复制所有local的变量， 可以使用基类的一些拷贝构造函数对一些成员拷贝；")]),t._v(" "),a("p",[t._v("因为有一些基类对象的拷贝， 必须要通过基类的拷贝构造函数来进行深度拷贝；")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("PriorityCustomer"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("operator")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" PriorityCustomer "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("rhs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("logCall")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"......"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    Customer"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("operator")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rhs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里直接调用了base class的拷贝构造函数来进行；")]),t._v("\n    priority "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" rhs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("priority"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("不要使用copy assignment 来调用copy constructor; 反过来也不建议， 因为都是针对没有构造好的对象进行操作；")]),t._v(" "),a("p",[t._v("最终还是要将他么共同的一些实际操作放到函数里面， 因为只要使用上面两种函数， 都会要实现构造一个临时的对象， 但对象在这些函数运行过程中都是没有构造好的；")])])]),t._v(" "),a("h2",{attrs:{id:"resource-management-资源管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#resource-management-资源管理"}},[t._v("#")]),t._v(" Resource Management， 资源管理")]),t._v(" "),a("ol",{attrs:{start:"13"}},[a("li",[a("p",[t._v("用对象的形式管理资源 (RAII， Resource Acquisition Is Initialization)，所以要特别注意构造和析构函数，在使用对象的时候可以使用shared_ptr之类的智能指针来管理每个对象的实例；")]),t._v(" "),a("ol",[a("li",[t._v("返回没有加工的指针， 容易造成资源泄露， 忘记delete")]),t._v(" "),a("li",[t._v("手动释放资源， 可能会跑不到释放的那个地方， 也有可能造成double release；")]),t._v(" "),a("li",[t._v("不要多个auto_ptr()指向同一个对象， 不然对象可能会被多次删除， 程序就会有未定义行为；")]),t._v(" "),a("li",[t._v("copy assignment要让原来的指针变成null")]),t._v(" "),a("li",[t._v("使用reference counting smart pointer, 使用"),a("strong",[t._v("shared_ptr()")])])])]),t._v(" "),a("li",[a("p",[t._v("虽然都是RAII原则， 但是要特别注意拷贝构造的行为，书里面用linux中的mutex的lock和unlock函数来举了例子")]),t._v(" "),a("ol",[a("li",[t._v("要清楚自己做的是深拷贝还是浅拷贝，要确保自己是在做深拷贝， 不仅拷贝指针， 也拷贝指针所指的内存块；")]),t._v(" "),a("li",[t._v("有时候拷贝其实是一种转移， 要确保系统中给目前只有者一个对象， 从一个地方转移到另外一个地方--\x3e auto_ptr")]),t._v(" "),a("li",[t._v("自动生成的拷贝函数不一定能够满足需求；")])])]),t._v(" "),a("li",[a("p",[t._v("资源管理类中， 提供对原始资源的访问接口， 例如x.get， get_instance这种接口")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("返回数字，")])]),t._v(" "),a("li",[a("p",[t._v("返回一个instance")])]),t._v(" "),a("li",[a("p",[t._v("singleton的设计模式是怎么做的?")])]),t._v(" "),a("li",[a("p",[t._v("factory模式是怎么做的？")])]),t._v(" "),a("li",[a("p",[t._v("操作符重载")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Font")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("operator")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("FontHandle")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//也可以重载类型转换函数；")]),t._v("\n    \t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])])])])]),t._v(" "),a("li",[a("p",[t._v("new和delete使用的时候要成对使用， 并且注意区别数组和对象的delete")]),t._v(" "),a("ul",[a("li",[t._v("operator new, new operator的区别？")]),t._v(" "),a("li",[t._v("placement new / new placement区别？")])]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("string"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" stringPtr1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstd"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("string"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" stringPtr2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),t._v(" stringPtr1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 删除一个对象， 一个指针；")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" stringPtr2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 删除一个数组， 一块内存")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])])]),t._v(" "),a("li",[a("p",[t._v("以单独的一条语句把new出来的对象放到智能指针里面去， why?")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("要保证new这个语句是单独执行的， 先于智能指针的赋值操作；")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("processWidget")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("tr1"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token generic-function"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shared_ptr")]),a("span",{pre:!0,attrs:{class:"token generic class-name"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Widget"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" Widget"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("priority")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 万一priority()这个函数执行异常会怎样？")]),t._v("\n\nstd"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("tr1"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("shared_ptr"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Widget"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pw")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" Widget"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("processWidget")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pw"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("priority")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])])])])])]),t._v(" "),a("h2",{attrs:{id:"design-and-declarations-设计与声明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#design-and-declarations-设计与声明"}},[t._v("#")]),t._v(" Design and Declarations, 设计与声明")]),t._v(" "),a("ol",{attrs:{start:"18"}},[a("li",[a("p",[t._v("接口设计简明， 不要让用户对其有歧义")]),t._v(" "),a("ol",[a("li",[t._v("建立新类型，限制类型上的操作， 束缚对象值，消除客户的资源管理责任")]),t._v(" "),a("li",[t._v("好好设计程序的类型系统， 使用class， template， typedef， struct， enum等等")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("设计class的时候， 就好比设计type（一系列要注意的事项）")])]),t._v(" "),a("ul",[a("li",[t._v("如何创建和销毁， operator new, operator new[]. operator delete, operator delete[],")]),t._v(" "),a("li",[t._v("对象初始化和对象的赋值有什么区别？ 拷贝构造， 和copy assignment之间有什么区别？ 。")])])])]),t._v(" "),a("p",[t._v("对一个新对象来说， pass by value意味着什么？因为要重载操作符， 函数， 和重载内存的分配和归还，")]),t._v(" "),a("p",[t._v("type cast的我呢提要怎么处理， 类型转换函数， operator T")]),t._v(" "),a("ol",{attrs:{start:"20"}},[a("li",[a("p",[t._v("函数的参数使用pass by reference to const替换pass by value，（内置类型， 其实pass by value也比较合适）")]),t._v(" "),a("ol",[a("li",[t._v("效率会比较高")])])]),t._v(" "),a("li",[a("p",[t._v("如果必须返回一个对象，  不要返回他的reference，")]),t._v(" "),a("ol",[a("li",[t._v("因为可能会返回一个local的对象，local对象的renference是没有用的；")])])]),t._v(" "),a("li",[a("p",[t._v("成员变量声明为private")]),t._v(" "),a("ol",[a("li",[t._v("使用函数来对成员变量进行访问控制， 这样能够给类更好的封装性")])])]),t._v(" "),a("li",[a("p",[t._v("使用non member, non friend来替换member函数")]),t._v(" "),a("ol",[a("li",[t._v("为的是增加封装性， 增加扩充的弹性，")]),t._v(" "),a("li",[t._v("可以把全局函数放在一个命名空间里面， 稍微约束一下它的作用域")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("如果某个函数所有的参数都需要类型转换， 这个函数必须弄成non merber函数")])]),t._v(" "),a("ol",[a("li",[t._v("【不是很懂， 需要接触一下模板相关的知识？】")])])]),t._v(" "),a("li",[a("p",[t._v("给自己的类写的swap函数，不要抛出异常， 这是为了和STL库一样支持swap的异常安全；")]),t._v(" "),a("ol",[a("li",[t._v("friend可以方位private变量和函数；")])])])]),t._v(" "),a("h2",{attrs:{id:"implementations-实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementations-实现"}},[t._v("#")]),t._v(" Implementations, 实现")]),t._v(" "),a("ol",{attrs:{start:"26"}},[a("li",[a("p",[t._v("延迟变量定义的出现时间， 尽量"),a("strong",[t._v("用到的时候再定义；")])])]),t._v(" "),a("li",[a("p",[t._v("少做cast转型动作， 即使要用也尽量使用C++自己的那四个转型")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("static_cast")])]),t._v(" "),a("li",[a("p",[t._v("const_cast")])]),t._v(" "),a("li",[a("p",[t._v("dynamic_cast")])]),t._v(" "),a("li",[a("p",[t._v("reinterpret_cast")])])])]),t._v(" "),a("li",[a("p",[t._v("避免返回一个handler， 这个handler却有指向对象的内部成分，")]),t._v(" "),a("ol",[a("li",[t._v("避免返回的是一个空悬的指针；")]),t._v(" "),a("li",[t._v("避免可以使用调用的操作来对函数内部的元素进行修改， 可以指定返回值是一个const， 这样用户就不能修改了；")])])]),t._v(" "),a("li",[a("p",[t._v("注意异常安全， （exceptional C++里面有很多异常安全的相关介绍）")])]),t._v(" "),a("li",[a("p",[t._v("对inline的里里外外需要透彻了解；")])])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("尽量inline， 也许compiler就能够执行context相关的inline优化；")])]),t._v(" "),a("li",[a("p",[t._v("定义在类里面的函数， 自动inline")])]),t._v(" "),a("li",[a("p",[t._v("inline会让代码文件变大， 会导致更多的换页行为（paging），降低 i cache的命中率, 如果函数比较小， inline对 icache miss的影响会稍微比较小， 但是inline的函数比较大， 就有可能会得不偿失；")])]),t._v(" "),a("li",[a("p",[t._v("虚函数的inline， 大多都不会生效")])]),t._v(" "),a("li",[a("p",[t._v("inline不仅会导致代码变大， 而且一旦inline的函数发生改变， 所有用到inline function的地方都要重新编译")])]),t._v(" "),a("li",[a("p",[t._v("template要尽量避免成为一个inline函数， 它的代价是很大的；")])])]),t._v(" "),a("ol",{attrs:{start:"31"}},[a("li",[t._v("尽量减少文件之间的编译依赖关系；不然修改之后编译， 会导致很多部件都一起编译了")])]),t._v(" "),a("ul",[a("li",[t._v("头文件应该仅有声明不要有定义；")]),t._v(" "),a("li",[t._v("一般使用pointer to implementation 和纯虚函数的工厂方法来解决， 前者叫handle class, 后者叫interface class;")])]),t._v(" "),a("h2",{attrs:{id:"继承与面向对象的设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承与面向对象的设计"}},[t._v("#")]),t._v(" 继承与面向对象的设计")]),t._v(" "),a("ol",{attrs:{start:"32"}},[a("li",[t._v("public继承的时候， 确认两个对象是 is a的关系；")]),t._v(" "),a("li",[t._v("继承的时候，注意类内部的变量名称是否会被覆盖，")])]),t._v(" "),a("ul",[a("li",[t._v("即使是重载的函数，不管函数接口形式是否一样， 也会被子类的同名函数覆盖")]),t._v(" "),a("li",[t._v("使用using Base::mf3() 可以指定在子类作用域范围里面使用base类的mf3函数，")]),t._v(" "),a("li",[t._v("如果只想使用某一个mf3(), 只能是子类的函数里面， 再调用Base::mf3(); 美其名曰，forward functions;")])]),t._v(" "),a("ol",{attrs:{start:"34"}},[a("li",[a("p",[t._v("什么是接口继承和实现继承？")]),t._v(" "),a("ol",[a("li",[t._v("pure virtual函数的目的就是接口继承， 但是也可以有一份基类实现，调用的时候只能通过子类指定父类名称的方式来调用（纯虚函数必须重写）；")]),t._v(" "),a("li",[t._v("非纯虚函数是为了让子类继承接口 + 缺省实现， 这些都是自动继承的， 如果子类不override 虚函数的话（一般虚函数可以重写， 也可以不重写）；")]),t._v(" "),a("li",[t._v("非虚函数的目的是强制让子类继承一个缺省的实现；（非虚函数，没有多态性，直接继承）")]),t._v(" "),a("li",[t._v("接口和实现继承分开， 也就是把接口用一个纯虚函数来声明， 实现使用一个private或者protected的缺省实现来代替， 这样子类必须要重写纯虚函数，但是可以选择使用缺省的实现；")]),t._v(" "),a("li",[t._v("也可以使用一个虚函数的非虚实现， 然后再在子类里面overide的时候调用这个函数；")])])]),t._v(" "),a("li",[a("p",[t._v("除了virtual函数之外，也可以考虑一下其他的选择")]),t._v(" "),a("ol",[a("li",[t._v("通过一个public函数， 调用自己的virtual函数， non-virtual interface（NVI）方法；（模板方法设计模式）")]),t._v(" "),a("li",[t._v("借助funciion pointer实现strategy pattern")]),t._v(" "),a("li",[t._v("使用各个库里面的function component， 例如std::function， 而且这个东西支持任何callable entities，包括运算符重载的struct和class")]),t._v(" "),a("li",[t._v("标准设计模式， 古典的strategy模式， 就是使用pImple的方式来实现strategy， 来代替第一条里面的实现方式")])])]),t._v(" "),a("li",[a("p",[t._v("不要重新定义继承来的non virtual函数， 这其实是一种overloading， 并不能实现多态特性的overide， nonvirtual 函数其实是静态绑定的；virtual函数是动态绑定的")])]),t._v(" "),a("li",[a("p",[t._v("不要重新定义继承来的缺省参数值， 因为可能会在调用子类的时候， 用到父类里面这个函数的默认值，（对于通过对象指针， 引用的方式都会有这个问题， 因为默认参数的绑定，是一种静态绑定），子类就声明参数就可以了， 不需要有默认值")])]),t._v(" "),a("li",[a("p",[t._v("通过composition实现has a, 或者根据某物实现的关系")])]),t._v(" "),a("li",[a("p",[t._v("谨慎使用private继承，")]),t._v(" "),a("ol",[a("li",[t._v("编译器不会把一个private继承的子类，自动转换成一个基类")]),t._v(" "),a("li",[t._v("private继承下来的所有成员， 在子类中都会变成private属性")]),t._v(" "),a("li",[t._v("protect继承\n"),a("ol",[a("li",[t._v("默认的基本上都是public继承；")]),t._v(" "),a("li",[t._v("尽可能使用compiosition， 必要的时候再使用private继承")])])])])]),t._v(" "),a("li",[a("p",[t._v("谨慎使用多重继承（子类从多个父类继承而来）")]),t._v(" "),a("ol",[a("li",[t._v("可能对导致对基类函数调用的歧义，到底调用的是哪一个基类的成员函数？")]),t._v(" "),a("li",[t._v("钻石形继承， 二级基类可以是虚基类， 这样三级再继承的时候， 就不会重复出现两个爷爷类里面的成员函数了；")]),t._v(" "),a("li",[t._v("virtual继承会带来更多大小，速度，初始化的成本。如果非要有一个virtual base class， 最好不要在虚基类里面放置数据；")]),t._v(" "),a("li",[t._v("有一种情况， 比较适合多重继承，public继承某个interface class， private继承某个协助实现的class；帮助子类实现某些功能。但是还是谨记第一条吧；")])])])]),t._v(" "),a("h2",{attrs:{id:"模板-gp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板-gp"}},[t._v("#")]),t._v(" 模板，GP")]),t._v(" "),a("ol",{attrs:{start:"41"}},[a("li",[t._v("隐式接口和编译期多态")]),t._v(" "),a("li",[t._v("typename和class关键字， typename关键字的双重定义")]),t._v(" "),a("li",[t._v("如何处理模板化基类的里面的名称")]),t._v(" "),a("li",[t._v("参数无关的代码， 抽离template")]),t._v(" "),a("li",[t._v("使用成员函数模板来接受所有兼容的类型")]),t._v(" "),a("li",[t._v("需要类型转换的时候， 为模板定义一个非成员函数")]),t._v(" "),a("li",[t._v("使用traits来表现模板里面的类型信息")]),t._v(" "),a("li",[t._v("什么是template元编程")])]),t._v(" "),a("h2",{attrs:{id:"定制new和delete"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定制new和delete"}},[t._v("#")]),t._v(" 定制new和delete")]),t._v(" "),a("ol",{attrs:{start:"49"}},[a("li",[t._v("new handler的行为（处理new失败时候throw的异常）， 底层是怎样构成的？")]),t._v(" "),a("li",[t._v("operator new和operator delete的合理替换时机；")]),t._v(" "),a("li",[t._v("operator new和operator delete需要遵循的一些规则")]),t._v(" "),a("li",[t._v("placement new和placement delete")])]),t._v(" "),a("h2",{attrs:{id:"一些杂项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一些杂项"}},[t._v("#")]),t._v(" 一些杂项")]),t._v(" "),a("ol",{attrs:{start:"53"}},[a("li",[t._v("编译器的warnning有时候也很重要")]),t._v(" "),a("li",[t._v("熟悉TR1标准库")]),t._v(" "),a("li",[t._v("熟悉boost保准库")])])])}),[],!1,null,null,null);s.default=e.exports}}]);