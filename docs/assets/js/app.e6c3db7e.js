(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function t(t){for(var r,o,s=t[0],c=t[1],l=t[2],p=0,d=[];p<s.length;p++)o=s[p],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&d.push(i[o][0]),i[o]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(n[r]=c[r]);for(u&&u(t);d.length;)d.shift()();return a.push.apply(a,l||[]),e()}function e(){for(var n,t=0;t<a.length;t++){for(var e=a[t],r=!0,s=1;s<e.length;s++){var c=e[s];0!==i[c]&&(r=!1)}r&&(a.splice(t--,1),n=o(o.s=e[0]))}return n}var r={},i={1:0},a=[];function o(t){if(r[t])return r[t].exports;var e=r[t]={i:t,l:!1,exports:{}};return n[t].call(e.exports,e,e.exports,o),e.l=!0,e.exports}o.e=function(n){var t=[],e=i[n];if(0!==e)if(e)t.push(e[2]);else{var r=new Promise((function(t,r){e=i[n]=[t,r]}));t.push(e[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"0eed2333",3:"1c18827c",4:"5c1dc4ce",5:"d89070b9",6:"1e60fa96",7:"77c61ade",8:"2239e66f",9:"cf150e26",10:"2839672e",11:"b5dffaf5",12:"1b0e4a1b",13:"5b153336",14:"c9818bab",15:"e1d4e55a",16:"b5733294",17:"6ebbc744",18:"5bf500e4",19:"e79925d2",20:"a7bc28ab",21:"b607bcc6",22:"bbfb5196",23:"ca136498",24:"c1071b43",25:"6c45a16d",26:"83d3d99a",27:"c9eeaa99",28:"727c4028",29:"e4acda9d",30:"7368254f",31:"8155bf2b",32:"60a19602",33:"699a2b94",34:"aaf5074b"}[n]+".js"}(n);var c=new Error;a=function(t){s.onerror=s.onload=null,clearTimeout(l);var e=i[n];if(0!==e){if(e){var r=t&&("load"===t.type?"missing":t.type),a=t&&t.target&&t.target.src;c.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",c.name="ChunkLoadError",c.type=r,c.request=a,e[1](c)}i[n]=void 0}};var l=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(t)},o.m=n,o.c=r,o.d=function(n,t,e){o.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:e})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,t){if(1&t&&(n=o(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(o.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var r in n)o.d(e,r,function(t){return n[t]}.bind(null,r));return e},o.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(t,"a",t),t},o.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],c=s.push.bind(s);s.push=t,s=s.slice();for(var l=0;l<s.length;l++)t(s[l]);var u=c;a.push([100,0]),e()}([function(n,t){n.exports=function(n){return"function"==typeof n}},function(n,t,e){var r=e(25),i=Function.prototype,a=i.bind,o=i.call,s=r&&a.bind(o,o);n.exports=r?function(n){return n&&s(n)}:function(n){return n&&function(){return o.apply(n,arguments)}}},function(n,t){var e=function(n){return n&&n.Math==Math&&n};n.exports=e("object"==typeof globalThis&&globalThis)||e("object"==typeof window&&window)||e("object"==typeof self&&self)||e("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,t){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,t){var e=Array.isArray;n.exports=e},function(n,t,e){var r=e(67),i="object"==typeof self&&self&&self.Object===Object&&self,a=r||i||Function("return this")();n.exports=a},function(n,t,e){"use strict";function r(n,t,e,r,i,a,o,s){var c,l="function"==typeof n?n.options:n;if(t&&(l.render=t,l.staticRenderFns=e,l._compiled=!0),r&&(l.functional=!0),a&&(l._scopeId="data-v-"+a),o?(c=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},l._ssrRegister=c):i&&(c=s?function(){i.call(this,(l.functional?this.parent:this).$root.$options.shadowRoot)}:i),c)if(l.functional){l._injectStyles=c;var u=l.render;l.render=function(n,t){return c.call(t),u(n,t)}}else{var p=l.beforeCreate;l.beforeCreate=p?[].concat(p,c):[c]}return{exports:n,options:l}}e.d(t,"a",(function(){return r}))},function(n,t,e){var r=e(3);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,t,e){var r=e(1),i=e(45),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,t){return a(i(n),t)}},function(n,t,e){var r=e(0);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,t,e){var r=e(155),i=e(158);n.exports=function(n,t){var e=i(n,t);return r(e)?e:void 0}},function(n,t,e){"use strict";e.d(t,"e",(function(){return r})),e.d(t,"b",(function(){return a})),e.d(t,"j",(function(){return o})),e.d(t,"g",(function(){return c})),e.d(t,"h",(function(){return l})),e.d(t,"i",(function(){return u})),e.d(t,"c",(function(){return p})),e.d(t,"f",(function(){return d})),e.d(t,"l",(function(){return f})),e.d(t,"m",(function(){return h})),e.d(t,"d",(function(){return v})),e.d(t,"k",(function(){return g})),e.d(t,"n",(function(){return y})),e.d(t,"a",(function(){return _}));const r=/#.*$/,i=/\.(md|html)$/,a=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(i,"")}function c(n){return o.test(n)}function l(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function p(n){if(c(n))return n;if(!n)return"404";const t=n.match(r),e=t?t[0]:"",i=s(n);return a.test(i)?n:i+".html"+e}function d(n,t){const e=n.hash,i=function(n){const t=n&&n.match(r);if(t)return t[0]}(t);if(i&&e!==i)return!1;return s(n.path)===s(t)}function f(n,t,e){if(c(t))return{type:"external",path:t};e&&(t=function(n,t,e){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return t+n;const i=t.split("/");e&&i[i.length-1]||i.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const t=a[n];".."===t?i.pop():"."!==t&&i.push(t)}""!==i[0]&&i.unshift("");return i.join("/")}(t,e));const r=s(t);for(let t=0;t<n.length;t++)if(s(n[t].regularPath)===r)return Object.assign({},n[t],{type:"page",path:p(n[t].path)});return console.error(`[vuepress] No matching page found for sidebar item "${t}"`),{}}function h(n,t,e,r){const{pages:i,themeConfig:a}=e,o=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||o.sidebar||a.sidebar))return m(n);const s=o.sidebar||a.sidebar;if(s){const{base:e,config:r}=function(n,t){if(Array.isArray(t))return{base:"/",config:t};for(const r in t)if(0===(e=n,/(\.html|\/)$/.test(e)?e:e+"/").indexOf(encodeURI(r)))return{base:r,config:t[r]};var e;return{}}(t,s);return"auto"===r?m(n):r?r.map(n=>function n(t,e,r,i=1){if("string"==typeof t)return f(e,t,r);if(Array.isArray(t))return Object.assign(f(e,t[0],r),{title:t[1]});{i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=t.children||[];return 0===a.length&&t.path?Object.assign(f(e,t.path,r),{title:t.title}):{type:"group",path:t.path,title:t.title,sidebarDepth:t.sidebarDepth,initialOpenGroupIndex:t.initialOpenGroupIndex,children:a.map(t=>n(t,e,r,i+1)),collapsable:!1!==t.collapsable}}}(n,i,e)):[]}return[]}function m(n){const t=v(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:t.map(t=>({type:"auto",title:t.title,basePath:n.path,path:n.path+"#"+t.slug,children:t.children||[]}))}]}function v(n){let t;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?t=n:t&&(t.children||(t.children=[])).push(n)}),n.filter(n=>2===n.level)}function g(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function y(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function b(n){let t=n.frontmatter.date||n.lastUpdated||new Date,e=new Date(t);return"Invalid Date"==e&&t&&(e=new Date(t.replace(/-/g,"/"))),e.getTime()}function _(n,t){return b(t)-b(n)}},function(n,t){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,t,e){var r=e(14),i=e(140),a=e(141),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?i(n):a(n)}},function(n,t,e){var r=e(5).Symbol;n.exports=r},function(n,t,e){var r=e(7),i=e(61),a=e(96),o=e(24),s=e(52),c=TypeError,l=Object.defineProperty,u=Object.getOwnPropertyDescriptor;t.f=r?a?function(n,t,e){if(o(n),t=s(t),o(e),"function"==typeof n&&"prototype"===t&&"value"in e&&"writable"in e&&!e.writable){var r=u(n,t);r&&r.writable&&(n[t]=e.value,e={configurable:"configurable"in e?e.configurable:r.configurable,enumerable:"enumerable"in e?e.enumerable:r.enumerable,writable:!1})}return l(n,t,e)}:l:function(n,t,e){if(o(n),t=s(t),o(e),i)try{return l(n,t,e)}catch(n){}if("get"in e||"set"in e)throw c("Accessors not supported");return"value"in e&&(n[t]=e.value),n}},function(n,t,e){var r=e(2),i=e(0),a=function(n){return i(n)?n:void 0};n.exports=function(n,t){return arguments.length<2?a(r[n]):r[n]&&r[n][t]}},function(n,t,e){var r=e(7),i=e(15),a=e(29);n.exports=r?function(n,t,e){return i.f(n,t,a(1,e))}:function(n,t,e){return n[t]=e,n}},function(n,t,e){var r=e(145),i=e(146),a=e(147),o=e(148),s=e(149);function c(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=a,c.prototype.has=o,c.prototype.set=s,n.exports=c},function(n,t,e){var r=e(69);n.exports=function(n,t){for(var e=n.length;e--;)if(r(n[e][0],t))return e;return-1}},function(n,t,e){var r=e(10)(Object,"create");n.exports=r},function(n,t,e){var r=e(167);n.exports=function(n,t){var e=n.__data__;return r(t)?e["string"==typeof t?"string":"hash"]:e.map}},function(n,t,e){var r=e(40);n.exports=function(n){if("string"==typeof n||r(n))return n;var t=n+"";return"0"==t&&1/n==-1/0?"-0":t}},function(n,t,e){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,t,e={version:"0.2.0"},r=e.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,t,e){return n<t?t:n>e?e:n}function a(n){return 100*(-1+n)}e.configure=function(n){var t,e;for(t in n)void 0!==(e=n[t])&&n.hasOwnProperty(t)&&(r[t]=e);return this},e.status=null,e.set=function(n){var t=e.isStarted();n=i(n,r.minimum,1),e.status=1===n?null:n;var c=e.render(!t),l=c.querySelector(r.barSelector),u=r.speed,p=r.easing;return c.offsetWidth,o((function(t){""===r.positionUsing&&(r.positionUsing=e.getPositioningCSS()),s(l,function(n,t,e){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+t+"ms "+e,i}(n,u,p)),1===n?(s(c,{transition:"none",opacity:1}),c.offsetWidth,setTimeout((function(){s(c,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){e.remove(),t()}),u)}),u)):setTimeout(t,u)})),this},e.isStarted=function(){return"number"==typeof e.status},e.start=function(){e.status||e.set(0);var n=function(){setTimeout((function(){e.status&&(e.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},e.done=function(n){return n||e.status?e.inc(.3+.5*Math.random()).set(1):this},e.inc=function(n){var t=e.status;return t?("number"!=typeof n&&(n=(1-t)*i(Math.random()*t,.1,.95)),t=i(t+n,0,.994),e.set(t)):e.start()},e.trickle=function(){return e.inc(Math.random()*r.trickleRate)},n=0,t=0,e.promise=function(r){return r&&"resolved"!==r.state()?(0===t&&e.start(),n++,t++,r.always((function(){0==--t?(n=0,e.done()):e.set((n-t)/n)})),this):this},e.render=function(n){if(e.isRendered())return document.getElementById("nprogress");l(document.documentElement,"nprogress-busy");var t=document.createElement("div");t.id="nprogress",t.innerHTML=r.template;var i,o=t.querySelector(r.barSelector),c=n?"-100":a(e.status||0),u=document.querySelector(r.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+c+"%,0,0)"}),r.showSpinner||(i=t.querySelector(r.spinnerSelector))&&d(i),u!=document.body&&l(u,"nprogress-custom-parent"),u.appendChild(t),t},e.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},e.isRendered=function(){return!!document.getElementById("nprogress")},e.getPositioningCSS=function(){var n=document.body.style,t="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return t+"Perspective"in n?"translate3d":t+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function t(){var e=n.shift();e&&e(t)}return function(e){n.push(e),1==n.length&&t()}}(),s=function(){var n=["Webkit","O","Moz","ms"],t={};function e(e){return e=e.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,t){return t.toUpperCase()})),t[e]||(t[e]=function(t){var e=document.body.style;if(t in e)return t;for(var r,i=n.length,a=t.charAt(0).toUpperCase()+t.slice(1);i--;)if((r=n[i]+a)in e)return r;return t}(e))}function r(n,t,r){t=e(t),n.style[t]=r}return function(n,t){var e,i,a=arguments;if(2==a.length)for(e in t)void 0!==(i=t[e])&&t.hasOwnProperty(e)&&r(n,e,i);else r(n,a[1],a[2])}}();function c(n,t){return("string"==typeof n?n:p(n)).indexOf(" "+t+" ")>=0}function l(n,t){var e=p(n),r=e+t;c(e,t)||(n.className=r.substring(1))}function u(n,t){var e,r=p(n);c(n,t)&&(e=r.replace(" "+t+" "," "),n.className=e.substring(1,e.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return e})?r.call(t,e,t,n):r)||(n.exports=i)},function(n,t,e){var r=e(9),i=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw a(i(n)+" is not an object")}},function(n,t,e){var r=e(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,t,e){var r=e(43),i=e(51);n.exports=function(n){return r(i(n))}},function(n,t,e){var r=e(2),i=e(58),a=e(8),o=e(60),s=e(56),c=e(55),l=i("wks"),u=r.Symbol,p=u&&u.for,d=c?u:u&&u.withoutSetter||o;n.exports=function(n){if(!a(l,n)||!s&&"string"!=typeof l[n]){var t="Symbol."+n;s&&a(u,n)?l[n]=u[n]:l[n]=c&&p?p(t):d(t)}return l[n]}},function(n,t,e){var r=e(25),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,t){n.exports=function(n,t){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:t}}},function(n,t,e){var r=e(1),i=r({}.toString),a=r("".slice);n.exports=function(n){return a(i(n),8,-1)}},function(n,t,e){var r=e(2),i=e(32),a=r["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=a},function(n,t,e){var r=e(2),i=Object.defineProperty;n.exports=function(n,t){try{i(r,n,{value:t,configurable:!0,writable:!0})}catch(e){r[n]=t}return t}},function(n,t,e){var r=e(139),i=e(12),a=Object.prototype,o=a.hasOwnProperty,s=a.propertyIsEnumerable,c=r(function(){return arguments}())?r:function(n){return i(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=c},function(n,t,e){var r=e(10)(e(5),"Map");n.exports=r},function(n,t){n.exports=function(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)}},function(n,t,e){var r=e(159),i=e(166),a=e(168),o=e(169),s=e(170);function c(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=a,c.prototype.has=o,c.prototype.set=s,n.exports=c},function(n,t){n.exports=function(n){var t=-1,e=Array(n.size);return n.forEach((function(n){e[++t]=n})),e}},function(n,t){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,t,e){var r=e(4),i=e(40),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,t){if(r(n))return!1;var e=typeof n;return!("number"!=e&&"symbol"!=e&&"boolean"!=e&&null!=n&&!i(n))||(o.test(n)||!a.test(n)||null!=t&&n in Object(t))}},function(n,t,e){var r=e(13),i=e(12);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,t){n.exports=function(n){return n}},function(n,t,e){var r=e(2),i=e(50).f,a=e(17),o=e(108),s=e(32),c=e(63),l=e(120);n.exports=function(n,t){var e,u,p,d,f,h=n.target,m=n.global,v=n.stat;if(e=m?r:v?r[h]||s(h,{}):(r[h]||{}).prototype)for(u in t){if(d=t[u],p=n.dontCallGetSet?(f=i(e,u))&&f.value:e[u],!l(m?u:h+(v?".":"#")+u,n.forced)&&void 0!==p){if(typeof d==typeof p)continue;c(d,p)}(n.sham||p&&p.sham)&&a(d,"sham",!0),o(e,u,d,n)}}},function(n,t,e){var r=e(1),i=e(3),a=e(30),o=Object,s=r("".split);n.exports=i((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?s(n,""):o(n)}:o},function(n,t,e){var r=e(0),i=e(106),a=TypeError;n.exports=function(n){if(r(n))return n;throw a(i(n)+" is not a function")}},function(n,t,e){var r=e(51),i=Object;n.exports=function(n){return i(r(n))}},function(n,t){n.exports={}},function(n,t,e){var r=e(118);n.exports=function(n){return r(n.length)}},function(n,t){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,t){var e=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,a=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,c="object"==typeof self&&self&&self.Object===Object&&self,l=s||c||Function("return this")(),u=Object.prototype.toString,p=Math.max,d=Math.min,f=function(){return l.Date.now()};function h(n){var t=typeof n;return!!n&&("object"==t||"function"==t)}function m(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(h(n)){var t="function"==typeof n.valueOf?n.valueOf():n;n=h(t)?t+"":t}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(e,"");var s=i.test(n);return s||a.test(n)?o(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,t,e){var r,i,a,o,s,c,l=0,u=!1,v=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function y(t){var e=r,a=i;return r=i=void 0,l=t,o=n.apply(a,e)}function b(n){return l=n,s=setTimeout(x,t),u?y(n):o}function _(n){var e=n-c;return void 0===c||e>=t||e<0||v&&n-l>=a}function x(){var n=f();if(_(n))return w(n);s=setTimeout(x,function(n){var e=t-(n-c);return v?d(e,a-(n-l)):e}(n))}function w(n){return s=void 0,g&&r?y(n):(r=i=void 0,o)}function C(){var n=f(),e=_(n);if(r=arguments,i=this,c=n,e){if(void 0===s)return b(c);if(v)return s=setTimeout(x,t),y(c)}return void 0===s&&(s=setTimeout(x,t)),o}return t=m(t)||0,h(e)&&(u=!!e.leading,a=(v="maxWait"in e)?p(m(e.maxWait)||0,t):a,g="trailing"in e?!!e.trailing:g),C.cancel=function(){void 0!==s&&clearTimeout(s),l=0,r=c=i=s=void 0},C.flush=function(){return void 0===s?o:w(f())},C}},function(n,t,e){var r=e(7),i=e(28),a=e(102),o=e(29),s=e(26),c=e(52),l=e(8),u=e(61),p=Object.getOwnPropertyDescriptor;t.f=r?p:function(n,t){if(n=s(n),t=c(t),u)try{return p(n,t)}catch(n){}if(l(n,t))return o(!i(a.f,n,t),n[t])}},function(n,t){var e=TypeError;n.exports=function(n){if(null==n)throw e("Can't call method on "+n);return n}},function(n,t,e){var r=e(103),i=e(53);n.exports=function(n){var t=r(n,"string");return i(t)?t:t+""}},function(n,t,e){var r=e(16),i=e(0),a=e(54),o=e(55),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var t=r("Symbol");return i(t)&&a(t.prototype,s(n))}},function(n,t,e){var r=e(1);n.exports=r({}.isPrototypeOf)},function(n,t,e){var r=e(56);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,t,e){var r=e(57),i=e(3);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,t,e){var r,i,a=e(2),o=e(104),s=a.process,c=a.Deno,l=s&&s.versions||c&&c.version,u=l&&l.v8;u&&(i=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,t,e){var r=e(59),i=e(31);(n.exports=function(n,t){return i[n]||(i[n]=void 0!==t?t:{})})("versions",[]).push({version:"3.23.3",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,t){n.exports=!1},function(n,t,e){var r=e(1),i=0,a=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++i+a,36)}},function(n,t,e){var r=e(7),i=e(3),a=e(95);n.exports=!r&&!i((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,t,e){var r=e(1),i=e(0),a=e(31),o=r(Function.toString);i(a.inspectSource)||(a.inspectSource=function(n){return o(n)}),n.exports=a.inspectSource},function(n,t,e){var r=e(8),i=e(113),a=e(50),o=e(15);n.exports=function(n,t,e){for(var s=i(t),c=o.f,l=a.f,u=0;u<s.length;u++){var p=s[u];r(n,p)||e&&r(e,p)||c(n,p,l(t,p))}}},function(n,t,e){var r=e(117);n.exports=function(n){var t=+n;return t!=t||0===t?0:r(t)}},function(n,t,e){var r=e(1),i=e(24),a=e(127);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,t=!1,e={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(e,[]),t=e instanceof Array}catch(n){}return function(e,r){return i(e),a(r),t?n(e,r):e.__proto__=r,e}}():void 0)},function(n,t){n.exports=function(n,t){for(var e=-1,r=t.length,i=n.length;++e<r;)n[i+e]=t[e];return n}},function(n,t){var e="object"==typeof global&&global&&global.Object===Object&&global;n.exports=e},function(n,t,e){var r=e(18),i=e(150),a=e(151),o=e(152),s=e(153),c=e(154);function l(n){var t=this.__data__=new r(n);this.size=t.size}l.prototype.clear=i,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=s,l.prototype.set=c,n.exports=l},function(n,t){n.exports=function(n,t){return n===t||n!=n&&t!=t}},function(n,t,e){var r=e(13),i=e(35);n.exports=function(n){if(!i(n))return!1;var t=r(n);return"[object Function]"==t||"[object GeneratorFunction]"==t||"[object AsyncFunction]"==t||"[object Proxy]"==t}},function(n,t){var e=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return e.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,t,e){var r=e(171),i=e(12);n.exports=function n(t,e,a,o,s){return t===e||(null==t||null==e||!i(t)&&!i(e)?t!=t&&e!=e:r(t,e,a,o,n,s))}},function(n,t,e){var r=e(74),i=e(174),a=e(75);n.exports=function(n,t,e,o,s,c){var l=1&e,u=n.length,p=t.length;if(u!=p&&!(l&&p>u))return!1;var d=c.get(n),f=c.get(t);if(d&&f)return d==t&&f==n;var h=-1,m=!0,v=2&e?new r:void 0;for(c.set(n,t),c.set(t,n);++h<u;){var g=n[h],y=t[h];if(o)var b=l?o(y,g,h,t,n,c):o(g,y,h,n,t,c);if(void 0!==b){if(b)continue;m=!1;break}if(v){if(!i(t,(function(n,t){if(!a(v,t)&&(g===n||s(g,n,e,o,c)))return v.push(t)}))){m=!1;break}}else if(g!==y&&!s(g,y,e,o,c)){m=!1;break}}return c.delete(n),c.delete(t),m}},function(n,t,e){var r=e(36),i=e(172),a=e(173);function o(n){var t=-1,e=null==n?0:n.length;for(this.__data__=new r;++t<e;)this.add(n[t])}o.prototype.add=o.prototype.push=i,o.prototype.has=a,n.exports=o},function(n,t){n.exports=function(n,t){return n.has(t)}},function(n,t,e){var r=e(184),i=e(190),a=e(80);n.exports=function(n){return a(n)?r(n):i(n)}},function(n,t,e){(function(n){var r=e(5),i=e(186),a=t&&!t.nodeType&&t,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===a?r.Buffer:void 0,c=(s?s.isBuffer:void 0)||i;n.exports=c}).call(this,e(48)(n))},function(n,t){var e=/^(?:0|[1-9]\d*)$/;n.exports=function(n,t){var r=typeof n;return!!(t=null==t?9007199254740991:t)&&("number"==r||"symbol"!=r&&e.test(n))&&n>-1&&n%1==0&&n<t}},function(n,t,e){var r=e(187),i=e(188),a=e(189),o=a&&a.isTypedArray,s=o?i(o):r;n.exports=s},function(n,t,e){var r=e(70),i=e(38);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,t,e){var r=e(10)(e(5),"Set");n.exports=r},function(n,t,e){var r=e(35);n.exports=function(n){return n==n&&!r(n)}},function(n,t){n.exports=function(n,t){return function(e){return null!=e&&(e[n]===t&&(void 0!==t||n in Object(e)))}}},function(n,t,e){var r=e(85),i=e(22);n.exports=function(n,t){for(var e=0,a=(t=r(t,n)).length;null!=n&&e<a;)n=n[i(t[e++])];return e&&e==a?n:void 0}},function(n,t,e){var r=e(4),i=e(39),a=e(201),o=e(204);n.exports=function(n,t){return r(n)?n:i(n,t)?[n]:a(o(n))}},function(n,t,e){},function(n,t,e){},function(n,t,e){},function(n,t,e){},function(n,t,e){var r=e(137),i=e(142),a=e(213),o=e(221),s=e(230),c=e(99),l=a((function(n){var t=c(n);return s(t)&&(t=void 0),o(r(n,1,s,!0),i(t,2))}));n.exports=l},function(n,t,e){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var t,e=""+n,i=r.exec(e);if(!i)return e;var a="",o=0,s=0;for(o=i.index;o<e.length;o++){switch(e.charCodeAt(o)){case 34:t="&quot;";break;case 38:t="&amp;";break;case 39:t="&#39;";break;case 60:t="&lt;";break;case 62:t="&gt;";break;default:continue}s!==o&&(a+=e.substring(s,o)),s=o+1,a+=t}return s!==o?a+e.substring(s,o):a}},function(n,t,e){"use strict";e.r(t);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(e(233),e(6)),a=Object(i.a)(r,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"5a3e6e86",null);t.default=a.exports},function(n,t,e){"use strict";e.r(t);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,t)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=t),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},i=(e(234),e(6)),a=Object(i.a)(r,(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(t){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"392329f0",null);t.default=a.exports},function(n,t){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,t,e){var r=e(2),i=e(9),a=r.document,o=i(a)&&i(a.createElement);n.exports=function(n){return o?a.createElement(n):{}}},function(n,t,e){var r=e(7),i=e(3);n.exports=r&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,t,e){var r=e(58),i=e(60),a=r("keys");n.exports=function(n){return a[n]||(a[n]=i(n))}},function(n,t,e){var r=e(1),i=e(8),a=e(26),o=e(115).indexOf,s=e(46),c=r([].push);n.exports=function(n,t){var e,r=a(n),l=0,u=[];for(e in r)!i(s,e)&&i(r,e)&&c(u,e);for(;t.length>l;)i(r,e=t[l++])&&(~o(u,e)||c(u,e));return u}},function(n,t){n.exports=function(n){var t=null==n?0:n.length;return t?n[t-1]:void 0}},function(n,t,e){n.exports=e(239)},function(n,t,e){"use strict";var r=e(42),i=e(121).left,a=e(122),o=e(57),s=e(123);r({target:"Array",proto:!0,forced:!a("reduce")||!s&&o>79&&o<83},{reduce:function(n){var t=arguments.length;return i(this,n,t,t>1?arguments[1]:void 0)}})},function(n,t,e){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,a=i&&!r.call({1:2},1);t.f=a?function(n){var t=i(this,n);return!!t&&t.enumerable}:r},function(n,t,e){var r=e(28),i=e(9),a=e(53),o=e(105),s=e(107),c=e(27),l=TypeError,u=c("toPrimitive");n.exports=function(n,t){if(!i(n)||a(n))return n;var e,c=o(n,u);if(c){if(void 0===t&&(t="default"),e=r(c,n,t),!i(e)||a(e))return e;throw l("Can't convert object to primitive value")}return void 0===t&&(t="number"),s(n,t)}},function(n,t,e){var r=e(16);n.exports=r("navigator","userAgent")||""},function(n,t,e){var r=e(44);n.exports=function(n,t){var e=n[t];return null==e?void 0:r(e)}},function(n,t){var e=String;n.exports=function(n){try{return e(n)}catch(n){return"Object"}}},function(n,t,e){var r=e(28),i=e(0),a=e(9),o=TypeError;n.exports=function(n,t){var e,s;if("string"===t&&i(e=n.toString)&&!a(s=r(e,n)))return s;if(i(e=n.valueOf)&&!a(s=r(e,n)))return s;if("string"!==t&&i(e=n.toString)&&!a(s=r(e,n)))return s;throw o("Can't convert object to primitive value")}},function(n,t,e){var r=e(0),i=e(15),a=e(109),o=e(32);n.exports=function(n,t,e,s){s||(s={});var c=s.enumerable,l=void 0!==s.name?s.name:t;if(r(e)&&a(e,l,s),s.global)c?n[t]=e:o(t,e);else{try{s.unsafe?n[t]&&(c=!0):delete n[t]}catch(n){}c?n[t]=e:i.f(n,t,{value:e,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,t,e){var r=e(3),i=e(0),a=e(8),o=e(7),s=e(110).CONFIGURABLE,c=e(62),l=e(111),u=l.enforce,p=l.get,d=Object.defineProperty,f=o&&!r((function(){return 8!==d((function(){}),"length",{value:8}).length})),h=String(String).split("String"),m=n.exports=function(n,t,e){"Symbol("===String(t).slice(0,7)&&(t="["+String(t).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),e&&e.getter&&(t="get "+t),e&&e.setter&&(t="set "+t),(!a(n,"name")||s&&n.name!==t)&&(o?d(n,"name",{value:t,configurable:!0}):n.name=t),f&&e&&a(e,"arity")&&n.length!==e.arity&&d(n,"length",{value:e.arity});try{e&&a(e,"constructor")&&e.constructor?o&&d(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=u(n);return a(r,"source")||(r.source=h.join("string"==typeof t?t:"")),n};Function.prototype.toString=m((function(){return i(this)&&p(this).source||c(this)}),"toString")},function(n,t,e){var r=e(7),i=e(8),a=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,s=i(a,"name"),c=s&&"something"===function(){}.name,l=s&&(!r||r&&o(a,"name").configurable);n.exports={EXISTS:s,PROPER:c,CONFIGURABLE:l}},function(n,t,e){var r,i,a,o=e(112),s=e(2),c=e(1),l=e(9),u=e(17),p=e(8),d=e(31),f=e(97),h=e(46),m=s.TypeError,v=s.WeakMap;if(o||d.state){var g=d.state||(d.state=new v),y=c(g.get),b=c(g.has),_=c(g.set);r=function(n,t){if(b(g,n))throw new m("Object already initialized");return t.facade=n,_(g,n,t),t},i=function(n){return y(g,n)||{}},a=function(n){return b(g,n)}}else{var x=f("state");h[x]=!0,r=function(n,t){if(p(n,x))throw new m("Object already initialized");return t.facade=n,u(n,x,t),t},i=function(n){return p(n,x)?n[x]:{}},a=function(n){return p(n,x)}}n.exports={set:r,get:i,has:a,enforce:function(n){return a(n)?i(n):r(n,{})},getterFor:function(n){return function(t){var e;if(!l(t)||(e=i(t)).type!==n)throw m("Incompatible receiver, "+n+" required");return e}}}},function(n,t,e){var r=e(2),i=e(0),a=e(62),o=r.WeakMap;n.exports=i(o)&&/native code/.test(a(o))},function(n,t,e){var r=e(16),i=e(1),a=e(114),o=e(119),s=e(24),c=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var t=a.f(s(n)),e=o.f;return e?c(t,e(n)):t}},function(n,t,e){var r=e(98),i=e(94).concat("length","prototype");t.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,t,e){var r=e(26),i=e(116),a=e(47),o=function(n){return function(t,e,o){var s,c=r(t),l=a(c),u=i(o,l);if(n&&e!=e){for(;l>u;)if((s=c[u++])!=s)return!0}else for(;l>u;u++)if((n||u in c)&&c[u]===e)return n||u||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,t,e){var r=e(64),i=Math.max,a=Math.min;n.exports=function(n,t){var e=r(n);return e<0?i(e+t,0):a(e,t)}},function(n,t){var e=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var t=+n;return(t>0?r:e)(t)}},function(n,t,e){var r=e(64),i=Math.min;n.exports=function(n){return n>0?i(r(n),9007199254740991):0}},function(n,t){t.f=Object.getOwnPropertySymbols},function(n,t,e){var r=e(3),i=e(0),a=/#|\.prototype\./,o=function(n,t){var e=c[s(n)];return e==u||e!=l&&(i(t)?r(t):!!t)},s=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},c=o.data={},l=o.NATIVE="N",u=o.POLYFILL="P";n.exports=o},function(n,t,e){var r=e(44),i=e(45),a=e(43),o=e(47),s=TypeError,c=function(n){return function(t,e,c,l){r(e);var u=i(t),p=a(u),d=o(u),f=n?d-1:0,h=n?-1:1;if(c<2)for(;;){if(f in p){l=p[f],f+=h;break}if(f+=h,n?f<0:d<=f)throw s("Reduce of empty array with no initial value")}for(;n?f>=0:d>f;f+=h)f in p&&(l=e(l,p[f],f,u));return l}};n.exports={left:c(!1),right:c(!0)}},function(n,t,e){"use strict";var r=e(3);n.exports=function(n,t){var e=[][n];return!!e&&r((function(){e.call(null,t||function(){return 1},1)}))}},function(n,t,e){var r=e(30),i=e(2);n.exports="process"==r(i.process)},function(n,t,e){var r=e(42),i=e(2),a=e(125),o=e(126),s=i.WebAssembly,c=7!==Error("e",{cause:7}).cause,l=function(n,t){var e={};e[n]=o(n,t,c),r({global:!0,constructor:!0,arity:1,forced:c},e)},u=function(n,t){if(s&&s[n]){var e={};e[n]=o("WebAssembly."+n,t,c),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:c},e)}};l("Error",(function(n){return function(t){return a(n,this,arguments)}})),l("EvalError",(function(n){return function(t){return a(n,this,arguments)}})),l("RangeError",(function(n){return function(t){return a(n,this,arguments)}})),l("ReferenceError",(function(n){return function(t){return a(n,this,arguments)}})),l("SyntaxError",(function(n){return function(t){return a(n,this,arguments)}})),l("TypeError",(function(n){return function(t){return a(n,this,arguments)}})),l("URIError",(function(n){return function(t){return a(n,this,arguments)}})),u("CompileError",(function(n){return function(t){return a(n,this,arguments)}})),u("LinkError",(function(n){return function(t){return a(n,this,arguments)}})),u("RuntimeError",(function(n){return function(t){return a(n,this,arguments)}}))},function(n,t,e){var r=e(25),i=Function.prototype,a=i.apply,o=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(a):function(){return o.apply(a,arguments)})},function(n,t,e){"use strict";var r=e(16),i=e(8),a=e(17),o=e(54),s=e(65),c=e(63),l=e(128),u=e(129),p=e(130),d=e(134),f=e(135),h=e(136),m=e(7),v=e(59);n.exports=function(n,t,e,g){var y=g?2:1,b=n.split("."),_=b[b.length-1],x=r.apply(null,b);if(x){var w=x.prototype;if(!v&&i(w,"cause")&&delete w.cause,!e)return x;var C=r("Error"),k=t((function(n,t){var e=p(g?t:n,void 0),r=g?new x(n):new x;return void 0!==e&&a(r,"message",e),h&&a(r,"stack",f(r.stack,2)),this&&o(w,this)&&u(r,this,k),arguments.length>y&&d(r,arguments[y]),r}));if(k.prototype=w,"Error"!==_?s?s(k,C):c(k,C,{name:!0}):m&&"stackTraceLimit"in x&&(l(k,x,"stackTraceLimit"),l(k,x,"prepareStackTrace")),c(k,x),!v)try{w.name!==_&&a(w,"name",_),w.constructor=k}catch(n){}return k}}},function(n,t,e){var r=e(0),i=String,a=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw a("Can't set "+i(n)+" as a prototype")}},function(n,t,e){var r=e(15).f;n.exports=function(n,t,e){e in n||r(n,e,{configurable:!0,get:function(){return t[e]},set:function(n){t[e]=n}})}},function(n,t,e){var r=e(0),i=e(9),a=e(65);n.exports=function(n,t,e){var o,s;return a&&r(o=t.constructor)&&o!==e&&i(s=o.prototype)&&s!==e.prototype&&a(n,s),n}},function(n,t,e){var r=e(131);n.exports=function(n,t){return void 0===n?arguments.length<2?"":t:r(n)}},function(n,t,e){var r=e(132),i=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,t,e){var r=e(133),i=e(0),a=e(30),o=e(27)("toStringTag"),s=Object,c="Arguments"==a(function(){return arguments}());n.exports=r?a:function(n){var t,e,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(e=function(n,t){try{return n[t]}catch(n){}}(t=s(n),o))?e:c?a(t):"Object"==(r=a(t))&&i(t.callee)?"Arguments":r}},function(n,t,e){var r={};r[e(27)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,t,e){var r=e(9),i=e(17);n.exports=function(n,t){r(t)&&"cause"in t&&i(n,"cause",t.cause)}},function(n,t,e){var r=e(1),i=Error,a=r("".replace),o=String(i("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,c=s.test(o);n.exports=function(n,t){if(c&&"string"==typeof n&&!i.prepareStackTrace)for(;t--;)n=a(n,s,"");return n}},function(n,t,e){var r=e(3),i=e(29);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,t,e){var r=e(66),i=e(138);n.exports=function n(t,e,a,o,s){var c=-1,l=t.length;for(a||(a=i),s||(s=[]);++c<l;){var u=t[c];e>0&&a(u)?e>1?n(u,e-1,a,o,s):r(s,u):o||(s[s.length]=u)}return s}},function(n,t,e){var r=e(14),i=e(33),a=e(4),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||i(n)||!!(o&&n&&n[o])}},function(n,t,e){var r=e(13),i=e(12);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,t,e){var r=e(14),i=Object.prototype,a=i.hasOwnProperty,o=i.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var t=a.call(n,s),e=n[s];try{n[s]=void 0;var r=!0}catch(n){}var i=o.call(n);return r&&(t?n[s]=e:delete n[s]),i}},function(n,t){var e=Object.prototype.toString;n.exports=function(n){return e.call(n)}},function(n,t,e){var r=e(143),i=e(199),a=e(41),o=e(4),s=e(210);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?o(n)?i(n[0],n[1]):r(n):s(n)}},function(n,t,e){var r=e(144),i=e(198),a=e(83);n.exports=function(n){var t=i(n);return 1==t.length&&t[0][2]?a(t[0][0],t[0][1]):function(e){return e===n||r(e,n,t)}}},function(n,t,e){var r=e(68),i=e(72);n.exports=function(n,t,e,a){var o=e.length,s=o,c=!a;if(null==n)return!s;for(n=Object(n);o--;){var l=e[o];if(c&&l[2]?l[1]!==n[l[0]]:!(l[0]in n))return!1}for(;++o<s;){var u=(l=e[o])[0],p=n[u],d=l[1];if(c&&l[2]){if(void 0===p&&!(u in n))return!1}else{var f=new r;if(a)var h=a(p,d,u,n,t,f);if(!(void 0===h?i(d,p,3,a,f):h))return!1}}return!0}},function(n,t){n.exports=function(){this.__data__=[],this.size=0}},function(n,t,e){var r=e(19),i=Array.prototype.splice;n.exports=function(n){var t=this.__data__,e=r(t,n);return!(e<0)&&(e==t.length-1?t.pop():i.call(t,e,1),--this.size,!0)}},function(n,t,e){var r=e(19);n.exports=function(n){var t=this.__data__,e=r(t,n);return e<0?void 0:t[e][1]}},function(n,t,e){var r=e(19);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,t,e){var r=e(19);n.exports=function(n,t){var e=this.__data__,i=r(e,n);return i<0?(++this.size,e.push([n,t])):e[i][1]=t,this}},function(n,t,e){var r=e(18);n.exports=function(){this.__data__=new r,this.size=0}},function(n,t){n.exports=function(n){var t=this.__data__,e=t.delete(n);return this.size=t.size,e}},function(n,t){n.exports=function(n){return this.__data__.get(n)}},function(n,t){n.exports=function(n){return this.__data__.has(n)}},function(n,t,e){var r=e(18),i=e(34),a=e(36);n.exports=function(n,t){var e=this.__data__;if(e instanceof r){var o=e.__data__;if(!i||o.length<199)return o.push([n,t]),this.size=++e.size,this;e=this.__data__=new a(o)}return e.set(n,t),this.size=e.size,this}},function(n,t,e){var r=e(70),i=e(156),a=e(35),o=e(71),s=/^\[object .+?Constructor\]$/,c=Function.prototype,l=Object.prototype,u=c.toString,p=l.hasOwnProperty,d=RegExp("^"+u.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||i(n))&&(r(n)?d:s).test(o(n))}},function(n,t,e){var r,i=e(157),a=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,t,e){var r=e(5)["__core-js_shared__"];n.exports=r},function(n,t){n.exports=function(n,t){return null==n?void 0:n[t]}},function(n,t,e){var r=e(160),i=e(18),a=e(34);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||i),string:new r}}},function(n,t,e){var r=e(161),i=e(162),a=e(163),o=e(164),s=e(165);function c(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=a,c.prototype.has=o,c.prototype.set=s,n.exports=c},function(n,t,e){var r=e(20);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,t){n.exports=function(n){var t=this.has(n)&&delete this.__data__[n];return this.size-=t?1:0,t}},function(n,t,e){var r=e(20),i=Object.prototype.hasOwnProperty;n.exports=function(n){var t=this.__data__;if(r){var e=t[n];return"__lodash_hash_undefined__"===e?void 0:e}return i.call(t,n)?t[n]:void 0}},function(n,t,e){var r=e(20),i=Object.prototype.hasOwnProperty;n.exports=function(n){var t=this.__data__;return r?void 0!==t[n]:i.call(t,n)}},function(n,t,e){var r=e(20);n.exports=function(n,t){var e=this.__data__;return this.size+=this.has(n)?0:1,e[n]=r&&void 0===t?"__lodash_hash_undefined__":t,this}},function(n,t,e){var r=e(21);n.exports=function(n){var t=r(this,n).delete(n);return this.size-=t?1:0,t}},function(n,t){n.exports=function(n){var t=typeof n;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==n:null===n}},function(n,t,e){var r=e(21);n.exports=function(n){return r(this,n).get(n)}},function(n,t,e){var r=e(21);n.exports=function(n){return r(this,n).has(n)}},function(n,t,e){var r=e(21);n.exports=function(n,t){var e=r(this,n),i=e.size;return e.set(n,t),this.size+=e.size==i?0:1,this}},function(n,t,e){var r=e(68),i=e(73),a=e(175),o=e(178),s=e(194),c=e(4),l=e(77),u=e(79),p="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,t,e,f,h,m){var v=c(n),g=c(t),y=v?"[object Array]":s(n),b=g?"[object Array]":s(t),_=(y="[object Arguments]"==y?p:y)==p,x=(b="[object Arguments]"==b?p:b)==p,w=y==b;if(w&&l(n)){if(!l(t))return!1;v=!0,_=!1}if(w&&!_)return m||(m=new r),v||u(n)?i(n,t,e,f,h,m):a(n,t,y,e,f,h,m);if(!(1&e)){var C=_&&d.call(n,"__wrapped__"),k=x&&d.call(t,"__wrapped__");if(C||k){var T=C?n.value():n,S=k?t.value():t;return m||(m=new r),h(T,S,e,f,m)}}return!!w&&(m||(m=new r),o(n,t,e,f,h,m))}},function(n,t){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,t){n.exports=function(n){return this.__data__.has(n)}},function(n,t){n.exports=function(n,t){for(var e=-1,r=null==n?0:n.length;++e<r;)if(t(n[e],e,n))return!0;return!1}},function(n,t,e){var r=e(14),i=e(176),a=e(69),o=e(73),s=e(177),c=e(37),l=r?r.prototype:void 0,u=l?l.valueOf:void 0;n.exports=function(n,t,e,r,l,p,d){switch(e){case"[object DataView]":if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)return!1;n=n.buffer,t=t.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=t.byteLength||!p(new i(n),new i(t)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+t);case"[object Error]":return n.name==t.name&&n.message==t.message;case"[object RegExp]":case"[object String]":return n==t+"";case"[object Map]":var f=s;case"[object Set]":var h=1&r;if(f||(f=c),n.size!=t.size&&!h)return!1;var m=d.get(n);if(m)return m==t;r|=2,d.set(n,t);var v=o(f(n),f(t),r,l,p,d);return d.delete(n),v;case"[object Symbol]":if(u)return u.call(n)==u.call(t)}return!1}},function(n,t,e){var r=e(5).Uint8Array;n.exports=r},function(n,t){n.exports=function(n){var t=-1,e=Array(n.size);return n.forEach((function(n,r){e[++t]=[r,n]})),e}},function(n,t,e){var r=e(179),i=Object.prototype.hasOwnProperty;n.exports=function(n,t,e,a,o,s){var c=1&e,l=r(n),u=l.length;if(u!=r(t).length&&!c)return!1;for(var p=u;p--;){var d=l[p];if(!(c?d in t:i.call(t,d)))return!1}var f=s.get(n),h=s.get(t);if(f&&h)return f==t&&h==n;var m=!0;s.set(n,t),s.set(t,n);for(var v=c;++p<u;){var g=n[d=l[p]],y=t[d];if(a)var b=c?a(y,g,d,t,n,s):a(g,y,d,n,t,s);if(!(void 0===b?g===y||o(g,y,e,a,s):b)){m=!1;break}v||(v="constructor"==d)}if(m&&!v){var _=n.constructor,x=t.constructor;_==x||!("constructor"in n)||!("constructor"in t)||"function"==typeof _&&_ instanceof _&&"function"==typeof x&&x instanceof x||(m=!1)}return s.delete(n),s.delete(t),m}},function(n,t,e){var r=e(180),i=e(181),a=e(76);n.exports=function(n){return r(n,a,i)}},function(n,t,e){var r=e(66),i=e(4);n.exports=function(n,t,e){var a=t(n);return i(n)?a:r(a,e(n))}},function(n,t,e){var r=e(182),i=e(183),a=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(t){return a.call(n,t)})))}:i;n.exports=s},function(n,t){n.exports=function(n,t){for(var e=-1,r=null==n?0:n.length,i=0,a=[];++e<r;){var o=n[e];t(o,e,n)&&(a[i++]=o)}return a}},function(n,t){n.exports=function(){return[]}},function(n,t,e){var r=e(185),i=e(33),a=e(4),o=e(77),s=e(78),c=e(79),l=Object.prototype.hasOwnProperty;n.exports=function(n,t){var e=a(n),u=!e&&i(n),p=!e&&!u&&o(n),d=!e&&!u&&!p&&c(n),f=e||u||p||d,h=f?r(n.length,String):[],m=h.length;for(var v in n)!t&&!l.call(n,v)||f&&("length"==v||p&&("offset"==v||"parent"==v)||d&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||s(v,m))||h.push(v);return h}},function(n,t){n.exports=function(n,t){for(var e=-1,r=Array(n);++e<n;)r[e]=t(e);return r}},function(n,t){n.exports=function(){return!1}},function(n,t,e){var r=e(13),i=e(38),a=e(12),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&i(n.length)&&!!o[r(n)]}},function(n,t){n.exports=function(n){return function(t){return n(t)}}},function(n,t,e){(function(n){var r=e(67),i=t&&!t.nodeType&&t,a=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=a&&a.exports===i&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,e(48)(n))},function(n,t,e){var r=e(191),i=e(192),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var t=[];for(var e in Object(n))a.call(n,e)&&"constructor"!=e&&t.push(e);return t}},function(n,t){var e=Object.prototype;n.exports=function(n){var t=n&&n.constructor;return n===("function"==typeof t&&t.prototype||e)}},function(n,t,e){var r=e(193)(Object.keys,Object);n.exports=r},function(n,t){n.exports=function(n,t){return function(e){return n(t(e))}}},function(n,t,e){var r=e(195),i=e(34),a=e(196),o=e(81),s=e(197),c=e(13),l=e(71),u=l(r),p=l(i),d=l(a),f=l(o),h=l(s),m=c;(r&&"[object DataView]"!=m(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=m(new i)||a&&"[object Promise]"!=m(a.resolve())||o&&"[object Set]"!=m(new o)||s&&"[object WeakMap]"!=m(new s))&&(m=function(n){var t=c(n),e="[object Object]"==t?n.constructor:void 0,r=e?l(e):"";if(r)switch(r){case u:return"[object DataView]";case p:return"[object Map]";case d:return"[object Promise]";case f:return"[object Set]";case h:return"[object WeakMap]"}return t}),n.exports=m},function(n,t,e){var r=e(10)(e(5),"DataView");n.exports=r},function(n,t,e){var r=e(10)(e(5),"Promise");n.exports=r},function(n,t,e){var r=e(10)(e(5),"WeakMap");n.exports=r},function(n,t,e){var r=e(82),i=e(76);n.exports=function(n){for(var t=i(n),e=t.length;e--;){var a=t[e],o=n[a];t[e]=[a,o,r(o)]}return t}},function(n,t,e){var r=e(72),i=e(200),a=e(207),o=e(39),s=e(82),c=e(83),l=e(22);n.exports=function(n,t){return o(n)&&s(t)?c(l(n),t):function(e){var o=i(e,n);return void 0===o&&o===t?a(e,n):r(t,o,3)}}},function(n,t,e){var r=e(84);n.exports=function(n,t,e){var i=null==n?void 0:r(n,t);return void 0===i?e:i}},function(n,t,e){var r=e(202),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,o=r((function(n){var t=[];return 46===n.charCodeAt(0)&&t.push(""),n.replace(i,(function(n,e,r,i){t.push(r?i.replace(a,"$1"):e||n)})),t}));n.exports=o},function(n,t,e){var r=e(203);n.exports=function(n){var t=r(n,(function(n){return 500===e.size&&e.clear(),n})),e=t.cache;return t}},function(n,t,e){var r=e(36);function i(n,t){if("function"!=typeof n||null!=t&&"function"!=typeof t)throw new TypeError("Expected a function");var e=function(){var r=arguments,i=t?t.apply(this,r):r[0],a=e.cache;if(a.has(i))return a.get(i);var o=n.apply(this,r);return e.cache=a.set(i,o)||a,o};return e.cache=new(i.Cache||r),e}i.Cache=r,n.exports=i},function(n,t,e){var r=e(205);n.exports=function(n){return null==n?"":r(n)}},function(n,t,e){var r=e(14),i=e(206),a=e(4),o=e(40),s=r?r.prototype:void 0,c=s?s.toString:void 0;n.exports=function n(t){if("string"==typeof t)return t;if(a(t))return i(t,n)+"";if(o(t))return c?c.call(t):"";var e=t+"";return"0"==e&&1/t==-1/0?"-0":e}},function(n,t){n.exports=function(n,t){for(var e=-1,r=null==n?0:n.length,i=Array(r);++e<r;)i[e]=t(n[e],e,n);return i}},function(n,t,e){var r=e(208),i=e(209);n.exports=function(n,t){return null!=n&&i(n,t,r)}},function(n,t){n.exports=function(n,t){return null!=n&&t in Object(n)}},function(n,t,e){var r=e(85),i=e(33),a=e(4),o=e(78),s=e(38),c=e(22);n.exports=function(n,t,e){for(var l=-1,u=(t=r(t,n)).length,p=!1;++l<u;){var d=c(t[l]);if(!(p=null!=n&&e(n,d)))break;n=n[d]}return p||++l!=u?p:!!(u=null==n?0:n.length)&&s(u)&&o(d,u)&&(a(n)||i(n))}},function(n,t,e){var r=e(211),i=e(212),a=e(39),o=e(22);n.exports=function(n){return a(n)?r(o(n)):i(n)}},function(n,t){n.exports=function(n){return function(t){return null==t?void 0:t[n]}}},function(n,t,e){var r=e(84);n.exports=function(n){return function(t){return r(t,n)}}},function(n,t,e){var r=e(41),i=e(214),a=e(216);n.exports=function(n,t){return a(i(n,t,r),n+"")}},function(n,t,e){var r=e(215),i=Math.max;n.exports=function(n,t,e){return t=i(void 0===t?n.length-1:t,0),function(){for(var a=arguments,o=-1,s=i(a.length-t,0),c=Array(s);++o<s;)c[o]=a[t+o];o=-1;for(var l=Array(t+1);++o<t;)l[o]=a[o];return l[t]=e(c),r(n,this,l)}}},function(n,t){n.exports=function(n,t,e){switch(e.length){case 0:return n.call(t);case 1:return n.call(t,e[0]);case 2:return n.call(t,e[0],e[1]);case 3:return n.call(t,e[0],e[1],e[2])}return n.apply(t,e)}},function(n,t,e){var r=e(217),i=e(220)(r);n.exports=i},function(n,t,e){var r=e(218),i=e(219),a=e(41),o=i?function(n,t){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(t),writable:!0})}:a;n.exports=o},function(n,t){n.exports=function(n){return function(){return n}}},function(n,t,e){var r=e(10),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,t){var e=Date.now;n.exports=function(n){var t=0,r=0;return function(){var i=e(),a=16-(i-r);if(r=i,a>0){if(++t>=800)return arguments[0]}else t=0;return n.apply(void 0,arguments)}}},function(n,t,e){var r=e(74),i=e(222),a=e(227),o=e(75),s=e(228),c=e(37);n.exports=function(n,t,e){var l=-1,u=i,p=n.length,d=!0,f=[],h=f;if(e)d=!1,u=a;else if(p>=200){var m=t?null:s(n);if(m)return c(m);d=!1,u=o,h=new r}else h=t?[]:f;n:for(;++l<p;){var v=n[l],g=t?t(v):v;if(v=e||0!==v?v:0,d&&g==g){for(var y=h.length;y--;)if(h[y]===g)continue n;t&&h.push(g),f.push(v)}else u(h,g,e)||(h!==f&&h.push(g),f.push(v))}return f}},function(n,t,e){var r=e(223);n.exports=function(n,t){return!!(null==n?0:n.length)&&r(n,t,0)>-1}},function(n,t,e){var r=e(224),i=e(225),a=e(226);n.exports=function(n,t,e){return t==t?a(n,t,e):r(n,i,e)}},function(n,t){n.exports=function(n,t,e,r){for(var i=n.length,a=e+(r?1:-1);r?a--:++a<i;)if(t(n[a],a,n))return a;return-1}},function(n,t){n.exports=function(n){return n!=n}},function(n,t){n.exports=function(n,t,e){for(var r=e-1,i=n.length;++r<i;)if(n[r]===t)return r;return-1}},function(n,t){n.exports=function(n,t,e){for(var r=-1,i=null==n?0:n.length;++r<i;)if(e(t,n[r]))return!0;return!1}},function(n,t,e){var r=e(81),i=e(229),a=e(37),o=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=o},function(n,t){n.exports=function(){}},function(n,t,e){var r=e(80),i=e(12);n.exports=function(n){return i(n)&&r(n)}},function(n,t,e){},function(n,t,e){},function(n,t,e){"use strict";e(86)},function(n,t,e){"use strict";e(87)},function(n,t,e){},function(n,t,e){},function(n,t,e){"use strict";e(88)},function(n,t,e){"use strict";e(89)},function(n,t,e){"use strict";e.r(t);
/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({});function i(n){return null==n}function a(n){return null!=n}function o(n){return!0===n}function s(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return null!==n&&"object"==typeof n}var l=Object.prototype.toString;function u(n){return"[object Object]"===l.call(n)}function p(n){return"[object RegExp]"===l.call(n)}function d(n){var t=parseFloat(String(n));return t>=0&&Math.floor(t)===t&&isFinite(n)}function f(n){return a(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function h(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===l?JSON.stringify(n,null,2):String(n)}function m(n){var t=parseFloat(n);return isNaN(t)?n:t}function v(n,t){for(var e=Object.create(null),r=n.split(","),i=0;i<r.length;i++)e[r[i]]=!0;return t?function(n){return e[n.toLowerCase()]}:function(n){return e[n]}}v("slot,component",!0);var g=v("key,ref,slot,slot-scope,is");function y(n,t){if(n.length){var e=n.indexOf(t);if(e>-1)return n.splice(e,1)}}var b=Object.prototype.hasOwnProperty;function _(n,t){return b.call(n,t)}function x(n){var t=Object.create(null);return function(e){return t[e]||(t[e]=n(e))}}var w=/-(\w)/g,C=x((function(n){return n.replace(w,(function(n,t){return t?t.toUpperCase():""}))})),k=x((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),T=/\B([A-Z])/g,S=x((function(n){return n.replace(T,"-$1").toLowerCase()}));var O=Function.prototype.bind?function(n,t){return n.bind(t)}:function(n,t){function e(e){var r=arguments.length;return r?r>1?n.apply(t,arguments):n.call(t,e):n.call(t)}return e._length=n.length,e};function E(n,t){t=t||0;for(var e=n.length-t,r=new Array(e);e--;)r[e]=n[e+t];return r}function j(n,t){for(var e in t)n[e]=t[e];return n}function P(n){for(var t={},e=0;e<n.length;e++)n[e]&&j(t,n[e]);return t}function A(n,t,e){}var z=function(n,t,e){return!1},I=function(n){return n};function $(n,t){if(n===t)return!0;var e=c(n),r=c(t);if(!e||!r)return!e&&!r&&String(n)===String(t);try{var i=Array.isArray(n),a=Array.isArray(t);if(i&&a)return n.length===t.length&&n.every((function(n,e){return $(n,t[e])}));if(n instanceof Date&&t instanceof Date)return n.getTime()===t.getTime();if(i||a)return!1;var o=Object.keys(n),s=Object.keys(t);return o.length===s.length&&o.every((function(e){return $(n[e],t[e])}))}catch(n){return!1}}function L(n,t){for(var e=0;e<n.length;e++)if($(n[e],t))return e;return-1}function M(n){var t=!1;return function(){t||(t=!0,n.apply(this,arguments))}}var R=["component","directive","filter"],D=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:z,isReservedAttr:z,isUnknownElement:z,getTagNamespace:A,parsePlatformTagName:I,mustUseProp:z,async:!0,_lifecycleHooks:D},B=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function U(n,t,e,r){Object.defineProperty(n,t,{value:e,enumerable:!!r,writable:!0,configurable:!0})}var W=new RegExp("[^"+B.source+".$_\\d]");var F,q="__proto__"in{},V="undefined"!=typeof window,G="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,H=G&&WXEnvironment.platform.toLowerCase(),Y=V&&window.navigator.userAgent.toLowerCase(),J=Y&&/msie|trident/.test(Y),Q=Y&&Y.indexOf("msie 9.0")>0,K=Y&&Y.indexOf("edge/")>0,X=(Y&&Y.indexOf("android"),Y&&/iphone|ipad|ipod|ios/.test(Y)||"ios"===H),Z=(Y&&/chrome\/\d+/.test(Y),Y&&/phantomjs/.test(Y),Y&&Y.match(/firefox\/(\d+)/)),nn={}.watch,tn=!1;if(V)try{var en={};Object.defineProperty(en,"passive",{get:function(){tn=!0}}),window.addEventListener("test-passive",null,en)}catch(n){}var rn=function(){return void 0===F&&(F=!V&&!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),F},an=V&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function on(n){return"function"==typeof n&&/native code/.test(n.toString())}var sn,cn="undefined"!=typeof Symbol&&on(Symbol)&&"undefined"!=typeof Reflect&&on(Reflect.ownKeys);sn="undefined"!=typeof Set&&on(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var ln=A,un=0,pn=function(){this.id=un++,this.subs=[]};pn.prototype.addSub=function(n){this.subs.push(n)},pn.prototype.removeSub=function(n){y(this.subs,n)},pn.prototype.depend=function(){pn.target&&pn.target.addDep(this)},pn.prototype.notify=function(){var n=this.subs.slice();for(var t=0,e=n.length;t<e;t++)n[t].update()},pn.target=null;var dn=[];function fn(n){dn.push(n),pn.target=n}function hn(){dn.pop(),pn.target=dn[dn.length-1]}var mn=function(n,t,e,r,i,a,o,s){this.tag=n,this.data=t,this.children=e,this.text=r,this.elm=i,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},vn={child:{configurable:!0}};vn.child.get=function(){return this.componentInstance},Object.defineProperties(mn.prototype,vn);var gn=function(n){void 0===n&&(n="");var t=new mn;return t.text=n,t.isComment=!0,t};function yn(n){return new mn(void 0,void 0,void 0,String(n))}function bn(n){var t=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return t.ns=n.ns,t.isStatic=n.isStatic,t.key=n.key,t.isComment=n.isComment,t.fnContext=n.fnContext,t.fnOptions=n.fnOptions,t.fnScopeId=n.fnScopeId,t.asyncMeta=n.asyncMeta,t.isCloned=!0,t}var _n=Array.prototype,xn=Object.create(_n);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var t=_n[n];U(xn,n,(function(){for(var e=[],r=arguments.length;r--;)e[r]=arguments[r];var i,a=t.apply(this,e),o=this.__ob__;switch(n){case"push":case"unshift":i=e;break;case"splice":i=e.slice(2)}return i&&o.observeArray(i),o.dep.notify(),a}))}));var wn=Object.getOwnPropertyNames(xn),Cn=!0;function kn(n){Cn=n}var Tn=function(n){this.value=n,this.dep=new pn,this.vmCount=0,U(n,"__ob__",this),Array.isArray(n)?(q?function(n,t){n.__proto__=t}(n,xn):function(n,t,e){for(var r=0,i=e.length;r<i;r++){var a=e[r];U(n,a,t[a])}}(n,xn,wn),this.observeArray(n)):this.walk(n)};function Sn(n,t){var e;if(c(n)&&!(n instanceof mn))return _(n,"__ob__")&&n.__ob__ instanceof Tn?e=n.__ob__:Cn&&!rn()&&(Array.isArray(n)||u(n))&&Object.isExtensible(n)&&!n._isVue&&(e=new Tn(n)),t&&e&&e.vmCount++,e}function On(n,t,e,r,i){var a=new pn,o=Object.getOwnPropertyDescriptor(n,t);if(!o||!1!==o.configurable){var s=o&&o.get,c=o&&o.set;s&&!c||2!==arguments.length||(e=n[t]);var l=!i&&Sn(e);Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var t=s?s.call(n):e;return pn.target&&(a.depend(),l&&(l.dep.depend(),Array.isArray(t)&&Pn(t))),t},set:function(t){var r=s?s.call(n):e;t===r||t!=t&&r!=r||s&&!c||(c?c.call(n,t):e=t,l=!i&&Sn(t),a.notify())}})}}function En(n,t,e){if(Array.isArray(n)&&d(t))return n.length=Math.max(n.length,t),n.splice(t,1,e),e;if(t in n&&!(t in Object.prototype))return n[t]=e,e;var r=n.__ob__;return n._isVue||r&&r.vmCount?e:r?(On(r.value,t,e),r.dep.notify(),e):(n[t]=e,e)}function jn(n,t){if(Array.isArray(n)&&d(t))n.splice(t,1);else{var e=n.__ob__;n._isVue||e&&e.vmCount||_(n,t)&&(delete n[t],e&&e.dep.notify())}}function Pn(n){for(var t=void 0,e=0,r=n.length;e<r;e++)(t=n[e])&&t.__ob__&&t.__ob__.dep.depend(),Array.isArray(t)&&Pn(t)}Tn.prototype.walk=function(n){for(var t=Object.keys(n),e=0;e<t.length;e++)On(n,t[e])},Tn.prototype.observeArray=function(n){for(var t=0,e=n.length;t<e;t++)Sn(n[t])};var An=N.optionMergeStrategies;function zn(n,t){if(!t)return n;for(var e,r,i,a=cn?Reflect.ownKeys(t):Object.keys(t),o=0;o<a.length;o++)"__ob__"!==(e=a[o])&&(r=n[e],i=t[e],_(n,e)?r!==i&&u(r)&&u(i)&&zn(r,i):En(n,e,i));return n}function In(n,t,e){return e?function(){var r="function"==typeof t?t.call(e,e):t,i="function"==typeof n?n.call(e,e):n;return r?zn(r,i):i}:t?n?function(){return zn("function"==typeof t?t.call(this,this):t,"function"==typeof n?n.call(this,this):n)}:t:n}function $n(n,t){var e=t?n?n.concat(t):Array.isArray(t)?t:[t]:n;return e?function(n){for(var t=[],e=0;e<n.length;e++)-1===t.indexOf(n[e])&&t.push(n[e]);return t}(e):e}function Ln(n,t,e,r){var i=Object.create(n||null);return t?j(i,t):i}An.data=function(n,t,e){return e?In(n,t,e):t&&"function"!=typeof t?n:In(n,t)},D.forEach((function(n){An[n]=$n})),R.forEach((function(n){An[n+"s"]=Ln})),An.watch=function(n,t,e,r){if(n===nn&&(n=void 0),t===nn&&(t=void 0),!t)return Object.create(n||null);if(!n)return t;var i={};for(var a in j(i,n),t){var o=i[a],s=t[a];o&&!Array.isArray(o)&&(o=[o]),i[a]=o?o.concat(s):Array.isArray(s)?s:[s]}return i},An.props=An.methods=An.inject=An.computed=function(n,t,e,r){if(!n)return t;var i=Object.create(null);return j(i,n),t&&j(i,t),i},An.provide=In;var Mn=function(n,t){return void 0===t?n:t};function Rn(n,t,e){if("function"==typeof t&&(t=t.options),function(n,t){var e=n.props;if(e){var r,i,a={};if(Array.isArray(e))for(r=e.length;r--;)"string"==typeof(i=e[r])&&(a[C(i)]={type:null});else if(u(e))for(var o in e)i=e[o],a[C(o)]=u(i)?i:{type:i};else 0;n.props=a}}(t),function(n,t){var e=n.inject;if(e){var r=n.inject={};if(Array.isArray(e))for(var i=0;i<e.length;i++)r[e[i]]={from:e[i]};else if(u(e))for(var a in e){var o=e[a];r[a]=u(o)?j({from:a},o):{from:o}}else 0}}(t),function(n){var t=n.directives;if(t)for(var e in t){var r=t[e];"function"==typeof r&&(t[e]={bind:r,update:r})}}(t),!t._base&&(t.extends&&(n=Rn(n,t.extends,e)),t.mixins))for(var r=0,i=t.mixins.length;r<i;r++)n=Rn(n,t.mixins[r],e);var a,o={};for(a in n)s(a);for(a in t)_(n,a)||s(a);function s(r){var i=An[r]||Mn;o[r]=i(n[r],t[r],e,r)}return o}function Dn(n,t,e,r){if("string"==typeof e){var i=n[t];if(_(i,e))return i[e];var a=C(e);if(_(i,a))return i[a];var o=k(a);return _(i,o)?i[o]:i[e]||i[a]||i[o]}}function Nn(n,t,e,r){var i=t[n],a=!_(e,n),o=e[n],s=Fn(Boolean,i.type);if(s>-1)if(a&&!_(i,"default"))o=!1;else if(""===o||o===S(n)){var c=Fn(String,i.type);(c<0||s<c)&&(o=!0)}if(void 0===o){o=function(n,t,e){if(!_(t,"default"))return;var r=t.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[e]&&void 0!==n._props[e])return n._props[e];return"function"==typeof r&&"Function"!==Un(t.type)?r.call(n):r}(r,i,n);var l=Cn;kn(!0),Sn(o),kn(l)}return o}var Bn=/^\s*function (\w+)/;function Un(n){var t=n&&n.toString().match(Bn);return t?t[1]:""}function Wn(n,t){return Un(n)===Un(t)}function Fn(n,t){if(!Array.isArray(t))return Wn(t,n)?0:-1;for(var e=0,r=t.length;e<r;e++)if(Wn(t[e],n))return e;return-1}function qn(n,t,e){fn();try{if(t)for(var r=t;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var a=0;a<i.length;a++)try{if(!1===i[a].call(r,n,t,e))return}catch(n){Gn(n,r,"errorCaptured hook")}}Gn(n,t,e)}finally{hn()}}function Vn(n,t,e,r,i){var a;try{(a=e?n.apply(t,e):n.call(t))&&!a._isVue&&f(a)&&!a._handled&&(a.catch((function(n){return qn(n,r,i+" (Promise/async)")})),a._handled=!0)}catch(n){qn(n,r,i)}return a}function Gn(n,t,e){if(N.errorHandler)try{return N.errorHandler.call(null,n,t,e)}catch(t){t!==n&&Hn(t,null,"config.errorHandler")}Hn(n,t,e)}function Hn(n,t,e){if(!V&&!G||"undefined"==typeof console)throw n;console.error(n)}var Yn,Jn=!1,Qn=[],Kn=!1;function Xn(){Kn=!1;var n=Qn.slice(0);Qn.length=0;for(var t=0;t<n.length;t++)n[t]()}if("undefined"!=typeof Promise&&on(Promise)){var Zn=Promise.resolve();Yn=function(){Zn.then(Xn),X&&setTimeout(A)},Jn=!0}else if(J||"undefined"==typeof MutationObserver||!on(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Yn="undefined"!=typeof setImmediate&&on(setImmediate)?function(){setImmediate(Xn)}:function(){setTimeout(Xn,0)};else{var nt=1,tt=new MutationObserver(Xn),et=document.createTextNode(String(nt));tt.observe(et,{characterData:!0}),Yn=function(){nt=(nt+1)%2,et.data=String(nt)},Jn=!0}function rt(n,t){var e;if(Qn.push((function(){if(n)try{n.call(t)}catch(n){qn(n,t,"nextTick")}else e&&e(t)})),Kn||(Kn=!0,Yn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){e=n}))}var it=new sn;function at(n){!function n(t,e){var r,i,a=Array.isArray(t);if(!a&&!c(t)||Object.isFrozen(t)||t instanceof mn)return;if(t.__ob__){var o=t.__ob__.dep.id;if(e.has(o))return;e.add(o)}if(a)for(r=t.length;r--;)n(t[r],e);else for(i=Object.keys(t),r=i.length;r--;)n(t[i[r]],e)}(n,it),it.clear()}var ot=x((function(n){var t="&"===n.charAt(0),e="~"===(n=t?n.slice(1):n).charAt(0),r="!"===(n=e?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:e,capture:r,passive:t}}));function st(n,t){function e(){var n=arguments,r=e.fns;if(!Array.isArray(r))return Vn(r,null,arguments,t,"v-on handler");for(var i=r.slice(),a=0;a<i.length;a++)Vn(i[a],null,n,t,"v-on handler")}return e.fns=n,e}function ct(n,t,e,r,a,s){var c,l,u,p;for(c in n)l=n[c],u=t[c],p=ot(c),i(l)||(i(u)?(i(l.fns)&&(l=n[c]=st(l,s)),o(p.once)&&(l=n[c]=a(p.name,l,p.capture)),e(p.name,l,p.capture,p.passive,p.params)):l!==u&&(u.fns=l,n[c]=u));for(c in t)i(n[c])&&r((p=ot(c)).name,t[c],p.capture)}function lt(n,t,e){var r;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var s=n[t];function c(){e.apply(this,arguments),y(r.fns,c)}i(s)?r=st([c]):a(s.fns)&&o(s.merged)?(r=s).fns.push(c):r=st([s,c]),r.merged=!0,n[t]=r}function ut(n,t,e,r,i){if(a(t)){if(_(t,e))return n[e]=t[e],i||delete t[e],!0;if(_(t,r))return n[e]=t[r],i||delete t[r],!0}return!1}function pt(n){return s(n)?[yn(n)]:Array.isArray(n)?function n(t,e){var r,c,l,u,p=[];for(r=0;r<t.length;r++)i(c=t[r])||"boolean"==typeof c||(l=p.length-1,u=p[l],Array.isArray(c)?c.length>0&&(dt((c=n(c,(e||"")+"_"+r))[0])&&dt(u)&&(p[l]=yn(u.text+c[0].text),c.shift()),p.push.apply(p,c)):s(c)?dt(u)?p[l]=yn(u.text+c):""!==c&&p.push(yn(c)):dt(c)&&dt(u)?p[l]=yn(u.text+c.text):(o(t._isVList)&&a(c.tag)&&i(c.key)&&a(e)&&(c.key="__vlist"+e+"_"+r+"__"),p.push(c)));return p}(n):void 0}function dt(n){return a(n)&&a(n.text)&&!1===n.isComment}function ft(n,t){if(n){for(var e=Object.create(null),r=cn?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var a=r[i];if("__ob__"!==a){for(var o=n[a].from,s=t;s;){if(s._provided&&_(s._provided,o)){e[a]=s._provided[o];break}s=s.$parent}if(!s)if("default"in n[a]){var c=n[a].default;e[a]="function"==typeof c?c.call(t):c}else 0}}return e}}function ht(n,t){if(!n||!n.length)return{};for(var e={},r=0,i=n.length;r<i;r++){var a=n[r],o=a.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,a.context!==t&&a.fnContext!==t||!o||null==o.slot)(e.default||(e.default=[])).push(a);else{var s=o.slot,c=e[s]||(e[s]=[]);"template"===a.tag?c.push.apply(c,a.children||[]):c.push(a)}}for(var l in e)e[l].every(mt)&&delete e[l];return e}function mt(n){return n.isComment&&!n.asyncFactory||" "===n.text}function vt(n){return n.isComment&&n.asyncFactory}function gt(n,t,e){var i,a=Object.keys(t).length>0,o=n?!!n.$stable:!a,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&e&&e!==r&&s===e.$key&&!a&&!e.$hasNormal)return e;for(var c in i={},n)n[c]&&"$"!==c[0]&&(i[c]=yt(t,c,n[c]))}else i={};for(var l in t)l in i||(i[l]=bt(t,l));return n&&Object.isExtensible(n)&&(n._normalized=i),U(i,"$stable",o),U(i,"$key",s),U(i,"$hasNormal",a),i}function yt(n,t,e){var r=function(){var n=arguments.length?e.apply(null,arguments):e({}),t=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:pt(n))&&n[0];return n&&(!t||1===n.length&&t.isComment&&!vt(t))?void 0:n};return e.proxy&&Object.defineProperty(n,t,{get:r,enumerable:!0,configurable:!0}),r}function bt(n,t){return function(){return n[t]}}function _t(n,t){var e,r,i,o,s;if(Array.isArray(n)||"string"==typeof n)for(e=new Array(n.length),r=0,i=n.length;r<i;r++)e[r]=t(n[r],r);else if("number"==typeof n)for(e=new Array(n),r=0;r<n;r++)e[r]=t(r+1,r);else if(c(n))if(cn&&n[Symbol.iterator]){e=[];for(var l=n[Symbol.iterator](),u=l.next();!u.done;)e.push(t(u.value,e.length)),u=l.next()}else for(o=Object.keys(n),e=new Array(o.length),r=0,i=o.length;r<i;r++)s=o[r],e[r]=t(n[s],s,r);return a(e)||(e=[]),e._isVList=!0,e}function xt(n,t,e,r){var i,a=this.$scopedSlots[n];a?(e=e||{},r&&(e=j(j({},r),e)),i=a(e)||("function"==typeof t?t():t)):i=this.$slots[n]||("function"==typeof t?t():t);var o=e&&e.slot;return o?this.$createElement("template",{slot:o},i):i}function wt(n){return Dn(this.$options,"filters",n)||I}function Ct(n,t){return Array.isArray(n)?-1===n.indexOf(t):n!==t}function kt(n,t,e,r,i){var a=N.keyCodes[t]||e;return i&&r&&!N.keyCodes[t]?Ct(i,r):a?Ct(a,n):r?S(r)!==t:void 0===n}function Tt(n,t,e,r,i){if(e)if(c(e)){var a;Array.isArray(e)&&(e=P(e));var o=function(o){if("class"===o||"style"===o||g(o))a=n;else{var s=n.attrs&&n.attrs.type;a=r||N.mustUseProp(t,s,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var c=C(o),l=S(o);c in a||l in a||(a[o]=e[o],i&&((n.on||(n.on={}))["update:"+o]=function(n){e[o]=n}))};for(var s in e)o(s)}else;return n}function St(n,t){var e=this._staticTrees||(this._staticTrees=[]),r=e[n];return r&&!t||Et(r=e[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function Ot(n,t,e){return Et(n,"__once__"+t+(e?"_"+e:""),!0),n}function Et(n,t,e){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&jt(n[r],t+"_"+r,e);else jt(n,t,e)}function jt(n,t,e){n.isStatic=!0,n.key=t,n.isOnce=e}function Pt(n,t){if(t)if(u(t)){var e=n.on=n.on?j({},n.on):{};for(var r in t){var i=e[r],a=t[r];e[r]=i?[].concat(i,a):a}}else;return n}function At(n,t,e,r){t=t||{$stable:!e};for(var i=0;i<n.length;i++){var a=n[i];Array.isArray(a)?At(a,t,e):a&&(a.proxy&&(a.fn.proxy=!0),t[a.key]=a.fn)}return r&&(t.$key=r),t}function zt(n,t){for(var e=0;e<t.length;e+=2){var r=t[e];"string"==typeof r&&r&&(n[t[e]]=t[e+1])}return n}function It(n,t){return"string"==typeof n?t+n:n}function $t(n){n._o=Ot,n._n=m,n._s=h,n._l=_t,n._t=xt,n._q=$,n._i=L,n._m=St,n._f=wt,n._k=kt,n._b=Tt,n._v=yn,n._e=gn,n._u=At,n._g=Pt,n._d=zt,n._p=It}function Lt(n,t,e,i,a){var s,c=this,l=a.options;_(i,"_uid")?(s=Object.create(i))._original=i:(s=i,i=i._original);var u=o(l._compiled),p=!u;this.data=n,this.props=t,this.children=e,this.parent=i,this.listeners=n.on||r,this.injections=ft(l.inject,i),this.slots=function(){return c.$slots||gt(n.scopedSlots,c.$slots=ht(e,i)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return gt(n.scopedSlots,this.slots())}}),u&&(this.$options=l,this.$slots=this.slots(),this.$scopedSlots=gt(n.scopedSlots,this.$slots)),l._scopeId?this._c=function(n,t,e,r){var a=Wt(s,n,t,e,r,p);return a&&!Array.isArray(a)&&(a.fnScopeId=l._scopeId,a.fnContext=i),a}:this._c=function(n,t,e,r){return Wt(s,n,t,e,r,p)}}function Mt(n,t,e,r,i){var a=bn(n);return a.fnContext=e,a.fnOptions=r,t.slot&&((a.data||(a.data={})).slot=t.slot),a}function Rt(n,t){for(var e in t)n[C(e)]=t[e]}$t(Lt.prototype);var Dt={init:function(n,t){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var e=n;Dt.prepatch(e,e)}else{(n.componentInstance=function(n,t){var e={_isComponent:!0,_parentVnode:n,parent:t},r=n.data.inlineTemplate;a(r)&&(e.render=r.render,e.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(e)}(n,Kt)).$mount(t?n.elm:void 0,t)}},prepatch:function(n,t){var e=t.componentOptions;!function(n,t,e,i,a){0;var o=i.data.scopedSlots,s=n.$scopedSlots,c=!!(o&&!o.$stable||s!==r&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),l=!!(a||n.$options._renderChildren||c);n.$options._parentVnode=i,n.$vnode=i,n._vnode&&(n._vnode.parent=i);if(n.$options._renderChildren=a,n.$attrs=i.data.attrs||r,n.$listeners=e||r,t&&n.$options.props){kn(!1);for(var u=n._props,p=n.$options._propKeys||[],d=0;d<p.length;d++){var f=p[d],h=n.$options.props;u[f]=Nn(f,h,t,n)}kn(!0),n.$options.propsData=t}e=e||r;var m=n.$options._parentListeners;n.$options._parentListeners=e,Qt(n,e,m),l&&(n.$slots=ht(a,i.context),n.$forceUpdate());0}(t.componentInstance=n.componentInstance,e.propsData,e.listeners,t,e.children)},insert:function(n){var t,e=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,te(r,"mounted")),n.data.keepAlive&&(e._isMounted?((t=r)._inactive=!1,re.push(t)):ne(r,!0))},destroy:function(n){var t=n.componentInstance;t._isDestroyed||(n.data.keepAlive?function n(t,e){if(e&&(t._directInactive=!0,Zt(t)))return;if(!t._inactive){t._inactive=!0;for(var r=0;r<t.$children.length;r++)n(t.$children[r]);te(t,"deactivated")}}(t,!0):t.$destroy())}},Nt=Object.keys(Dt);function Bt(n,t,e,s,l){if(!i(n)){var u=e.$options._base;if(c(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(i(n.cid)&&void 0===(n=function(n,t){if(o(n.error)&&a(n.errorComp))return n.errorComp;if(a(n.resolved))return n.resolved;var e=qt;e&&a(n.owners)&&-1===n.owners.indexOf(e)&&n.owners.push(e);if(o(n.loading)&&a(n.loadingComp))return n.loadingComp;if(e&&!a(n.owners)){var r=n.owners=[e],s=!0,l=null,u=null;e.$on("hook:destroyed",(function(){return y(r,e)}));var p=function(n){for(var t=0,e=r.length;t<e;t++)r[t].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==u&&(clearTimeout(u),u=null))},d=M((function(e){n.resolved=Vt(e,t),s?r.length=0:p(!0)})),h=M((function(t){a(n.errorComp)&&(n.error=!0,p(!0))})),m=n(d,h);return c(m)&&(f(m)?i(n.resolved)&&m.then(d,h):f(m.component)&&(m.component.then(d,h),a(m.error)&&(n.errorComp=Vt(m.error,t)),a(m.loading)&&(n.loadingComp=Vt(m.loading,t),0===m.delay?n.loading=!0:l=setTimeout((function(){l=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,p(!1))}),m.delay||200)),a(m.timeout)&&(u=setTimeout((function(){u=null,i(n.resolved)&&h(null)}),m.timeout)))),s=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,t,e,r,i){var a=gn();return a.asyncFactory=n,a.asyncMeta={data:t,context:e,children:r,tag:i},a}(p,t,e,s,l);t=t||{},Ce(n),a(t.model)&&function(n,t){var e=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(t.attrs||(t.attrs={}))[e]=t.model.value;var i=t.on||(t.on={}),o=i[r],s=t.model.callback;a(o)?(Array.isArray(o)?-1===o.indexOf(s):o!==s)&&(i[r]=[s].concat(o)):i[r]=s}(n.options,t);var d=function(n,t,e){var r=t.options.props;if(!i(r)){var o={},s=n.attrs,c=n.props;if(a(s)||a(c))for(var l in r){var u=S(l);ut(o,c,l,u,!0)||ut(o,s,l,u,!1)}return o}}(t,n);if(o(n.options.functional))return function(n,t,e,i,o){var s=n.options,c={},l=s.props;if(a(l))for(var u in l)c[u]=Nn(u,l,t||r);else a(e.attrs)&&Rt(c,e.attrs),a(e.props)&&Rt(c,e.props);var p=new Lt(e,c,o,i,n),d=s.render.call(null,p._c,p);if(d instanceof mn)return Mt(d,e,p.parent,s,p);if(Array.isArray(d)){for(var f=pt(d)||[],h=new Array(f.length),m=0;m<f.length;m++)h[m]=Mt(f[m],e,p.parent,s,p);return h}}(n,d,t,e,s);var h=t.on;if(t.on=t.nativeOn,o(n.options.abstract)){var m=t.slot;t={},m&&(t.slot=m)}!function(n){for(var t=n.hook||(n.hook={}),e=0;e<Nt.length;e++){var r=Nt[e],i=t[r],a=Dt[r];i===a||i&&i._merged||(t[r]=i?Ut(a,i):a)}}(t);var v=n.options.name||l;return new mn("vue-component-"+n.cid+(v?"-"+v:""),t,void 0,void 0,void 0,e,{Ctor:n,propsData:d,listeners:h,tag:l,children:s},p)}}}function Ut(n,t){var e=function(e,r){n(e,r),t(e,r)};return e._merged=!0,e}function Wt(n,t,e,r,l,u){return(Array.isArray(e)||s(e))&&(l=r,r=e,e=void 0),o(u)&&(l=2),function(n,t,e,r,s){if(a(e)&&a(e.__ob__))return gn();a(e)&&a(e.is)&&(t=e.is);if(!t)return gn();0;Array.isArray(r)&&"function"==typeof r[0]&&((e=e||{}).scopedSlots={default:r[0]},r.length=0);2===s?r=pt(r):1===s&&(r=function(n){for(var t=0;t<n.length;t++)if(Array.isArray(n[t]))return Array.prototype.concat.apply([],n);return n}(r));var l,u;if("string"==typeof t){var p;u=n.$vnode&&n.$vnode.ns||N.getTagNamespace(t),l=N.isReservedTag(t)?new mn(N.parsePlatformTagName(t),e,r,void 0,void 0,n):e&&e.pre||!a(p=Dn(n.$options,"components",t))?new mn(t,e,r,void 0,void 0,n):Bt(p,e,n,r,t)}else l=Bt(t,e,n,r);return Array.isArray(l)?l:a(l)?(a(u)&&function n(t,e,r){t.ns=e,"foreignObject"===t.tag&&(e=void 0,r=!0);if(a(t.children))for(var s=0,c=t.children.length;s<c;s++){var l=t.children[s];a(l.tag)&&(i(l.ns)||o(r)&&"svg"!==l.tag)&&n(l,e,r)}}(l,u),a(e)&&function(n){c(n.style)&&at(n.style);c(n.class)&&at(n.class)}(e),l):gn()}(n,t,e,r,l)}var Ft,qt=null;function Vt(n,t){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?t.extend(n):n}function Gt(n){if(Array.isArray(n))for(var t=0;t<n.length;t++){var e=n[t];if(a(e)&&(a(e.componentOptions)||vt(e)))return e}}function Ht(n,t){Ft.$on(n,t)}function Yt(n,t){Ft.$off(n,t)}function Jt(n,t){var e=Ft;return function r(){var i=t.apply(null,arguments);null!==i&&e.$off(n,r)}}function Qt(n,t,e){Ft=n,ct(t,e||{},Ht,Yt,Jt,n),Ft=void 0}var Kt=null;function Xt(n){var t=Kt;return Kt=n,function(){Kt=t}}function Zt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function ne(n,t){if(t){if(n._directInactive=!1,Zt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var e=0;e<n.$children.length;e++)ne(n.$children[e]);te(n,"activated")}}function te(n,t){fn();var e=n.$options[t],r=t+" hook";if(e)for(var i=0,a=e.length;i<a;i++)Vn(e[i],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+t),hn()}var ee=[],re=[],ie={},ae=!1,oe=!1,se=0;var ce=0,le=Date.now;if(V&&!J){var ue=window.performance;ue&&"function"==typeof ue.now&&le()>document.createEvent("Event").timeStamp&&(le=function(){return ue.now()})}function pe(){var n,t;for(ce=le(),oe=!0,ee.sort((function(n,t){return n.id-t.id})),se=0;se<ee.length;se++)(n=ee[se]).before&&n.before(),t=n.id,ie[t]=null,n.run();var e=re.slice(),r=ee.slice();se=ee.length=re.length=0,ie={},ae=oe=!1,function(n){for(var t=0;t<n.length;t++)n[t]._inactive=!0,ne(n[t],!0)}(e),function(n){var t=n.length;for(;t--;){var e=n[t],r=e.vm;r._watcher===e&&r._isMounted&&!r._isDestroyed&&te(r,"updated")}}(r),an&&N.devtools&&an.emit("flush")}var de=0,fe=function(n,t,e,r,i){this.vm=n,i&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=e,this.id=++de,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new sn,this.newDepIds=new sn,this.expression="","function"==typeof t?this.getter=t:(this.getter=function(n){if(!W.test(n)){var t=n.split(".");return function(n){for(var e=0;e<t.length;e++){if(!n)return;n=n[t[e]]}return n}}}(t),this.getter||(this.getter=A)),this.value=this.lazy?void 0:this.get()};fe.prototype.get=function(){var n;fn(this);var t=this.vm;try{n=this.getter.call(t,t)}catch(n){if(!this.user)throw n;qn(n,t,'getter for watcher "'+this.expression+'"')}finally{this.deep&&at(n),hn(),this.cleanupDeps()}return n},fe.prototype.addDep=function(n){var t=n.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(n),this.depIds.has(t)||n.addSub(this))},fe.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var t=this.deps[n];this.newDepIds.has(t.id)||t.removeSub(this)}var e=this.depIds;this.depIds=this.newDepIds,this.newDepIds=e,this.newDepIds.clear(),e=this.deps,this.deps=this.newDeps,this.newDeps=e,this.newDeps.length=0},fe.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var t=n.id;if(null==ie[t]){if(ie[t]=!0,oe){for(var e=ee.length-1;e>se&&ee[e].id>n.id;)e--;ee.splice(e+1,0,n)}else ee.push(n);ae||(ae=!0,rt(pe))}}(this)},fe.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var t=this.value;if(this.value=n,this.user){var e='callback for watcher "'+this.expression+'"';Vn(this.cb,this.vm,[n,t],this.vm,e)}else this.cb.call(this.vm,n,t)}}},fe.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},fe.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},fe.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||y(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var he={enumerable:!0,configurable:!0,get:A,set:A};function me(n,t,e){he.get=function(){return this[t][e]},he.set=function(n){this[t][e]=n},Object.defineProperty(n,e,he)}function ve(n){n._watchers=[];var t=n.$options;t.props&&function(n,t){var e=n.$options.propsData||{},r=n._props={},i=n.$options._propKeys=[];n.$parent&&kn(!1);var a=function(a){i.push(a);var o=Nn(a,t,e,n);On(r,a,o),a in n||me(n,"_props",a)};for(var o in t)a(o);kn(!0)}(n,t.props),t.methods&&function(n,t){n.$options.props;for(var e in t)n[e]="function"!=typeof t[e]?A:O(t[e],n)}(n,t.methods),t.data?function(n){var t=n.$options.data;u(t=n._data="function"==typeof t?function(n,t){fn();try{return n.call(t,t)}catch(n){return qn(n,t,"data()"),{}}finally{hn()}}(t,n):t||{})||(t={});var e=Object.keys(t),r=n.$options.props,i=(n.$options.methods,e.length);for(;i--;){var a=e[i];0,r&&_(r,a)||(o=void 0,36!==(o=(a+"").charCodeAt(0))&&95!==o&&me(n,"_data",a))}var o;Sn(t,!0)}(n):Sn(n._data={},!0),t.computed&&function(n,t){var e=n._computedWatchers=Object.create(null),r=rn();for(var i in t){var a=t[i],o="function"==typeof a?a:a.get;0,r||(e[i]=new fe(n,o||A,A,ge)),i in n||ye(n,i,a)}}(n,t.computed),t.watch&&t.watch!==nn&&function(n,t){for(var e in t){var r=t[e];if(Array.isArray(r))for(var i=0;i<r.length;i++)xe(n,e,r[i]);else xe(n,e,r)}}(n,t.watch)}var ge={lazy:!0};function ye(n,t,e){var r=!rn();"function"==typeof e?(he.get=r?be(t):_e(e),he.set=A):(he.get=e.get?r&&!1!==e.cache?be(t):_e(e.get):A,he.set=e.set||A),Object.defineProperty(n,t,he)}function be(n){return function(){var t=this._computedWatchers&&this._computedWatchers[n];if(t)return t.dirty&&t.evaluate(),pn.target&&t.depend(),t.value}}function _e(n){return function(){return n.call(this,this)}}function xe(n,t,e,r){return u(e)&&(r=e,e=e.handler),"string"==typeof e&&(e=n[e]),n.$watch(t,e,r)}var we=0;function Ce(n){var t=n.options;if(n.super){var e=Ce(n.super);if(e!==n.superOptions){n.superOptions=e;var r=function(n){var t,e=n.options,r=n.sealedOptions;for(var i in e)e[i]!==r[i]&&(t||(t={}),t[i]=e[i]);return t}(n);r&&j(n.extendOptions,r),(t=n.options=Rn(e,n.extendOptions)).name&&(t.components[t.name]=n)}}return t}function ke(n){this._init(n)}function Te(n){n.cid=0;var t=1;n.extend=function(n){n=n||{};var e=this,r=e.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var a=n.name||e.options.name;var o=function(n){this._init(n)};return(o.prototype=Object.create(e.prototype)).constructor=o,o.cid=t++,o.options=Rn(e.options,n),o.super=e,o.options.props&&function(n){var t=n.options.props;for(var e in t)me(n.prototype,"_props",e)}(o),o.options.computed&&function(n){var t=n.options.computed;for(var e in t)ye(n.prototype,e,t[e])}(o),o.extend=e.extend,o.mixin=e.mixin,o.use=e.use,R.forEach((function(n){o[n]=e[n]})),a&&(o.options.components[a]=o),o.superOptions=e.options,o.extendOptions=n,o.sealedOptions=j({},o.options),i[r]=o,o}}function Se(n){return n&&(n.Ctor.options.name||n.tag)}function Oe(n,t){return Array.isArray(n)?n.indexOf(t)>-1:"string"==typeof n?n.split(",").indexOf(t)>-1:!!p(n)&&n.test(t)}function Ee(n,t){var e=n.cache,r=n.keys,i=n._vnode;for(var a in e){var o=e[a];if(o){var s=o.name;s&&!t(s)&&je(e,a,r,i)}}}function je(n,t,e,r){var i=n[t];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[t]=null,y(e,t)}!function(n){n.prototype._init=function(n){var t=this;t._uid=we++,t._isVue=!0,n&&n._isComponent?function(n,t){var e=n.$options=Object.create(n.constructor.options),r=t._parentVnode;e.parent=t.parent,e._parentVnode=r;var i=r.componentOptions;e.propsData=i.propsData,e._parentListeners=i.listeners,e._renderChildren=i.children,e._componentTag=i.tag,t.render&&(e.render=t.render,e.staticRenderFns=t.staticRenderFns)}(t,n):t.$options=Rn(Ce(t.constructor),n||{},t),t._renderProxy=t,t._self=t,function(n){var t=n.$options,e=t.parent;if(e&&!t.abstract){for(;e.$options.abstract&&e.$parent;)e=e.$parent;e.$children.push(n)}n.$parent=e,n.$root=e?e.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(t),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var t=n.$options._parentListeners;t&&Qt(n,t)}(t),function(n){n._vnode=null,n._staticTrees=null;var t=n.$options,e=n.$vnode=t._parentVnode,i=e&&e.context;n.$slots=ht(t._renderChildren,i),n.$scopedSlots=r,n._c=function(t,e,r,i){return Wt(n,t,e,r,i,!1)},n.$createElement=function(t,e,r,i){return Wt(n,t,e,r,i,!0)};var a=e&&e.data;On(n,"$attrs",a&&a.attrs||r,null,!0),On(n,"$listeners",t._parentListeners||r,null,!0)}(t),te(t,"beforeCreate"),function(n){var t=ft(n.$options.inject,n);t&&(kn(!1),Object.keys(t).forEach((function(e){On(n,e,t[e])})),kn(!0))}(t),ve(t),function(n){var t=n.$options.provide;t&&(n._provided="function"==typeof t?t.call(n):t)}(t),te(t,"created"),t.$options.el&&t.$mount(t.$options.el)}}(ke),function(n){var t={get:function(){return this._data}},e={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",t),Object.defineProperty(n.prototype,"$props",e),n.prototype.$set=En,n.prototype.$delete=jn,n.prototype.$watch=function(n,t,e){if(u(t))return xe(this,n,t,e);(e=e||{}).user=!0;var r=new fe(this,n,t,e);if(e.immediate){var i='callback for immediate watcher "'+r.expression+'"';fn(),Vn(t,this,[r.value],this,i),hn()}return function(){r.teardown()}}}(ke),function(n){var t=/^hook:/;n.prototype.$on=function(n,e){var r=this;if(Array.isArray(n))for(var i=0,a=n.length;i<a;i++)r.$on(n[i],e);else(r._events[n]||(r._events[n]=[])).push(e),t.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,t){var e=this;function r(){e.$off(n,r),t.apply(e,arguments)}return r.fn=t,e.$on(n,r),e},n.prototype.$off=function(n,t){var e=this;if(!arguments.length)return e._events=Object.create(null),e;if(Array.isArray(n)){for(var r=0,i=n.length;r<i;r++)e.$off(n[r],t);return e}var a,o=e._events[n];if(!o)return e;if(!t)return e._events[n]=null,e;for(var s=o.length;s--;)if((a=o[s])===t||a.fn===t){o.splice(s,1);break}return e},n.prototype.$emit=function(n){var t=this,e=t._events[n];if(e){e=e.length>1?E(e):e;for(var r=E(arguments,1),i='event handler for "'+n+'"',a=0,o=e.length;a<o;a++)Vn(e[a],t,r,t,i)}return t}}(ke),function(n){n.prototype._update=function(n,t){var e=this,r=e.$el,i=e._vnode,a=Xt(e);e._vnode=n,e.$el=i?e.__patch__(i,n):e.__patch__(e.$el,n,t,!1),a(),r&&(r.__vue__=null),e.$el&&(e.$el.__vue__=e),e.$vnode&&e.$parent&&e.$vnode===e.$parent._vnode&&(e.$parent.$el=e.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){te(n,"beforeDestroy"),n._isBeingDestroyed=!0;var t=n.$parent;!t||t._isBeingDestroyed||n.$options.abstract||y(t.$children,n),n._watcher&&n._watcher.teardown();for(var e=n._watchers.length;e--;)n._watchers[e].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),te(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(ke),function(n){$t(n.prototype),n.prototype.$nextTick=function(n){return rt(n,this)},n.prototype._render=function(){var n,t=this,e=t.$options,r=e.render,i=e._parentVnode;i&&(t.$scopedSlots=gt(i.data.scopedSlots,t.$slots,t.$scopedSlots)),t.$vnode=i;try{qt=t,n=r.call(t._renderProxy,t.$createElement)}catch(e){qn(e,t,"render"),n=t._vnode}finally{qt=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=gn()),n.parent=i,n}}(ke);var Pe=[String,RegExp,Array],Ae={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Pe,exclude:Pe,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,t=this.keys,e=this.vnodeToCache,r=this.keyToCache;if(e){var i=e.tag,a=e.componentInstance,o=e.componentOptions;n[r]={name:Se(o),tag:i,componentInstance:a},t.push(r),this.max&&t.length>parseInt(this.max)&&je(n,t[0],t,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)je(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(t){Ee(n,(function(n){return Oe(t,n)}))})),this.$watch("exclude",(function(t){Ee(n,(function(n){return!Oe(t,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,t=Gt(n),e=t&&t.componentOptions;if(e){var r=Se(e),i=this.include,a=this.exclude;if(i&&(!r||!Oe(i,r))||a&&r&&Oe(a,r))return t;var o=this.cache,s=this.keys,c=null==t.key?e.Ctor.cid+(e.tag?"::"+e.tag:""):t.key;o[c]?(t.componentInstance=o[c].componentInstance,y(s,c),s.push(c)):(this.vnodeToCache=t,this.keyToCache=c),t.data.keepAlive=!0}return t||n&&n[0]}}};!function(n){var t={get:function(){return N}};Object.defineProperty(n,"config",t),n.util={warn:ln,extend:j,mergeOptions:Rn,defineReactive:On},n.set=En,n.delete=jn,n.nextTick=rt,n.observable=function(n){return Sn(n),n},n.options=Object.create(null),R.forEach((function(t){n.options[t+"s"]=Object.create(null)})),n.options._base=n,j(n.options.components,Ae),function(n){n.use=function(n){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(n)>-1)return this;var e=E(arguments,1);return e.unshift(this),"function"==typeof n.install?n.install.apply(n,e):"function"==typeof n&&n.apply(null,e),t.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Rn(this.options,n),this}}(n),Te(n),function(n){R.forEach((function(t){n[t]=function(n,e){return e?("component"===t&&u(e)&&(e.name=e.name||n,e=this.options._base.extend(e)),"directive"===t&&"function"==typeof e&&(e={bind:e,update:e}),this.options[t+"s"][n]=e,e):this.options[t+"s"][n]}}))}(n)}(ke),Object.defineProperty(ke.prototype,"$isServer",{get:rn}),Object.defineProperty(ke.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(ke,"FunctionalRenderContext",{value:Lt}),ke.version="2.6.14";var ze=v("style,class"),Ie=v("input,textarea,option,select,progress"),$e=v("contenteditable,draggable,spellcheck"),Le=v("events,caret,typing,plaintext-only"),Me=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Re="http://www.w3.org/1999/xlink",De=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Ne=function(n){return De(n)?n.slice(6,n.length):""},Be=function(n){return null==n||!1===n};function Ue(n){for(var t=n.data,e=n,r=n;a(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(t=We(r.data,t));for(;a(e=e.parent);)e&&e.data&&(t=We(t,e.data));return function(n,t){if(a(n)||a(t))return Fe(n,qe(t));return""}(t.staticClass,t.class)}function We(n,t){return{staticClass:Fe(n.staticClass,t.staticClass),class:a(n.class)?[n.class,t.class]:t.class}}function Fe(n,t){return n?t?n+" "+t:n:t||""}function qe(n){return Array.isArray(n)?function(n){for(var t,e="",r=0,i=n.length;r<i;r++)a(t=qe(n[r]))&&""!==t&&(e&&(e+=" "),e+=t);return e}(n):c(n)?function(n){var t="";for(var e in n)n[e]&&(t&&(t+=" "),t+=e);return t}(n):"string"==typeof n?n:""}var Ve={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Ge=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),He=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Ye=function(n){return Ge(n)||He(n)};var Je=Object.create(null);var Qe=v("text,number,password,search,email,tel,url");var Ke=Object.freeze({createElement:function(n,t){var e=document.createElement(n);return"select"!==n||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&e.setAttribute("multiple","multiple"),e},createElementNS:function(n,t){return document.createElementNS(Ve[n],t)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,t,e){n.insertBefore(t,e)},removeChild:function(n,t){n.removeChild(t)},appendChild:function(n,t){n.appendChild(t)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,t){n.textContent=t},setStyleScope:function(n,t){n.setAttribute(t,"")}}),Xe={create:function(n,t){Ze(t)},update:function(n,t){n.data.ref!==t.data.ref&&(Ze(n,!0),Ze(t))},destroy:function(n){Ze(n,!0)}};function Ze(n,t){var e=n.data.ref;if(a(e)){var r=n.context,i=n.componentInstance||n.elm,o=r.$refs;t?Array.isArray(o[e])?y(o[e],i):o[e]===i&&(o[e]=void 0):n.data.refInFor?Array.isArray(o[e])?o[e].indexOf(i)<0&&o[e].push(i):o[e]=[i]:o[e]=i}}var nr=new mn("",{},[]),tr=["create","activate","update","remove","destroy"];function er(n,t){return n.key===t.key&&n.asyncFactory===t.asyncFactory&&(n.tag===t.tag&&n.isComment===t.isComment&&a(n.data)===a(t.data)&&function(n,t){if("input"!==n.tag)return!0;var e,r=a(e=n.data)&&a(e=e.attrs)&&e.type,i=a(e=t.data)&&a(e=e.attrs)&&e.type;return r===i||Qe(r)&&Qe(i)}(n,t)||o(n.isAsyncPlaceholder)&&i(t.asyncFactory.error))}function rr(n,t,e){var r,i,o={};for(r=t;r<=e;++r)a(i=n[r].key)&&(o[i]=r);return o}var ir={create:ar,update:ar,destroy:function(n){ar(n,nr)}};function ar(n,t){(n.data.directives||t.data.directives)&&function(n,t){var e,r,i,a=n===nr,o=t===nr,s=sr(n.data.directives,n.context),c=sr(t.data.directives,t.context),l=[],u=[];for(e in c)r=s[e],i=c[e],r?(i.oldValue=r.value,i.oldArg=r.arg,lr(i,"update",t,n),i.def&&i.def.componentUpdated&&u.push(i)):(lr(i,"bind",t,n),i.def&&i.def.inserted&&l.push(i));if(l.length){var p=function(){for(var e=0;e<l.length;e++)lr(l[e],"inserted",t,n)};a?lt(t,"insert",p):p()}u.length&&lt(t,"postpatch",(function(){for(var e=0;e<u.length;e++)lr(u[e],"componentUpdated",t,n)}));if(!a)for(e in s)c[e]||lr(s[e],"unbind",n,n,o)}(n,t)}var or=Object.create(null);function sr(n,t){var e,r,i=Object.create(null);if(!n)return i;for(e=0;e<n.length;e++)(r=n[e]).modifiers||(r.modifiers=or),i[cr(r)]=r,r.def=Dn(t.$options,"directives",r.name);return i}function cr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function lr(n,t,e,r,i){var a=n.def&&n.def[t];if(a)try{a(e.elm,n,e,r,i)}catch(r){qn(r,e.context,"directive "+n.name+" "+t+" hook")}}var ur=[Xe,ir];function pr(n,t){var e=t.componentOptions;if(!(a(e)&&!1===e.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(t.data.attrs))){var r,o,s=t.elm,c=n.data.attrs||{},l=t.data.attrs||{};for(r in a(l.__ob__)&&(l=t.data.attrs=j({},l)),l)o=l[r],c[r]!==o&&dr(s,r,o,t.data.pre);for(r in(J||K)&&l.value!==c.value&&dr(s,"value",l.value),c)i(l[r])&&(De(r)?s.removeAttributeNS(Re,Ne(r)):$e(r)||s.removeAttribute(r))}}function dr(n,t,e,r){r||n.tagName.indexOf("-")>-1?fr(n,t,e):Me(t)?Be(e)?n.removeAttribute(t):(e="allowfullscreen"===t&&"EMBED"===n.tagName?"true":t,n.setAttribute(t,e)):$e(t)?n.setAttribute(t,function(n,t){return Be(t)||"false"===t?"false":"contenteditable"===n&&Le(t)?t:"true"}(t,e)):De(t)?Be(e)?n.removeAttributeNS(Re,Ne(t)):n.setAttributeNS(Re,t,e):fr(n,t,e)}function fr(n,t,e){if(Be(e))n.removeAttribute(t);else{if(J&&!Q&&"TEXTAREA"===n.tagName&&"placeholder"===t&&""!==e&&!n.__ieph){var r=function(t){t.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(t,e)}}var hr={create:pr,update:pr};function mr(n,t){var e=t.elm,r=t.data,o=n.data;if(!(i(r.staticClass)&&i(r.class)&&(i(o)||i(o.staticClass)&&i(o.class)))){var s=Ue(t),c=e._transitionClasses;a(c)&&(s=Fe(s,qe(c))),s!==e._prevClass&&(e.setAttribute("class",s),e._prevClass=s)}}var vr,gr={create:mr,update:mr};function yr(n,t,e){var r=vr;return function i(){var a=t.apply(null,arguments);null!==a&&xr(n,i,e,r)}}var br=Jn&&!(Z&&Number(Z[1])<=53);function _r(n,t,e,r){if(br){var i=ce,a=t;t=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}vr.addEventListener(n,t,tn?{capture:e,passive:r}:e)}function xr(n,t,e,r){(r||vr).removeEventListener(n,t._wrapper||t,e)}function wr(n,t){if(!i(n.data.on)||!i(t.data.on)){var e=t.data.on||{},r=n.data.on||{};vr=t.elm,function(n){if(a(n.__r)){var t=J?"change":"input";n[t]=[].concat(n.__r,n[t]||[]),delete n.__r}a(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(e),ct(e,r,_r,xr,yr,t.context),vr=void 0}}var Cr,kr={create:wr,update:wr};function Tr(n,t){if(!i(n.data.domProps)||!i(t.data.domProps)){var e,r,o=t.elm,s=n.data.domProps||{},c=t.data.domProps||{};for(e in a(c.__ob__)&&(c=t.data.domProps=j({},c)),s)e in c||(o[e]="");for(e in c){if(r=c[e],"textContent"===e||"innerHTML"===e){if(t.children&&(t.children.length=0),r===s[e])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===e&&"PROGRESS"!==o.tagName){o._value=r;var l=i(r)?"":String(r);Sr(o,l)&&(o.value=l)}else if("innerHTML"===e&&He(o.tagName)&&i(o.innerHTML)){(Cr=Cr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var u=Cr.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;u.firstChild;)o.appendChild(u.firstChild)}else if(r!==s[e])try{o[e]=r}catch(n){}}}}function Sr(n,t){return!n.composing&&("OPTION"===n.tagName||function(n,t){var e=!0;try{e=document.activeElement!==n}catch(n){}return e&&n.value!==t}(n,t)||function(n,t){var e=n.value,r=n._vModifiers;if(a(r)){if(r.number)return m(e)!==m(t);if(r.trim)return e.trim()!==t.trim()}return e!==t}(n,t))}var Or={create:Tr,update:Tr},Er=x((function(n){var t={},e=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(e);r.length>1&&(t[r[0].trim()]=r[1].trim())}})),t}));function jr(n){var t=Pr(n.style);return n.staticStyle?j(n.staticStyle,t):t}function Pr(n){return Array.isArray(n)?P(n):"string"==typeof n?Er(n):n}var Ar,zr=/^--/,Ir=/\s*!important$/,$r=function(n,t,e){if(zr.test(t))n.style.setProperty(t,e);else if(Ir.test(e))n.style.setProperty(S(t),e.replace(Ir,""),"important");else{var r=Mr(t);if(Array.isArray(e))for(var i=0,a=e.length;i<a;i++)n.style[r]=e[i];else n.style[r]=e}},Lr=["Webkit","Moz","ms"],Mr=x((function(n){if(Ar=Ar||document.createElement("div").style,"filter"!==(n=C(n))&&n in Ar)return n;for(var t=n.charAt(0).toUpperCase()+n.slice(1),e=0;e<Lr.length;e++){var r=Lr[e]+t;if(r in Ar)return r}}));function Rr(n,t){var e=t.data,r=n.data;if(!(i(e.staticStyle)&&i(e.style)&&i(r.staticStyle)&&i(r.style))){var o,s,c=t.elm,l=r.staticStyle,u=r.normalizedStyle||r.style||{},p=l||u,d=Pr(t.data.style)||{};t.data.normalizedStyle=a(d.__ob__)?j({},d):d;var f=function(n,t){var e,r={};if(t)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(e=jr(i.data))&&j(r,e);(e=jr(n.data))&&j(r,e);for(var a=n;a=a.parent;)a.data&&(e=jr(a.data))&&j(r,e);return r}(t,!0);for(s in p)i(f[s])&&$r(c,s,"");for(s in f)(o=f[s])!==p[s]&&$r(c,s,null==o?"":o)}}var Dr={create:Rr,update:Rr},Nr=/\s+/;function Br(n,t){if(t&&(t=t.trim()))if(n.classList)t.indexOf(" ")>-1?t.split(Nr).forEach((function(t){return n.classList.add(t)})):n.classList.add(t);else{var e=" "+(n.getAttribute("class")||"")+" ";e.indexOf(" "+t+" ")<0&&n.setAttribute("class",(e+t).trim())}}function Ur(n,t){if(t&&(t=t.trim()))if(n.classList)t.indexOf(" ")>-1?t.split(Nr).forEach((function(t){return n.classList.remove(t)})):n.classList.remove(t),n.classList.length||n.removeAttribute("class");else{for(var e=" "+(n.getAttribute("class")||"")+" ",r=" "+t+" ";e.indexOf(r)>=0;)e=e.replace(r," ");(e=e.trim())?n.setAttribute("class",e):n.removeAttribute("class")}}function Wr(n){if(n){if("object"==typeof n){var t={};return!1!==n.css&&j(t,Fr(n.name||"v")),j(t,n),t}return"string"==typeof n?Fr(n):void 0}}var Fr=x((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),qr=V&&!Q,Vr="transition",Gr="transitionend",Hr="animation",Yr="animationend";qr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Vr="WebkitTransition",Gr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Hr="WebkitAnimation",Yr="webkitAnimationEnd"));var Jr=V?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Qr(n){Jr((function(){Jr(n)}))}function Kr(n,t){var e=n._transitionClasses||(n._transitionClasses=[]);e.indexOf(t)<0&&(e.push(t),Br(n,t))}function Xr(n,t){n._transitionClasses&&y(n._transitionClasses,t),Ur(n,t)}function Zr(n,t,e){var r=ti(n,t),i=r.type,a=r.timeout,o=r.propCount;if(!i)return e();var s="transition"===i?Gr:Yr,c=0,l=function(){n.removeEventListener(s,u),e()},u=function(t){t.target===n&&++c>=o&&l()};setTimeout((function(){c<o&&l()}),a+1),n.addEventListener(s,u)}var ni=/\b(transform|all)(,|$)/;function ti(n,t){var e,r=window.getComputedStyle(n),i=(r[Vr+"Delay"]||"").split(", "),a=(r[Vr+"Duration"]||"").split(", "),o=ei(i,a),s=(r[Hr+"Delay"]||"").split(", "),c=(r[Hr+"Duration"]||"").split(", "),l=ei(s,c),u=0,p=0;return"transition"===t?o>0&&(e="transition",u=o,p=a.length):"animation"===t?l>0&&(e="animation",u=l,p=c.length):p=(e=(u=Math.max(o,l))>0?o>l?"transition":"animation":null)?"transition"===e?a.length:c.length:0,{type:e,timeout:u,propCount:p,hasTransform:"transition"===e&&ni.test(r[Vr+"Property"])}}function ei(n,t){for(;n.length<t.length;)n=n.concat(n);return Math.max.apply(null,t.map((function(t,e){return ri(t)+ri(n[e])})))}function ri(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ii(n,t){var e=n.elm;a(e._leaveCb)&&(e._leaveCb.cancelled=!0,e._leaveCb());var r=Wr(n.data.transition);if(!i(r)&&!a(e._enterCb)&&1===e.nodeType){for(var o=r.css,s=r.type,l=r.enterClass,u=r.enterToClass,p=r.enterActiveClass,d=r.appearClass,f=r.appearToClass,h=r.appearActiveClass,v=r.beforeEnter,g=r.enter,y=r.afterEnter,b=r.enterCancelled,_=r.beforeAppear,x=r.appear,w=r.afterAppear,C=r.appearCancelled,k=r.duration,T=Kt,S=Kt.$vnode;S&&S.parent;)T=S.context,S=S.parent;var O=!T._isMounted||!n.isRootInsert;if(!O||x||""===x){var E=O&&d?d:l,j=O&&h?h:p,P=O&&f?f:u,A=O&&_||v,z=O&&"function"==typeof x?x:g,I=O&&w||y,$=O&&C||b,L=m(c(k)?k.enter:k);0;var R=!1!==o&&!Q,D=si(z),N=e._enterCb=M((function(){R&&(Xr(e,P),Xr(e,j)),N.cancelled?(R&&Xr(e,E),$&&$(e)):I&&I(e),e._enterCb=null}));n.data.show||lt(n,"insert",(function(){var t=e.parentNode,r=t&&t._pending&&t._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),z&&z(e,N)})),A&&A(e),R&&(Kr(e,E),Kr(e,j),Qr((function(){Xr(e,E),N.cancelled||(Kr(e,P),D||(oi(L)?setTimeout(N,L):Zr(e,s,N)))}))),n.data.show&&(t&&t(),z&&z(e,N)),R||D||N()}}}function ai(n,t){var e=n.elm;a(e._enterCb)&&(e._enterCb.cancelled=!0,e._enterCb());var r=Wr(n.data.transition);if(i(r)||1!==e.nodeType)return t();if(!a(e._leaveCb)){var o=r.css,s=r.type,l=r.leaveClass,u=r.leaveToClass,p=r.leaveActiveClass,d=r.beforeLeave,f=r.leave,h=r.afterLeave,v=r.leaveCancelled,g=r.delayLeave,y=r.duration,b=!1!==o&&!Q,_=si(f),x=m(c(y)?y.leave:y);0;var w=e._leaveCb=M((function(){e.parentNode&&e.parentNode._pending&&(e.parentNode._pending[n.key]=null),b&&(Xr(e,u),Xr(e,p)),w.cancelled?(b&&Xr(e,l),v&&v(e)):(t(),h&&h(e)),e._leaveCb=null}));g?g(C):C()}function C(){w.cancelled||(!n.data.show&&e.parentNode&&((e.parentNode._pending||(e.parentNode._pending={}))[n.key]=n),d&&d(e),b&&(Kr(e,l),Kr(e,p),Qr((function(){Xr(e,l),w.cancelled||(Kr(e,u),_||(oi(x)?setTimeout(w,x):Zr(e,s,w)))}))),f&&f(e,w),b||_||w())}}function oi(n){return"number"==typeof n&&!isNaN(n)}function si(n){if(i(n))return!1;var t=n.fns;return a(t)?si(Array.isArray(t)?t[0]:t):(n._length||n.length)>1}function ci(n,t){!0!==t.data.show&&ii(t)}var li=function(n){var t,e,r={},c=n.modules,l=n.nodeOps;for(t=0;t<tr.length;++t)for(r[tr[t]]=[],e=0;e<c.length;++e)a(c[e][tr[t]])&&r[tr[t]].push(c[e][tr[t]]);function u(n){var t=l.parentNode(n);a(t)&&l.removeChild(t,n)}function p(n,t,e,i,s,c,u){if(a(n.elm)&&a(c)&&(n=c[u]=bn(n)),n.isRootInsert=!s,!function(n,t,e,i){var s=n.data;if(a(s)){var c=a(n.componentInstance)&&s.keepAlive;if(a(s=s.hook)&&a(s=s.init)&&s(n,!1),a(n.componentInstance))return d(n,t),f(e,n.elm,i),o(c)&&function(n,t,e,i){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,a(o=s.data)&&a(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](nr,s);t.push(s);break}f(e,n.elm,i)}(n,t,e,i),!0}}(n,t,e,i)){var p=n.data,m=n.children,v=n.tag;a(v)?(n.elm=n.ns?l.createElementNS(n.ns,v):l.createElement(v,n),y(n),h(n,m,t),a(p)&&g(n,t),f(e,n.elm,i)):o(n.isComment)?(n.elm=l.createComment(n.text),f(e,n.elm,i)):(n.elm=l.createTextNode(n.text),f(e,n.elm,i))}}function d(n,t){a(n.data.pendingInsert)&&(t.push.apply(t,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,m(n)?(g(n,t),y(n)):(Ze(n),t.push(n))}function f(n,t,e){a(n)&&(a(e)?l.parentNode(e)===n&&l.insertBefore(n,t,e):l.appendChild(n,t))}function h(n,t,e){if(Array.isArray(t)){0;for(var r=0;r<t.length;++r)p(t[r],e,n.elm,null,!0,t,r)}else s(n.text)&&l.appendChild(n.elm,l.createTextNode(String(n.text)))}function m(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return a(n.tag)}function g(n,e){for(var i=0;i<r.create.length;++i)r.create[i](nr,n);a(t=n.data.hook)&&(a(t.create)&&t.create(nr,n),a(t.insert)&&e.push(n))}function y(n){var t;if(a(t=n.fnScopeId))l.setStyleScope(n.elm,t);else for(var e=n;e;)a(t=e.context)&&a(t=t.$options._scopeId)&&l.setStyleScope(n.elm,t),e=e.parent;a(t=Kt)&&t!==n.context&&t!==n.fnContext&&a(t=t.$options._scopeId)&&l.setStyleScope(n.elm,t)}function b(n,t,e,r,i,a){for(;r<=i;++r)p(e[r],a,n,t,!1,e,r)}function _(n){var t,e,i=n.data;if(a(i))for(a(t=i.hook)&&a(t=t.destroy)&&t(n),t=0;t<r.destroy.length;++t)r.destroy[t](n);if(a(t=n.children))for(e=0;e<n.children.length;++e)_(n.children[e])}function x(n,t,e){for(;t<=e;++t){var r=n[t];a(r)&&(a(r.tag)?(w(r),_(r)):u(r.elm))}}function w(n,t){if(a(t)||a(n.data)){var e,i=r.remove.length+1;for(a(t)?t.listeners+=i:t=function(n,t){function e(){0==--e.listeners&&u(n)}return e.listeners=t,e}(n.elm,i),a(e=n.componentInstance)&&a(e=e._vnode)&&a(e.data)&&w(e,t),e=0;e<r.remove.length;++e)r.remove[e](n,t);a(e=n.data.hook)&&a(e=e.remove)?e(n,t):t()}else u(n.elm)}function C(n,t,e,r){for(var i=e;i<r;i++){var o=t[i];if(a(o)&&er(n,o))return i}}function k(n,t,e,s,c,u){if(n!==t){a(t.elm)&&a(s)&&(t=s[c]=bn(t));var d=t.elm=n.elm;if(o(n.isAsyncPlaceholder))a(t.asyncFactory.resolved)?O(n.elm,t,e):t.isAsyncPlaceholder=!0;else if(o(t.isStatic)&&o(n.isStatic)&&t.key===n.key&&(o(t.isCloned)||o(t.isOnce)))t.componentInstance=n.componentInstance;else{var f,h=t.data;a(h)&&a(f=h.hook)&&a(f=f.prepatch)&&f(n,t);var v=n.children,g=t.children;if(a(h)&&m(t)){for(f=0;f<r.update.length;++f)r.update[f](n,t);a(f=h.hook)&&a(f=f.update)&&f(n,t)}i(t.text)?a(v)&&a(g)?v!==g&&function(n,t,e,r,o){var s,c,u,d=0,f=0,h=t.length-1,m=t[0],v=t[h],g=e.length-1,y=e[0],_=e[g],w=!o;for(0;d<=h&&f<=g;)i(m)?m=t[++d]:i(v)?v=t[--h]:er(m,y)?(k(m,y,r,e,f),m=t[++d],y=e[++f]):er(v,_)?(k(v,_,r,e,g),v=t[--h],_=e[--g]):er(m,_)?(k(m,_,r,e,g),w&&l.insertBefore(n,m.elm,l.nextSibling(v.elm)),m=t[++d],_=e[--g]):er(v,y)?(k(v,y,r,e,f),w&&l.insertBefore(n,v.elm,m.elm),v=t[--h],y=e[++f]):(i(s)&&(s=rr(t,d,h)),i(c=a(y.key)?s[y.key]:C(y,t,d,h))?p(y,r,n,m.elm,!1,e,f):er(u=t[c],y)?(k(u,y,r,e,f),t[c]=void 0,w&&l.insertBefore(n,u.elm,m.elm)):p(y,r,n,m.elm,!1,e,f),y=e[++f]);d>h?b(n,i(e[g+1])?null:e[g+1].elm,e,f,g,r):f>g&&x(t,d,h)}(d,v,g,e,u):a(g)?(a(n.text)&&l.setTextContent(d,""),b(d,null,g,0,g.length-1,e)):a(v)?x(v,0,v.length-1):a(n.text)&&l.setTextContent(d,""):n.text!==t.text&&l.setTextContent(d,t.text),a(h)&&a(f=h.hook)&&a(f=f.postpatch)&&f(n,t)}}}function T(n,t,e){if(o(e)&&a(n.parent))n.parent.data.pendingInsert=t;else for(var r=0;r<t.length;++r)t[r].data.hook.insert(t[r])}var S=v("attrs,class,staticClass,staticStyle,key");function O(n,t,e,r){var i,s=t.tag,c=t.data,l=t.children;if(r=r||c&&c.pre,t.elm=n,o(t.isComment)&&a(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(a(c)&&(a(i=c.hook)&&a(i=i.init)&&i(t,!0),a(i=t.componentInstance)))return d(t,e),!0;if(a(s)){if(a(l))if(n.hasChildNodes())if(a(i=c)&&a(i=i.domProps)&&a(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var u=!0,p=n.firstChild,f=0;f<l.length;f++){if(!p||!O(p,l[f],e,r)){u=!1;break}p=p.nextSibling}if(!u||p)return!1}else h(t,l,e);if(a(c)){var m=!1;for(var v in c)if(!S(v)){m=!0,g(t,e);break}!m&&c.class&&at(c.class)}}else n.data!==t.text&&(n.data=t.text);return!0}return function(n,t,e,s){if(!i(t)){var c,u=!1,d=[];if(i(n))u=!0,p(t,d);else{var f=a(n.nodeType);if(!f&&er(n,t))k(n,t,d,null,null,s);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),e=!0),o(e)&&O(n,t,d))return T(t,d,!0),n;c=n,n=new mn(l.tagName(c).toLowerCase(),{},[],void 0,c)}var h=n.elm,v=l.parentNode(h);if(p(t,d,h._leaveCb?null:v,l.nextSibling(h)),a(t.parent))for(var g=t.parent,y=m(t);g;){for(var b=0;b<r.destroy.length;++b)r.destroy[b](g);if(g.elm=t.elm,y){for(var w=0;w<r.create.length;++w)r.create[w](nr,g);var C=g.data.hook.insert;if(C.merged)for(var S=1;S<C.fns.length;S++)C.fns[S]()}else Ze(g);g=g.parent}a(v)?x([n],0,0):a(n.tag)&&_(n)}}return T(t,d,u),t.elm}a(n)&&_(n)}}({nodeOps:Ke,modules:[hr,gr,kr,Or,Dr,V?{create:ci,activate:ci,remove:function(n,t){!0!==n.data.show?ai(n,t):t()}}:{}].concat(ur)});Q&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&gi(n,"input")}));var ui={inserted:function(n,t,e,r){"select"===e.tag?(r.elm&&!r.elm._vOptions?lt(e,"postpatch",(function(){ui.componentUpdated(n,t,e)})):pi(n,t,e.context),n._vOptions=[].map.call(n.options,hi)):("textarea"===e.tag||Qe(n.type))&&(n._vModifiers=t.modifiers,t.modifiers.lazy||(n.addEventListener("compositionstart",mi),n.addEventListener("compositionend",vi),n.addEventListener("change",vi),Q&&(n.vmodel=!0)))},componentUpdated:function(n,t,e){if("select"===e.tag){pi(n,t,e.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,hi);if(i.some((function(n,t){return!$(n,r[t])})))(n.multiple?t.value.some((function(n){return fi(n,i)})):t.value!==t.oldValue&&fi(t.value,i))&&gi(n,"change")}}};function pi(n,t,e){di(n,t,e),(J||K)&&setTimeout((function(){di(n,t,e)}),0)}function di(n,t,e){var r=t.value,i=n.multiple;if(!i||Array.isArray(r)){for(var a,o,s=0,c=n.options.length;s<c;s++)if(o=n.options[s],i)a=L(r,hi(o))>-1,o.selected!==a&&(o.selected=a);else if($(hi(o),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));i||(n.selectedIndex=-1)}}function fi(n,t){return t.every((function(t){return!$(t,n)}))}function hi(n){return"_value"in n?n._value:n.value}function mi(n){n.target.composing=!0}function vi(n){n.target.composing&&(n.target.composing=!1,gi(n.target,"input"))}function gi(n,t){var e=document.createEvent("HTMLEvents");e.initEvent(t,!0,!0),n.dispatchEvent(e)}function yi(n){return!n.componentInstance||n.data&&n.data.transition?n:yi(n.componentInstance._vnode)}var bi={model:ui,show:{bind:function(n,t,e){var r=t.value,i=(e=yi(e)).data&&e.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(e.data.show=!0,ii(e,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,t,e){var r=t.value;!r!=!t.oldValue&&((e=yi(e)).data&&e.data.transition?(e.data.show=!0,r?ii(e,(function(){n.style.display=n.__vOriginalDisplay})):ai(e,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,t,e,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},_i={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function xi(n){var t=n&&n.componentOptions;return t&&t.Ctor.options.abstract?xi(Gt(t.children)):n}function wi(n){var t={},e=n.$options;for(var r in e.propsData)t[r]=n[r];var i=e._parentListeners;for(var a in i)t[C(a)]=i[a];return t}function Ci(n,t){if(/\d-keep-alive$/.test(t.tag))return n("keep-alive",{props:t.componentOptions.propsData})}var ki=function(n){return n.tag||vt(n)},Ti=function(n){return"show"===n.name},Si={name:"transition",props:_i,abstract:!0,render:function(n){var t=this,e=this.$slots.default;if(e&&(e=e.filter(ki)).length){0;var r=this.mode;0;var i=e[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var a=xi(i);if(!a)return i;if(this._leaving)return Ci(n,i);var o="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?o+"comment":o+a.tag:s(a.key)?0===String(a.key).indexOf(o)?a.key:o+a.key:a.key;var c=(a.data||(a.data={})).transition=wi(this),l=this._vnode,u=xi(l);if(a.data.directives&&a.data.directives.some(Ti)&&(a.data.show=!0),u&&u.data&&!function(n,t){return t.key===n.key&&t.tag===n.tag}(a,u)&&!vt(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var p=u.data.transition=j({},c);if("out-in"===r)return this._leaving=!0,lt(p,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),Ci(n,i);if("in-out"===r){if(vt(a))return l;var d,f=function(){d()};lt(c,"afterEnter",f),lt(c,"enterCancelled",f),lt(p,"delayLeave",(function(n){d=n}))}}return i}}},Oi=j({tag:String,moveClass:String},_i);function Ei(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function ji(n){n.data.newPos=n.elm.getBoundingClientRect()}function Pi(n){var t=n.data.pos,e=n.data.newPos,r=t.left-e.left,i=t.top-e.top;if(r||i){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate("+r+"px,"+i+"px)",a.transitionDuration="0s"}}delete Oi.mode;var Ai={Transition:Si,TransitionGroup:{props:Oi,beforeMount:function(){var n=this,t=this._update;this._update=function(e,r){var i=Xt(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),t.call(n,e,r)}},render:function(n){for(var t=this.tag||this.$vnode.data.tag||"span",e=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],a=this.children=[],o=wi(this),s=0;s<i.length;s++){var c=i[s];if(c.tag)if(null!=c.key&&0!==String(c.key).indexOf("__vlist"))a.push(c),e[c.key]=c,(c.data||(c.data={})).transition=o;else;}if(r){for(var l=[],u=[],p=0;p<r.length;p++){var d=r[p];d.data.transition=o,d.data.pos=d.elm.getBoundingClientRect(),e[d.key]?l.push(d):u.push(d)}this.kept=n(t,null,l),this.removed=u}return n(t,null,a)},updated:function(){var n=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,t)&&(n.forEach(Ei),n.forEach(ji),n.forEach(Pi),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var e=n.elm,r=e.style;Kr(e,t),r.transform=r.WebkitTransform=r.transitionDuration="",e.addEventListener(Gr,e._moveCb=function n(r){r&&r.target!==e||r&&!/transform$/.test(r.propertyName)||(e.removeEventListener(Gr,n),e._moveCb=null,Xr(e,t))})}})))},methods:{hasMove:function(n,t){if(!qr)return!1;if(this._hasMove)return this._hasMove;var e=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Ur(e,n)})),Br(e,t),e.style.display="none",this.$el.appendChild(e);var r=ti(e);return this.$el.removeChild(e),this._hasMove=r.hasTransform}}}};ke.config.mustUseProp=function(n,t,e){return"value"===e&&Ie(n)&&"button"!==t||"selected"===e&&"option"===n||"checked"===e&&"input"===n||"muted"===e&&"video"===n},ke.config.isReservedTag=Ye,ke.config.isReservedAttr=ze,ke.config.getTagNamespace=function(n){return He(n)?"svg":"math"===n?"math":void 0},ke.config.isUnknownElement=function(n){if(!V)return!0;if(Ye(n))return!1;if(n=n.toLowerCase(),null!=Je[n])return Je[n];var t=document.createElement(n);return n.indexOf("-")>-1?Je[n]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:Je[n]=/HTMLUnknownElement/.test(t.toString())},j(ke.options.directives,bi),j(ke.options.components,Ai),ke.prototype.__patch__=V?li:A,ke.prototype.$mount=function(n,t){return function(n,t,e){var r;return n.$el=t,n.$options.render||(n.$options.render=gn),te(n,"beforeMount"),r=function(){n._update(n._render(),e)},new fe(n,r,A,{before:function(){n._isMounted&&!n._isDestroyed&&te(n,"beforeUpdate")}},!0),e=!1,null==n.$vnode&&(n._isMounted=!0,te(n,"mounted")),n}(this,n=n&&V?function(n){if("string"==typeof n){var t=document.querySelector(n);return t||document.createElement("div")}return n}(n):void 0,t)},V&&setTimeout((function(){N.devtools&&an&&an.emit("init",ke)}),0);var zi=ke;
/*!
  * vue-router v3.5.4
  * (c) 2022 Evan You
  * @license MIT
  */function Ii(n,t){for(var e in t)n[e]=t[e];return n}var $i=/[!'()*]/g,Li=function(n){return"%"+n.charCodeAt(0).toString(16)},Mi=/%2C/g,Ri=function(n){return encodeURIComponent(n).replace($i,Li).replace(Mi,",")};function Di(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Ni=function(n){return null==n||"object"==typeof n?n:String(n)};function Bi(n){var t={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var e=n.replace(/\+/g," ").split("="),r=Di(e.shift()),i=e.length>0?Di(e.join("=")):null;void 0===t[r]?t[r]=i:Array.isArray(t[r])?t[r].push(i):t[r]=[t[r],i]})),t):t}function Ui(n){var t=n?Object.keys(n).map((function(t){var e=n[t];if(void 0===e)return"";if(null===e)return Ri(t);if(Array.isArray(e)){var r=[];return e.forEach((function(n){void 0!==n&&(null===n?r.push(Ri(t)):r.push(Ri(t)+"="+Ri(n)))})),r.join("&")}return Ri(t)+"="+Ri(e)})).filter((function(n){return n.length>0})).join("&"):null;return t?"?"+t:""}var Wi=/\/?$/;function Fi(n,t,e,r){var i=r&&r.options.stringifyQuery,a=t.query||{};try{a=qi(a)}catch(n){}var o={name:t.name||n&&n.name,meta:n&&n.meta||{},path:t.path||"/",hash:t.hash||"",query:a,params:t.params||{},fullPath:Hi(t,i),matched:n?Gi(n):[]};return e&&(o.redirectedFrom=Hi(e,i)),Object.freeze(o)}function qi(n){if(Array.isArray(n))return n.map(qi);if(n&&"object"==typeof n){var t={};for(var e in n)t[e]=qi(n[e]);return t}return n}var Vi=Fi(null,{path:"/"});function Gi(n){for(var t=[];n;)t.unshift(n),n=n.parent;return t}function Hi(n,t){var e=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(e||"/")+(t||Ui)(r)+i}function Yi(n,t,e){return t===Vi?n===t:!!t&&(n.path&&t.path?n.path.replace(Wi,"")===t.path.replace(Wi,"")&&(e||n.hash===t.hash&&Ji(n.query,t.query)):!(!n.name||!t.name)&&(n.name===t.name&&(e||n.hash===t.hash&&Ji(n.query,t.query)&&Ji(n.params,t.params))))}function Ji(n,t){if(void 0===n&&(n={}),void 0===t&&(t={}),!n||!t)return n===t;var e=Object.keys(n).sort(),r=Object.keys(t).sort();return e.length===r.length&&e.every((function(e,i){var a=n[e];if(r[i]!==e)return!1;var o=t[e];return null==a||null==o?a===o:"object"==typeof a&&"object"==typeof o?Ji(a,o):String(a)===String(o)}))}function Qi(n){for(var t=0;t<n.matched.length;t++){var e=n.matched[t];for(var r in e.instances){var i=e.instances[r],a=e.enteredCbs[r];if(i&&a){delete e.enteredCbs[r];for(var o=0;o<a.length;o++)i._isBeingDestroyed||a[o](i)}}}}var Ki={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,t){var e=t.props,r=t.children,i=t.parent,a=t.data;a.routerView=!0;for(var o=i.$createElement,s=e.name,c=i.$route,l=i._routerViewCache||(i._routerViewCache={}),u=0,p=!1;i&&i._routerRoot!==i;){var d=i.$vnode?i.$vnode.data:{};d.routerView&&u++,d.keepAlive&&i._directInactive&&i._inactive&&(p=!0),i=i.$parent}if(a.routerViewDepth=u,p){var f=l[s],h=f&&f.component;return h?(f.configProps&&Xi(h,a,f.route,f.configProps),o(h,a,r)):o()}var m=c.matched[u],v=m&&m.components[s];if(!m||!v)return l[s]=null,o();l[s]={component:v},a.registerRouteInstance=function(n,t){var e=m.instances[s];(t&&e!==n||!t&&e===n)&&(m.instances[s]=t)},(a.hook||(a.hook={})).prepatch=function(n,t){m.instances[s]=t.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==m.instances[s]&&(m.instances[s]=n.componentInstance),Qi(c)};var g=m.props&&m.props[s];return g&&(Ii(l[s],{route:c,configProps:g}),Xi(v,a,c,g)),o(v,a,r)}};function Xi(n,t,e,r){var i=t.props=function(n,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(n);case"boolean":return t?n.params:void 0;default:0}}(e,r);if(i){i=t.props=Ii({},i);var a=t.attrs=t.attrs||{};for(var o in i)n.props&&o in n.props||(a[o]=i[o],delete i[o])}}function Zi(n,t,e){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return t+n;var i=t.split("/");e&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var s=a[o];".."===s?i.pop():"."!==s&&i.push(s)}return""!==i[0]&&i.unshift(""),i.join("/")}function na(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var ta=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ea=va,ra=ca,ia=function(n,t){return ua(ca(n,t),t)},aa=ua,oa=ma,sa=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function ca(n,t){for(var e,r=[],i=0,a=0,o="",s=t&&t.delimiter||"/";null!=(e=sa.exec(n));){var c=e[0],l=e[1],u=e.index;if(o+=n.slice(a,u),a=u+c.length,l)o+=l[1];else{var p=n[a],d=e[2],f=e[3],h=e[4],m=e[5],v=e[6],g=e[7];o&&(r.push(o),o="");var y=null!=d&&null!=p&&p!==d,b="+"===v||"*"===v,_="?"===v||"*"===v,x=e[2]||s,w=h||m;r.push({name:f||i++,prefix:d||"",delimiter:x,optional:_,repeat:b,partial:y,asterisk:!!g,pattern:w?da(w):g?".*":"[^"+pa(x)+"]+?"})}}return a<n.length&&(o+=n.substr(a)),o&&r.push(o),r}function la(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function ua(n,t){for(var e=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(e[r]=new RegExp("^(?:"+n[r].pattern+")$",ha(t)));return function(t,r){for(var i="",a=t||{},o=(r||{}).pretty?la:encodeURIComponent,s=0;s<n.length;s++){var c=n[s];if("string"!=typeof c){var l,u=a[c.name];if(null==u){if(c.optional){c.partial&&(i+=c.prefix);continue}throw new TypeError('Expected "'+c.name+'" to be defined')}if(ta(u)){if(!c.repeat)throw new TypeError('Expected "'+c.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(c.optional)continue;throw new TypeError('Expected "'+c.name+'" to not be empty')}for(var p=0;p<u.length;p++){if(l=o(u[p]),!e[s].test(l))throw new TypeError('Expected all "'+c.name+'" to match "'+c.pattern+'", but received `'+JSON.stringify(l)+"`");i+=(0===p?c.prefix:c.delimiter)+l}}else{if(l=c.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(u),!e[s].test(l))throw new TypeError('Expected "'+c.name+'" to match "'+c.pattern+'", but received "'+l+'"');i+=c.prefix+l}}else i+=c}return i}}function pa(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function da(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function fa(n,t){return n.keys=t,n}function ha(n){return n&&n.sensitive?"":"i"}function ma(n,t,e){ta(t)||(e=t||e,t=[]);for(var r=(e=e||{}).strict,i=!1!==e.end,a="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)a+=pa(s);else{var c=pa(s.prefix),l="(?:"+s.pattern+")";t.push(s),s.repeat&&(l+="(?:"+c+l+")*"),a+=l=s.optional?s.partial?c+"("+l+")?":"(?:"+c+"("+l+"))?":c+"("+l+")"}}var u=pa(e.delimiter||"/"),p=a.slice(-u.length)===u;return r||(a=(p?a.slice(0,-u.length):a)+"(?:"+u+"(?=$))?"),a+=i?"$":r&&p?"":"(?="+u+"|$)",fa(new RegExp("^"+a,ha(e)),t)}function va(n,t,e){return ta(t)||(e=t||e,t=[]),e=e||{},n instanceof RegExp?function(n,t){var e=n.source.match(/\((?!\?)/g);if(e)for(var r=0;r<e.length;r++)t.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return fa(n,t)}(n,t):ta(n)?function(n,t,e){for(var r=[],i=0;i<n.length;i++)r.push(va(n[i],t,e).source);return fa(new RegExp("(?:"+r.join("|")+")",ha(e)),t)}(n,t,e):function(n,t,e){return ma(ca(n,e),t,e)}(n,t,e)}ea.parse=ra,ea.compile=ia,ea.tokensToFunction=aa,ea.tokensToRegExp=oa;var ga=Object.create(null);function ya(n,t,e){t=t||{};try{var r=ga[n]||(ga[n]=ea.compile(n));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),r(t,{pretty:!0})}catch(n){return""}finally{delete t[0]}}function ba(n,t,e,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var a=(i=Ii({},n)).params;return a&&"object"==typeof a&&(i.params=Ii({},a)),i}if(!i.path&&i.params&&t){(i=Ii({},i))._normalized=!0;var o=Ii(Ii({},t.params),i.params);if(t.name)i.name=t.name,i.params=o;else if(t.matched.length){var s=t.matched[t.matched.length-1].path;i.path=ya(s,o,t.path)}else 0;return i}var c=function(n){var t="",e="",r=n.indexOf("#");r>=0&&(t=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(e=n.slice(i+1),n=n.slice(0,i)),{path:n,query:e,hash:t}}(i.path||""),l=t&&t.path||"/",u=c.path?Zi(c.path,l,e||i.append):l,p=function(n,t,e){void 0===t&&(t={});var r,i=e||Bi;try{r=i(n||"")}catch(n){r={}}for(var a in t){var o=t[a];r[a]=Array.isArray(o)?o.map(Ni):Ni(o)}return r}(c.query,i.query,r&&r.options.parseQuery),d=i.hash||c.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:u,query:p,hash:d}}var _a,xa=function(){},wa={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var t=this,e=this.$router,r=this.$route,i=e.resolve(this.to,r,this.append),a=i.location,o=i.route,s=i.href,c={},l=e.options.linkActiveClass,u=e.options.linkExactActiveClass,p=null==l?"router-link-active":l,d=null==u?"router-link-exact-active":u,f=null==this.activeClass?p:this.activeClass,h=null==this.exactActiveClass?d:this.exactActiveClass,m=o.redirectedFrom?Fi(null,ba(o.redirectedFrom),null,e):o;c[h]=Yi(r,m,this.exactPath),c[f]=this.exact||this.exactPath?c[h]:function(n,t){return 0===n.path.replace(Wi,"/").indexOf(t.path.replace(Wi,"/"))&&(!t.hash||n.hash===t.hash)&&function(n,t){for(var e in t)if(!(e in n))return!1;return!0}(n.query,t.query)}(r,m);var v=c[h]?this.ariaCurrentValue:null,g=function(n){Ca(n)&&(t.replace?e.replace(a,xa):e.push(a,xa))},y={click:Ca};Array.isArray(this.event)?this.event.forEach((function(n){y[n]=g})):y[this.event]=g;var b={class:c},_=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:g,isActive:c[f],isExactActive:c[h]});if(_){if(1===_.length)return _[0];if(_.length>1||!_.length)return 0===_.length?n():n("span",{},_)}if("a"===this.tag)b.on=y,b.attrs={href:s,"aria-current":v};else{var x=function n(t){var e;if(t)for(var r=0;r<t.length;r++){if("a"===(e=t[r]).tag)return e;if(e.children&&(e=n(e.children)))return e}}(this.$slots.default);if(x){x.isStatic=!1;var w=x.data=Ii({},x.data);for(var C in w.on=w.on||{},w.on){var k=w.on[C];C in y&&(w.on[C]=Array.isArray(k)?k:[k])}for(var T in y)T in w.on?w.on[T].push(y[T]):w.on[T]=g;var S=x.data.attrs=Ii({},x.data.attrs);S.href=s,S["aria-current"]=v}else b.on=y}return n(this.tag,b,this.$slots.default)}};function Ca(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var t=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return n.preventDefault&&n.preventDefault(),!0}}var ka="undefined"!=typeof window;function Ta(n,t,e,r,i){var a=t||[],o=e||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(t,e,r,i,a,o){var s=i.path,c=i.name;0;var l=i.pathToRegexpOptions||{},u=function(n,t,e){e||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==t)return n;return na(t.path+"/"+n)}(s,a,l.strict);"boolean"==typeof i.caseSensitive&&(l.sensitive=i.caseSensitive);var p={path:u,regex:Sa(u,l),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:c,parent:a,matchAs:o,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var a=o?na(o+"/"+i.path):void 0;n(t,e,r,i,p,a)}));e[p.path]||(t.push(p.path),e[p.path]=p);if(void 0!==i.alias)for(var d=Array.isArray(i.alias)?i.alias:[i.alias],f=0;f<d.length;++f){0;var h={path:d[f],children:i.children};n(t,e,r,h,a,p.path||"/")}c&&(r[c]||(r[c]=p))}(a,o,s,n,i)}));for(var c=0,l=a.length;c<l;c++)"*"===a[c]&&(a.push(a.splice(c,1)[0]),l--,c--);return{pathList:a,pathMap:o,nameMap:s}}function Sa(n,t){return ea(n,[],t)}function Oa(n,t){var e=Ta(n),r=e.pathList,i=e.pathMap,a=e.nameMap;function o(n,e,o){var s=ba(n,e,!1,t),l=s.name;if(l){var u=a[l];if(!u)return c(null,s);var p=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),e&&"object"==typeof e.params)for(var d in e.params)!(d in s.params)&&p.indexOf(d)>-1&&(s.params[d]=e.params[d]);return s.path=ya(u.path,s.params),c(u,s,o)}if(s.path){s.params={};for(var f=0;f<r.length;f++){var h=r[f],m=i[h];if(Ea(m.regex,s.path,s.params))return c(m,s,o)}}return c(null,s)}function s(n,e){var r=n.redirect,i="function"==typeof r?r(Fi(n,e,null,t)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return c(null,e);var s=i,l=s.name,u=s.path,p=e.query,d=e.hash,f=e.params;if(p=s.hasOwnProperty("query")?s.query:p,d=s.hasOwnProperty("hash")?s.hash:d,f=s.hasOwnProperty("params")?s.params:f,l){a[l];return o({_normalized:!0,name:l,query:p,hash:d,params:f},void 0,e)}if(u){var h=function(n,t){return Zi(n,t.parent?t.parent.path:"/",!0)}(u,n);return o({_normalized:!0,path:ya(h,f),query:p,hash:d},void 0,e)}return c(null,e)}function c(n,e,r){return n&&n.redirect?s(n,r||e):n&&n.matchAs?function(n,t,e){var r=o({_normalized:!0,path:ya(e,t.params)});if(r){var i=r.matched,a=i[i.length-1];return t.params=r.params,c(a,t)}return c(null,t)}(0,e,n.matchAs):Fi(n,e,r,t)}return{match:o,addRoute:function(n,t){var e="object"!=typeof n?a[n]:void 0;Ta([t||n],r,i,a,e),e&&e.alias.length&&Ta(e.alias.map((function(n){return{path:n,children:[t]}})),r,i,a,e)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Ta(n,r,i,a)}}}function Ea(n,t,e){var r=t.match(n);if(!r)return!1;if(!e)return!0;for(var i=1,a=r.length;i<a;++i){var o=n.keys[i-1];o&&(e[o.name||"pathMatch"]="string"==typeof r[i]?Di(r[i]):r[i])}return!0}var ja=ka&&window.performance&&window.performance.now?window.performance:Date;function Pa(){return ja.now().toFixed(3)}var Aa=Pa();function za(){return Aa}function Ia(n){return Aa=n}var $a=Object.create(null);function La(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(n,""),e=Ii({},window.history.state);return e.key=za(),window.history.replaceState(e,"",t),window.addEventListener("popstate",Da),function(){window.removeEventListener("popstate",Da)}}function Ma(n,t,e,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var a=function(){var n=za();if(n)return $a[n]}(),o=i.call(n,t,e,r?a:null);o&&("function"==typeof o.then?o.then((function(n){Fa(n,a)})).catch((function(n){0})):Fa(o,a))}))}}function Ra(){var n=za();n&&($a[n]={x:window.pageXOffset,y:window.pageYOffset})}function Da(n){Ra(),n.state&&n.state.key&&Ia(n.state.key)}function Na(n){return Ua(n.x)||Ua(n.y)}function Ba(n){return{x:Ua(n.x)?n.x:window.pageXOffset,y:Ua(n.y)?n.y:window.pageYOffset}}function Ua(n){return"number"==typeof n}var Wa=/^#\d/;function Fa(n,t){var e,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=Wa.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var a=n.offset&&"object"==typeof n.offset?n.offset:{};t=function(n,t){var e=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-e.left-t.x,y:r.top-e.top-t.y}}(i,a={x:Ua((e=a).x)?e.x:0,y:Ua(e.y)?e.y:0})}else Na(n)&&(t=Ba(n))}else r&&Na(n)&&(t=Ba(n));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:n.behavior}):window.scrollTo(t.x,t.y))}var qa,Va=ka&&((-1===(qa=window.navigator.userAgent).indexOf("Android 2.")&&-1===qa.indexOf("Android 4.0")||-1===qa.indexOf("Mobile Safari")||-1!==qa.indexOf("Chrome")||-1!==qa.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Ga(n,t){Ra();var e=window.history;try{if(t){var r=Ii({},e.state);r.key=za(),e.replaceState(r,"",n)}else e.pushState({key:Ia(Pa())},"",n)}catch(e){window.location[t?"replace":"assign"](n)}}function Ha(n){Ga(n,!0)}function Ya(n,t,e){var r=function(i){i>=n.length?e():n[i]?t(n[i],(function(){r(i+1)})):r(i+1)};r(0)}var Ja={redirected:2,aborted:4,cancelled:8,duplicated:16};function Qa(n,t){return Xa(n,t,Ja.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var t={};return Za.forEach((function(e){e in n&&(t[e]=n[e])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}function Ka(n,t){return Xa(n,t,Ja.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function Xa(n,t,e,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=t,i.type=e,i}var Za=["params","query","hash"];function no(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function to(n,t){return no(n)&&n._isRouter&&(null==t||n.type===t)}function eo(n){return function(t,e,r){var i=!1,a=0,o=null;ro(n,(function(n,t,e,s){if("function"==typeof n&&void 0===n.cid){i=!0,a++;var c,l=oo((function(t){var i;((i=t).__esModule||ao&&"Module"===i[Symbol.toStringTag])&&(t=t.default),n.resolved="function"==typeof t?t:_a.extend(t),e.components[s]=t,--a<=0&&r()})),u=oo((function(n){var t="Failed to resolve async component "+s+": "+n;o||(o=no(n)?n:new Error(t),r(o))}));try{c=n(l,u)}catch(n){u(n)}if(c)if("function"==typeof c.then)c.then(l,u);else{var p=c.component;p&&"function"==typeof p.then&&p.then(l,u)}}})),i||r()}}function ro(n,t){return io(n.map((function(n){return Object.keys(n.components).map((function(e){return t(n.components[e],n.instances[e],n,e)}))})))}function io(n){return Array.prototype.concat.apply([],n)}var ao="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function oo(n){var t=!1;return function(){for(var e=[],r=arguments.length;r--;)e[r]=arguments[r];if(!t)return t=!0,n.apply(this,e)}}var so=function(n,t){this.router=n,this.base=function(n){if(!n)if(ka){var t=document.querySelector("base");n=(n=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(t),this.current=Vi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function co(n,t,e,r){var i=ro(n,(function(n,r,i,a){var o=function(n,t){"function"!=typeof n&&(n=_a.extend(n));return n.options[t]}(n,t);if(o)return Array.isArray(o)?o.map((function(n){return e(n,r,i,a)})):e(o,r,i,a)}));return io(r?i.reverse():i)}function lo(n,t){if(t)return function(){return n.apply(t,arguments)}}so.prototype.listen=function(n){this.cb=n},so.prototype.onReady=function(n,t){this.ready?n():(this.readyCbs.push(n),t&&this.readyErrorCbs.push(t))},so.prototype.onError=function(n){this.errorCbs.push(n)},so.prototype.transitionTo=function(n,t,e){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(t){t(n)})),n}var a=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),t&&t(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,a)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){e&&e(n),n&&!i.ready&&(to(n,Ja.redirected)&&a===Vi||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(n)}))))}))},so.prototype.confirmTransition=function(n,t,e){var r=this,i=this.current;this.pending=n;var a,o,s=function(n){!to(n)&&no(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(t){t(n)})):console.error(n)),e&&e(n)},c=n.matched.length-1,l=i.matched.length-1;if(Yi(n,i)&&c===l&&n.matched[c]===i.matched[l])return this.ensureURL(),n.hash&&Ma(this.router,i,n,!1),s(((o=Xa(a=i,n,Ja.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",o));var u=function(n,t){var e,r=Math.max(n.length,t.length);for(e=0;e<r&&n[e]===t[e];e++);return{updated:t.slice(0,e),activated:t.slice(e),deactivated:n.slice(e)}}(this.current.matched,n.matched),p=u.updated,d=u.deactivated,f=u.activated,h=[].concat(function(n){return co(n,"beforeRouteLeave",lo,!0)}(d),this.router.beforeHooks,function(n){return co(n,"beforeRouteUpdate",lo)}(p),f.map((function(n){return n.beforeEnter})),eo(f)),m=function(t,e){if(r.pending!==n)return s(Ka(i,n));try{t(n,i,(function(t){!1===t?(r.ensureURL(!0),s(function(n,t){return Xa(n,t,Ja.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,n))):no(t)?(r.ensureURL(!0),s(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(s(Qa(i,n)),"object"==typeof t&&t.replace?r.replace(t):r.push(t)):e(t)}))}catch(n){s(n)}};Ya(h,m,(function(){Ya(function(n){return co(n,"beforeRouteEnter",(function(n,t,e,r){return function(n,t,e){return function(r,i,a){return n(r,i,(function(n){"function"==typeof n&&(t.enteredCbs[e]||(t.enteredCbs[e]=[]),t.enteredCbs[e].push(n)),a(n)}))}}(n,e,r)}))}(f).concat(r.router.resolveHooks),m,(function(){if(r.pending!==n)return s(Ka(i,n));r.pending=null,t(n),r.router.app&&r.router.app.$nextTick((function(){Qi(n)}))}))}))},so.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},so.prototype.setupListeners=function(){},so.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Vi,this.pending=null};var uo=function(n){function t(t,e){n.call(this,t,e),this._startLocation=po(this.base)}return n&&(t.__proto__=n),t.prototype=Object.create(n&&n.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var t=this.router,e=t.options.scrollBehavior,r=Va&&e;r&&this.listeners.push(La());var i=function(){var e=n.current,i=po(n.base);n.current===Vi&&i===n._startLocation||n.transitionTo(i,(function(n){r&&Ma(t,n,e,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(n){window.history.go(n)},t.prototype.push=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){Ga(na(r.base+n.fullPath)),Ma(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.replace=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){Ha(na(r.base+n.fullPath)),Ma(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.ensureURL=function(n){if(po(this.base)!==this.current.fullPath){var t=na(this.base+this.current.fullPath);n?Ga(t):Ha(t)}},t.prototype.getCurrentLocation=function(){return po(this.base)},t}(so);function po(n){var t=window.location.pathname,e=t.toLowerCase(),r=n.toLowerCase();return!n||e!==r&&0!==e.indexOf(na(r+"/"))||(t=t.slice(n.length)),(t||"/")+window.location.search+window.location.hash}var fo=function(n){function t(t,e,r){n.call(this,t,e),r&&function(n){var t=po(n);if(!/^\/#/.test(t))return window.location.replace(na(n+"/#"+t)),!0}(this.base)||ho()}return n&&(t.__proto__=n),t.prototype=Object.create(n&&n.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,e=Va&&t;e&&this.listeners.push(La());var r=function(){var t=n.current;ho()&&n.transitionTo(mo(),(function(r){e&&Ma(n.router,r,t,!0),Va||yo(r.fullPath)}))},i=Va?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},t.prototype.push=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){go(n.fullPath),Ma(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.replace=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){yo(n.fullPath),Ma(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.go=function(n){window.history.go(n)},t.prototype.ensureURL=function(n){var t=this.current.fullPath;mo()!==t&&(n?go(t):yo(t))},t.prototype.getCurrentLocation=function(){return mo()},t}(so);function ho(){var n=mo();return"/"===n.charAt(0)||(yo("/"+n),!1)}function mo(){var n=window.location.href,t=n.indexOf("#");return t<0?"":n=n.slice(t+1)}function vo(n){var t=window.location.href,e=t.indexOf("#");return(e>=0?t.slice(0,e):t)+"#"+n}function go(n){Va?Ga(vo(n)):window.location.hash=n}function yo(n){Va?Ha(vo(n)):window.location.replace(vo(n))}var bo=function(n){function t(t,e){n.call(this,t,e),this.stack=[],this.index=-1}return n&&(t.__proto__=n),t.prototype=Object.create(n&&n.prototype),t.prototype.constructor=t,t.prototype.push=function(n,t,e){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,t&&t(n)}),e)},t.prototype.replace=function(n,t,e){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),t&&t(n)}),e)},t.prototype.go=function(n){var t=this,e=this.index+n;if(!(e<0||e>=this.stack.length)){var r=this.stack[e];this.confirmTransition(r,(function(){var n=t.current;t.index=e,t.updateRoute(r),t.router.afterHooks.forEach((function(t){t&&t(r,n)}))}),(function(n){to(n,Ja.duplicated)&&(t.index=e)}))}},t.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},t.prototype.ensureURL=function(){},t}(so),_o=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Oa(n.routes||[],this);var t=n.mode||"hash";switch(this.fallback="history"===t&&!Va&&!1!==n.fallback,this.fallback&&(t="hash"),ka||(t="abstract"),this.mode=t,t){case"history":this.history=new uo(this,n.base);break;case"hash":this.history=new fo(this,n.base,this.fallback);break;case"abstract":this.history=new bo(this,n.base);break;default:0}},xo={currentRoute:{configurable:!0}};function wo(n,t){return n.push(t),function(){var e=n.indexOf(t);e>-1&&n.splice(e,1)}}_o.prototype.match=function(n,t,e){return this.matcher.match(n,t,e)},xo.currentRoute.get=function(){return this.history&&this.history.current},_o.prototype.init=function(n){var t=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var e=t.apps.indexOf(n);e>-1&&t.apps.splice(e,1),t.app===n&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=n;var e=this.history;if(e instanceof uo||e instanceof fo){var r=function(n){e.setupListeners(),function(n){var r=e.current,i=t.options.scrollBehavior;Va&&i&&"fullPath"in n&&Ma(t,n,r,!1)}(n)};e.transitionTo(e.getCurrentLocation(),r,r)}e.listen((function(n){t.apps.forEach((function(t){t._route=n}))}))}},_o.prototype.beforeEach=function(n){return wo(this.beforeHooks,n)},_o.prototype.beforeResolve=function(n){return wo(this.resolveHooks,n)},_o.prototype.afterEach=function(n){return wo(this.afterHooks,n)},_o.prototype.onReady=function(n,t){this.history.onReady(n,t)},_o.prototype.onError=function(n){this.history.onError(n)},_o.prototype.push=function(n,t,e){var r=this;if(!t&&!e&&"undefined"!=typeof Promise)return new Promise((function(t,e){r.history.push(n,t,e)}));this.history.push(n,t,e)},_o.prototype.replace=function(n,t,e){var r=this;if(!t&&!e&&"undefined"!=typeof Promise)return new Promise((function(t,e){r.history.replace(n,t,e)}));this.history.replace(n,t,e)},_o.prototype.go=function(n){this.history.go(n)},_o.prototype.back=function(){this.go(-1)},_o.prototype.forward=function(){this.go(1)},_o.prototype.getMatchedComponents=function(n){var t=n?n.matched?n:this.resolve(n).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(n){return Object.keys(n.components).map((function(t){return n.components[t]}))}))):[]},_o.prototype.resolve=function(n,t,e){var r=ba(n,t=t||this.history.current,e,this),i=this.match(r,t),a=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,t,e){var r="hash"===e?"#"+t:t;return n?na(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:i}},_o.prototype.getRoutes=function(){return this.matcher.getRoutes()},_o.prototype.addRoute=function(n,t){this.matcher.addRoute(n,t),this.history.current!==Vi&&this.history.transitionTo(this.history.getCurrentLocation())},_o.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Vi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(_o.prototype,xo),_o.install=function n(t){if(!n.installed||_a!==t){n.installed=!0,_a=t;var e=function(n){return void 0!==n},r=function(n,t){var r=n.$options._parentVnode;e(r)&&e(r=r.data)&&e(r=r.registerRouteInstance)&&r(n,t)};t.mixin({beforeCreate:function(){e(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",Ki),t.component("RouterLink",wa);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},_o.version="3.5.4",_o.isNavigationFailure=to,_o.NavigationFailureType=Ja,_o.START_LOCATION=Vi,ka&&window.Vue&&window.Vue.use(_o);var Co=_o;e(101);e(124);var ko={NotFound:()=>Promise.all([e.e(0),e.e(5)]).then(e.bind(null,324)),Layout:()=>Promise.all([e.e(0),e.e(3),e.e(2)]).then(e.bind(null,323))},To={"v-465a10a3":()=>e.e(6).then(e.bind(null,325)),"v-ae8ce3d2":()=>e.e(7).then(e.bind(null,326)),"v-7a9dff07":()=>e.e(8).then(e.bind(null,327)),"v-7d0fcd4a":()=>e.e(10).then(e.bind(null,328)),"v-18718c04":()=>e.e(9).then(e.bind(null,329)),"v-16253573":()=>e.e(12).then(e.bind(null,330)),"v-602d1c42":()=>e.e(11).then(e.bind(null,331)),"v-52de352b":()=>e.e(13).then(e.bind(null,332)),"v-6a18abfa":()=>e.e(14).then(e.bind(null,333)),"v-9b512a1a":()=>e.e(15).then(e.bind(null,334)),"v-a31e7cfa":()=>e.e(16).then(e.bind(null,335)),"v-adaed63a":()=>e.e(17).then(e.bind(null,336)),"v-38c4d983":()=>e.e(19).then(e.bind(null,337)),"v-808e1b3a":()=>e.e(20).then(e.bind(null,338)),"v-0eba4323":()=>e.e(18).then(e.bind(null,339)),"v-19e58c3a":()=>e.e(21).then(e.bind(null,340)),"v-448f6e72":()=>e.e(22).then(e.bind(null,341)),"v-acc65afa":()=>e.e(23).then(e.bind(null,342)),"v-3cdd7c23":()=>e.e(24).then(e.bind(null,343)),"v-1595c540":()=>e.e(25).then(e.bind(null,344)),"v-b802e238":()=>e.e(26).then(e.bind(null,345)),"v-76d7a407":()=>e.e(27).then(e.bind(null,346)),"v-04def3fa":()=>e.e(28).then(e.bind(null,347)),"v-faf1db3a":()=>e.e(29).then(e.bind(null,348)),"v-cda71308":()=>e.e(31).then(e.bind(null,349)),"v-f6245f3a":()=>e.e(33).then(e.bind(null,350)),"v-b1c16cfa":()=>e.e(30).then(e.bind(null,351)),"v-1bf730e3":()=>e.e(32).then(e.bind(null,352)),"v-e5b4aac8":()=>e.e(34).then(e.bind(null,353))};function So(n){const t=Object.create(null);return function(e){return t[e]||(t[e]=n(e))}}const Oo=/-(\w)/g,Eo=So(n=>n.replace(Oo,(n,t)=>t?t.toUpperCase():"")),jo=/\B([A-Z])/g,Po=So(n=>n.replace(jo,"-$1").toLowerCase()),Ao=So(n=>n.charAt(0).toUpperCase()+n.slice(1));function zo(n,t){if(!t)return;if(n(t))return n(t);return t.includes("-")?n(Ao(Eo(t))):n(Ao(t))||n(Po(t))}const Io=Object.assign({},ko,To),$o=n=>Io[n],Lo=n=>To[n],Mo=n=>ko[n],Ro=n=>zi.component(n);function Do(n){return zo(Lo,n)}function No(n){return zo(Mo,n)}function Bo(n){return zo($o,n)}function Uo(n){return zo(Ro,n)}function Wo(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!Uo(n)&&Bo(n)){const t=await Bo(n)();zi.component(n,t.default)}}))}function Fo(n,t){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=t)}var qo=e(90),Vo=e.n(qo),Go=e(91),Ho=e.n(Go),Yo={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,t])=>t),this.$ssrContext){const t=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=t)?n.map(n=>{let t="<meta";return Object.keys(n).forEach(e=>{t+=` ${e}="${Ho()(n[e])}"`}),t+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=Qo(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=Ko(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return Vo()([{name:"description",content:this.$description}],n,this.siteMeta,Xo)},updateCanonicalLink(){Jo(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",Qo(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){Ko(null,this.currentMetaTags),Jo()}};function Jo(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function Qo(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function Ko(n,t){if(t&&[...t].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const t=document.createElement("meta");return Object.keys(n).forEach(e=>{t.setAttribute(e,n[e])}),document.head.appendChild(t),t})}function Xo(n){for(const t of["name","property","itemprop"])if(n.hasOwnProperty(t))return n[t]+t;return JSON.stringify(n)}var Zo=e(49),ns={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:e.n(Zo)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter(t=>n.some(n=>n.hash===t.hash)),e=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+e;for(let n=0;n<t.length;n++){const a=t[n],o=t[n+1],s=0===n&&0===e||e>=a.parentElement.offsetTop+10&&(!o||e<o.parentElement.offsetTop-10),c=decodeURIComponent(this.$route.hash);if(s&&c!==decodeURIComponent(a.hash)){const e=a;if(i===r)for(let e=n+1;e<t.length;e++)if(c===decodeURIComponent(t[e].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(e.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},ts=e(23),es=e.n(ts),rs={mounted(){es.a.configure({showSpinner:!1}),this.$router.beforeEach((n,t,e)=>{n.path===t.path||zi.component(n.name)||es.a.start(),e()}),this.$router.afterEach(()=>{es.a.done(),this.isSidebarOpen=!1})}};e(231),e(232);class is{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:t=3e3}){let e=document.createElement("div");e.className="message move-in",e.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(e),t>0&&setTimeout(()=>{this.close(e)},t)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var as={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Copy to clipboard",t.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(t),n.classList.add("codecopy-enabled")},copyToClipboard(n){const t=document.createElement("textarea");t.value=n,t.setAttribute("readonly",""),t.style.position="absolute",t.style.left="-9999px",document.body.appendChild(t);const e=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);t.select(),document.execCommand("copy");(new is).show({text:"Copied",duration:1e3}),document.body.removeChild(t),e&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(e))}}};!function(n,t){void 0===t&&(t={});var e=t.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===e&&r.firstChild?r.insertBefore(i,r.firstChild):r.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var os={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},ss={},cs=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},ls=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:os[n]},us=function n(t,e,r){var i=document.createElement(t);return e&&Object.keys(e).forEach((function(n){if(n.indexOf("data"))i[n]=e[n];else{var t=n.replace("data","");i.dataset[t]=e[n]}})),r&&r.forEach((function(t){var e=t.tag,r=t.attrs,a=t.children;i.appendChild(n(e,r,a))})),i},ps=function(n,t,e){var r,i=(r=n.querySelectorAll(".".concat(t)),Array.prototype.slice.call(r));return 1!==i.length||e?i:i[0]},ds=function(n,t){var e,r,i=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:i&&i[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:t.jsLib||[],cssLib:t.cssLib||[]};s.htmlTpl=cs(s.html),s.jsTpl=(e=s.js,r=e.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,t){var e=n.split(/export\s+default/),r="(function() {".concat(e[0]," ; return ").concat(e[1],"})()"),i=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,a=[eval][0](i);return a.template=t,a}(s.js,s.html);var c=ls("vue");return s.jsLib.unshift(c),s},fs=function(n,t){var e,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:t.jsLib||[],cssLib:t.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(e=o.js,window.Babel?window.Babel.transform(e,{presets:["es2015"]}).code:e),o},hs=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function ms(){var n=ps(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var t=ps(n,"vuepress-plugin-demo-block__code"),e=ps(n,"vuepress-plugin-demo-block__display"),r=ps(n,"vuepress-plugin-demo-block__footer"),i=ps(e,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var c=t.querySelector("div").clientHeight,l="react"===s?function(n,t){var e=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(e,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(r))(),a={js:i,css:i.__style__||"",jsLib:t.jsLib||[],cssLib:t.cssLib||[],jsTpl:hs(n),htmlTpl:cs("")},o=ls("react"),s=ls("reactDOM");return a.jsLib.unshift(o,s),a}(a,o):"vanilla"===s?fs(a,o):ds(a,o),u=us("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(u),u.addEventListener("click",vs.bind(null,u,c,t,r)),ls("jsfiddle")&&r.appendChild(function(n){var t=n.css,e=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=i.concat(a).concat(ls("cssLib")).concat(ls("jsLib")).join(",");return us("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:t}},{tag:"input",attrs:{type:"hidden",name:"html",value:e}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(l)),ls("codepen")&&r.appendChild(function(n){var t=n.css,e=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=JSON.stringify({css:t,html:e,js:r,js_external:i.concat(ls("jsLib")).join(";"),css_external:a.concat(ls("cssLib")).join(";"),layout:ls("codepenLayout"),js_pre_processor:ls("codepenJsProcessor"),editors:ls("codepenEditors")});return us("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(l)),void 0!==o.horizontal?o.horizontal:ls("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=t.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),e.appendChild(p)}if(l.css&&function(n){if(!ss[n]){var t=us("style",{innerHTML:n});document.body.appendChild(t),ss[n]=!0}}(l.css),"react"===s)ReactDOM.render(React.createElement(l.js),i);else if("vue"===s){var d=(new(Vue.extend(l.script))).$mount();i.appendChild(d.$el)}else"vanilla"===s&&(i.innerHTML=l.html,new Function("return (function(){".concat(l.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){ms()}),300)}function vs(n,t,e,r){var i="1"!==n.dataset.isExpand;e.style.height=i?"".concat(t,"px"):0,i?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=i?"1":"0"}var gs={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},ms()},updated:function(){ms()}},ys="auto",bs="zoom-in",_s="zoom-out",xs="grab",ws="move";function Cs(n,t,e){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?n.addEventListener(t,e,i):n.removeEventListener(t,e,i)}function ks(n,t){if(n){var e=new Image;e.onload=function(){t&&t(e)},e.src=n}}function Ts(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ss(n,t,e){!function(n){var t=Os,e=Es;if(n.transition){var r=n.transition;delete n.transition,n[t]=r}if(n.transform){var i=n.transform;delete n.transform,n[e]=i}}(t);var r=n.style,i={};for(var a in t)e&&(i[a]=r[a]||""),r[a]=t[a];return i}var Os="transition",Es="transform",js="transform",Ps="transitionend";var As=function(){},zs={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:As,onClose:As,onGrab:As,onMove:As,onRelease:As,onBeforeOpen:As,onBeforeClose:As,onBeforeGrab:As,onBeforeRelease:As,onImageLoading:As,onImageLoaded:As},Is={init:function(n){var t,e;t=this,e=n,Object.getOwnPropertyNames(Object.getPrototypeOf(t)).forEach((function(n){t[n]=t[n].bind(e)}))},click:function(n){if(n.preventDefault(),Ls(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,t=window.pageXOffset||n.scrollLeft,e=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:t,y:e});var r=this.lastScrollPosition.x-t,i=this.lastScrollPosition.y-e,a=this.options.scrollThreshold;(Math.abs(i)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if($s(n)&&!Ls(n)){n.preventDefault();var t=n.clientX,e=n.clientY;this.pressTimer=setTimeout(function(){this.grab(t,e)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){$s(n)&&!Ls(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var t=n.touches[0],e=t.clientX,r=t.clientY;this.pressTimer=setTimeout(function(){this.grab(e,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var t=n.touches[0],e=t.clientX,r=t.clientY;this.move(e,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function $s(n){return 0===n.button}function Ls(n){return n.metaKey||n.ctrlKey}var Ms={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ss(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Cs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ss(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Rs="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Ds=function(){function n(n,t){for(var e=0;e<t.length;e++){var r=t[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(t,e,r){return e&&n(t.prototype,e),r&&n(t,r),t}}(),Ns=Object.assign||function(n){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r])}return n},Bs={init:function(n,t){this.el=n,this.instance=t,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Ts(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,t=n.zIndex,e=n.enableGrab,r=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:t+1,cursor:e?xs:_s,transition:js+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ss(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ss(this.el,{transform:"none"})},grab:function(n,t,e){var r=Us(),i=r.x-n,a=r.y-t;Ss(this.el,{cursor:ws,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+e)+","+(this.scale.y+e)+")"})},move:function(n,t,e){var r=Us(),i=r.x-n,a=r.y-t;Ss(this.el,{transition:js,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+e)+","+(this.scale.y+e)+")"})},restoreCloseStyle:function(){Ss(this.el,this.styleClose)},restoreOpenStyle:function(){Ss(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var t=this.el.cloneNode(!1);t.setAttribute("src",this.srcOriginal),t.style.position="fixed",t.style.visibility="hidden",n.appendChild(t),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(t)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Us(),t=this.rect.left+this.rect.width/2,e=this.rect.top+this.rect.height/2;return{x:n.x-t,y:n.y-e}},calculateScale:function(){var n=this.el.dataset,t=n.zoomingHeight,e=n.zoomingWidth,r=this.instance.options,i=r.customSize,a=r.scaleBase;if(!i&&t&&e)return{x:e/this.rect.width,y:t/this.rect.height};if(i&&"object"===(void 0===i?"undefined":Rs(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,c=Us(),l={x:c.x-o,y:c.y-s},u=l.x/o,p=l.y/s,d=a+Math.min(u,p);if(i&&"string"==typeof i){var f=e||this.el.naturalWidth,h=t||this.el.naturalHeight,m=parseFloat(i)*f/(100*this.rect.width),v=parseFloat(i)*h/(100*this.rect.height);if(d>m||d>v)return{x:m,y:v}}return{x:d,y:d}}};function Us(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Ws(n,t,e){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Cs(n,r,t[r],e)}))}var Fs=function(){function n(t){!function(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Bs),this.overlay=Object.create(Ms),this.handler=Object.create(Is),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Ns({},zs,t),this.overlay.init(this),this.handler.init(this)}return Ds(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var t=document.querySelectorAll(n),e=t.length;e--;)this.listen(t[e]);else"IMG"===n.tagName&&(n.style.cursor=bs,Cs(n,"click",this.handler.click),this.options.preloadImage&&ks(Ts(n)));return this}},{key:"config",value:function(n){return n?(Ns(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var t=this,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),ks(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Cs(document,"scroll",this.handler.scroll),Cs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Cs(window,"resize",this.handler.resizeWindow);var a=function n(){Cs(r,Ps,n,!1),t.lock=!1,t.target.upgradeSource(),t.options.enableGrab&&Ws(document,t.handler,!0),e(r)};return Cs(r,Ps,a),this}}}},{key:"close",value:function(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var e=this.target.el;this.options.onBeforeClose(e),this.lock=!0,this.body.style.cursor=ys,this.overlay.fadeOut(),this.target.zoomOut(),Cs(document,"scroll",this.handler.scroll,!1),Cs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Cs(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Cs(e,Ps,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Ws(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),t(e)};return Cs(e,Ps,r),this}}},{key:"grab",value:function(n,t){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,t,e);var a=function n(){Cs(i,Ps,n,!1),r(i)};return Cs(i,Ps,a),this}}},{key:"move",value:function(n,t){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=ws,this.target.move(n,t,e);var i=this.target.el,a=function n(){Cs(i,Ps,n,!1),r(i)};return Cs(i,Ps,a),this}}},{key:"release",value:function(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var e=this.target.el;this.options.onBeforeRelease(e),this.lock=!0,this.body.style.cursor=ys,this.target.restoreOpenStyle();var r=function r(){Cs(e,Ps,r,!1),n.lock=!1,n.released=!0,t(e)};return Cs(e,Ps,r),this}}}]),n}();const qs=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),Vs=Number("500");class Gs{constructor(){this.instance=new Fs(qs)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",t=Vs){setTimeout(()=>this.update(n),t)}}var Hs=[Yo,ns,rs,as,gs,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new Gs,this.$vuepress.zooming.updateDelay()}}],Ys={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return Fo("layout",n),zi.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Js=e(6),Qs=Object(Js.a)(Ys,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,t,e){switch(t){case"components":n[t]||(n[t]={}),Object.assign(n[t],e);break;case"mixins":n[t]||(n[t]=[]),n[t].push(...e);break;default:throw new Error("Unknown option name.")}}(Qs,"mixins",Hs);const Ks=[{name:"v-465a10a3",path:"/wiki/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-465a10a3").then(e)}},{path:"/wiki/index.html",redirect:"/wiki/"},{path:"/00.NavBar/01.Wiki.html",redirect:"/wiki/"},{name:"v-ae8ce3d2",path:"/authoring/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-ae8ce3d2").then(e)}},{path:"/authoring/index.html",redirect:"/authoring/"},{path:"/00.NavBar/02.Authoring.html",redirect:"/authoring/"},{name:"v-7a9dff07",path:"/wiki/lean_in_c++/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-7a9dff07").then(e)}},{path:"/wiki/lean_in_c++/index.html",redirect:"/wiki/lean_in_c++/"},{path:"/01.Wiki/01.Lean in c++/00.ReadMe.html",redirect:"/wiki/lean_in_c++/"},{name:"v-7d0fcd4a",path:"/pages/409de3/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-7d0fcd4a").then(e)}},{path:"/pages/409de3/index.html",redirect:"/pages/409de3/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/01.type cast.html",redirect:"/pages/409de3/"},{name:"v-18718c04",path:"/pages/8744f7/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-18718c04").then(e)}},{path:"/pages/8744f7/index.html",redirect:"/pages/8744f7/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/00.C++ Glimpse.html",redirect:"/pages/8744f7/"},{name:"v-16253573",path:"/pages/2b0a8f/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-16253573").then(e)}},{path:"/pages/2b0a8f/index.html",redirect:"/pages/2b0a8f/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/03.typename vs class.html",redirect:"/pages/2b0a8f/"},{name:"v-602d1c42",path:"/pages/ab4daf/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-602d1c42").then(e)}},{path:"/pages/ab4daf/index.html",redirect:"/pages/ab4daf/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/02.typedef.html",redirect:"/pages/ab4daf/"},{name:"v-52de352b",path:"/pages/b9de04/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-52de352b").then(e)}},{path:"/pages/b9de04/index.html",redirect:"/pages/b9de04/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/04.const.html",redirect:"/pages/b9de04/"},{name:"v-6a18abfa",path:"/pages/5bac8e/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-6a18abfa").then(e)}},{path:"/pages/5bac8e/index.html",redirect:"/pages/5bac8e/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/05.extern.html",redirect:"/pages/5bac8e/"},{name:"v-9b512a1a",path:"/pages/c08a6e/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-9b512a1a").then(e)}},{path:"/pages/c08a6e/index.html",redirect:"/pages/c08a6e/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/06.pointer.html",redirect:"/pages/c08a6e/"},{name:"v-a31e7cfa",path:"/pages/9b131d/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-a31e7cfa").then(e)}},{path:"/pages/9b131d/index.html",redirect:"/pages/9b131d/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/07.static.html",redirect:"/pages/9b131d/"},{name:"v-adaed63a",path:"/pages/598385/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-adaed63a").then(e)}},{path:"/pages/598385/index.html",redirect:"/pages/598385/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/08.volatile.html",redirect:"/pages/598385/"},{name:"v-38c4d983",path:"/pages/efbaf4/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-38c4d983").then(e)}},{path:"/pages/efbaf4/index.html",redirect:"/pages/efbaf4/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/10.assert.html",redirect:"/pages/efbaf4/"},{name:"v-808e1b3a",path:"/pages/b4d0b6/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-808e1b3a").then(e)}},{path:"/pages/b4d0b6/index.html",redirect:"/pages/b4d0b6/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/11.void.html",redirect:"/pages/b4d0b6/"},{name:"v-0eba4323",path:"/pages/91242f/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-0eba4323").then(e)}},{path:"/pages/91242f/index.html",redirect:"/pages/91242f/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/09.inline.html",redirect:"/pages/91242f/"},{name:"v-19e58c3a",path:"/pages/fc5419/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-19e58c3a").then(e)}},{path:"/pages/fc5419/index.html",redirect:"/pages/fc5419/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/12.__global__.html",redirect:"/pages/fc5419/"},{name:"v-448f6e72",path:"/wiki/Performance_Engineering/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-448f6e72").then(e)}},{path:"/wiki/Performance_Engineering/index.html",redirect:"/wiki/Performance_Engineering/"},{path:"/01.Wiki/02.Performance Engineering/01.Perf.html",redirect:"/wiki/Performance_Engineering/"},{name:"v-acc65afa",path:"/pages/41a6c9/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-acc65afa").then(e)}},{path:"/pages/41a6c9/index.html",redirect:"/pages/41a6c9/"},{path:"/01.Wiki/10.Misc/01.Chrome.html",redirect:"/pages/41a6c9/"},{name:"v-3cdd7c23",path:"/pages/6f0fa2/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-3cdd7c23").then(e)}},{path:"/pages/6f0fa2/index.html",redirect:"/pages/6f0fa2/"},{path:"/01.Wiki/10.Misc/02.VsCode.html",redirect:"/pages/6f0fa2/"},{name:"v-1595c540",path:"/pages/fb2fc1/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-1595c540").then(e)}},{path:"/pages/fb2fc1/index.html",redirect:"/pages/fb2fc1/"},{path:"/01.Wiki/19.Reading Notes/01.Effective_C++.html",redirect:"/pages/fb2fc1/"},{name:"v-b802e238",path:"/pages/e1ff7c/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-b802e238").then(e)}},{path:"/pages/e1ff7c/index.html",redirect:"/pages/e1ff7c/"},{path:"/01.Wiki/19.Reading Notes/02.More_Effective_C++.html",redirect:"/pages/e1ff7c/"},{name:"v-76d7a407",path:"/wiki/Reading_Notes/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-76d7a407").then(e)}},{path:"/wiki/Reading_Notes/index.html",redirect:"/wiki/Reading_Notes/"},{path:"/01.Wiki/19.Reading Notes/03.C++性能优化指南.html",redirect:"/wiki/Reading_Notes/"},{name:"v-04def3fa",path:"/archives/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-04def3fa").then(e)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-faf1db3a",path:"/categories/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-faf1db3a").then(e)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-cda71308",path:"/pages/9b7dad/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-cda71308").then(e)}},{path:"/pages/9b7dad/index.html",redirect:"/pages/9b7dad/"},{path:"/_posts/Notes/编程议题.html",redirect:"/pages/9b7dad/"},{name:"v-f6245f3a",path:"/pages/dcdff1/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-f6245f3a").then(e)}},{path:"/pages/dcdff1/index.html",redirect:"/pages/dcdff1/"},{path:"/_posts/Writing/thePowerOfTime.html",redirect:"/pages/dcdff1/"},{name:"v-b1c16cfa",path:"/tags/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-b1c16cfa").then(e)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-1bf730e3",path:"/pages/cc9a5c/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-1bf730e3").then(e)}},{path:"/pages/cc9a5c/index.html",redirect:"/pages/cc9a5c/"},{path:"/_posts/Writing/WhyYouHave2Write.html",redirect:"/pages/cc9a5c/"},{name:"v-e5b4aac8",path:"/",component:Qs,beforeEnter:(n,t,e)=>{Wo("Layout","v-e5b4aac8").then(e)}},{path:"/index.html",redirect:"/"},{path:"*",component:Qs}],Xs={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/more.png"}],["meta",{name:"keywords",content:"optimization, analysis, profile, performance, latency, throughput, metrics, linux, cache, CPU, architecture"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"Wiki",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.Wiki",description:"Technical & Lab doc"}},title:"Wiki",date:"2020-03-11T21:50:53.000Z",permalink:"/wiki/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/00.NavBar/01.Wiki.html",relativePath:"00.NavBar/01.Wiki.md",key:"v-465a10a3",path:"/wiki/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/30, 23:47:28",lastUpdatedTimestamp:1656604048e3},{title:"Authoring",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"02.Authoring",description:"some simple writings"}},title:"Authoring",date:"2020-03-11T21:50:54.000Z",permalink:"/authoring/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/00.NavBar/02.Authoring.html",relativePath:"00.NavBar/02.Authoring.md",key:"v-ae8ce3d2",path:"/authoring/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/30, 23:47:28",lastUpdatedTimestamp:1656604048e3},{title:"Lean in C++",frontmatter:{pageClass:"notes",title:"Lean in C++",date:"2022-06-27T07:53:54.000Z",categories:["Wiki","C++"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/wiki/lean_in_c++/"},regularPath:"/01.Wiki/01.Lean%20in%20c++/00.ReadMe.html",relativePath:"01.Wiki/01.Lean in c++/00.ReadMe.md",key:"v-7a9dff07",path:"/wiki/lean_in_c++/",headersStr:null,content:"这其实是一个C++的常识合辑， 不得不说C++的学习给很多人都带来了挑战， 不同于其他知识的学习， C++的学习总是让人对这一块知识的边界望而生畏， 而在平时生活中， 我们对其他知识的学习， 其实多数时候内心都至少会知晓一个边界， 从这个边界往里走， 不断对边界内的知识进行分层， 分块， 解构， 一点一点地完善自己对知识的理解。\n\n但是C++仿佛一上来就把知识边界拉的十分分散， 在中国， 很多人学习编程都是从C语言， 汇编开始， 逐渐丰富到C++， 这导致越往后， 其实越感觉对底层知识边界的模糊。当边界清晰的时候， 人们往往容易建立起对一个知识掌握的信息， 而边界变得模糊的时候， 人们常常会望而生畏， 既无法规划出一个完美的学习策略， 也容易丧失信心。\n\nLean in 在这里表示一步一步加深理解的意思， 由于C++的知识边界模糊， 我希望采取一种渐进式加深理解的方式，而非直接在知识层面进行分层理解， 我们实际上需要的是在认知的早期阶段就构建出一种让自己有条不紊逐渐变强的策略， 而非对一事一物完美无缺的理解。这也是能够体现学习经验是否丰富的一个地方。既然在一开始就不能够或者就无法设置一个清晰的知识边界， 我们不妨先设立一个框架， 在一个三维立体的知识地图里面先抓住一个自己最容易抓住的把手， 然后从这个点出发， 不断在层次中进行水平或者垂直的移动， 来丰富自己已经掌握的知识结构；\n\n我们先从最基本的C/C++语法的关键字开始，从最小的代码片段需要注意些什么开始，这里主要是消灭在阅读代码的时候一些容易混淆的语法点，称之为Phase 0\n\n暂时计划Phase1可以是多个代码片段， 函数， 类和对象， 在构建一个大程序的时候， 一些让人傻傻分不清的概念。还有一些常规语法之外的编程技巧， 常规用法。例如前向声明， RTTI, CRTP，\n\n更进一步， 我们希望通过Phase2 和Phase 3 ， 能够了解到最核心的内容， 通过理清楚这些内容， 我们能够过渡到计算机的各个方面， 例如OS, compiler, network SW stack中， 以及Compute Arch， 理解软硬接结合之后是如何工作的，\n\n前面几个其实都是线性的关系， 到Phase3 其实就可以分叉， 会涉及到很多很多不同的方面里面去。 需要其他的很多领域知识， 并且要循环往复在不同的phase之间进行巩固对这些知识的理解，从而不断拓展和前进；\n\n关于如何划分不同的Level， 还在规划中，但是",normalizedContent:"这其实是一个c++的常识合辑， 不得不说c++的学习给很多人都带来了挑战， 不同于其他知识的学习， c++的学习总是让人对这一块知识的边界望而生畏， 而在平时生活中， 我们对其他知识的学习， 其实多数时候内心都至少会知晓一个边界， 从这个边界往里走， 不断对边界内的知识进行分层， 分块， 解构， 一点一点地完善自己对知识的理解。\n\n但是c++仿佛一上来就把知识边界拉的十分分散， 在中国， 很多人学习编程都是从c语言， 汇编开始， 逐渐丰富到c++， 这导致越往后， 其实越感觉对底层知识边界的模糊。当边界清晰的时候， 人们往往容易建立起对一个知识掌握的信息， 而边界变得模糊的时候， 人们常常会望而生畏， 既无法规划出一个完美的学习策略， 也容易丧失信心。\n\nlean in 在这里表示一步一步加深理解的意思， 由于c++的知识边界模糊， 我希望采取一种渐进式加深理解的方式，而非直接在知识层面进行分层理解， 我们实际上需要的是在认知的早期阶段就构建出一种让自己有条不紊逐渐变强的策略， 而非对一事一物完美无缺的理解。这也是能够体现学习经验是否丰富的一个地方。既然在一开始就不能够或者就无法设置一个清晰的知识边界， 我们不妨先设立一个框架， 在一个三维立体的知识地图里面先抓住一个自己最容易抓住的把手， 然后从这个点出发， 不断在层次中进行水平或者垂直的移动， 来丰富自己已经掌握的知识结构；\n\n我们先从最基本的c/c++语法的关键字开始，从最小的代码片段需要注意些什么开始，这里主要是消灭在阅读代码的时候一些容易混淆的语法点，称之为phase 0\n\n暂时计划phase1可以是多个代码片段， 函数， 类和对象， 在构建一个大程序的时候， 一些让人傻傻分不清的概念。还有一些常规语法之外的编程技巧， 常规用法。例如前向声明， rtti, crtp，\n\n更进一步， 我们希望通过phase2 和phase 3 ， 能够了解到最核心的内容， 通过理清楚这些内容， 我们能够过渡到计算机的各个方面， 例如os, compiler, network sw stack中， 以及compute arch， 理解软硬接结合之后是如何工作的，\n\n前面几个其实都是线性的关系， 到phase3 其实就可以分叉， 会涉及到很多很多不同的方面里面去。 需要其他的很多领域知识， 并且要循环往复在不同的phase之间进行巩固对这些知识的理解，从而不断拓展和前进；\n\n关于如何划分不同的level， 还在规划中，但是",charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"type cast",frontmatter:{title:"type cast",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/409de3/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/01.type%20cast.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/01.type cast.md",key:"v-7d0fcd4a",path:"/pages/409de3/",headers:[{level:2,title:"隐式转换",slug:"隐式转换",normalizedTitle:"隐式转换",charIndex:86},{level:3,title:"整型提升",slug:"整型提升",normalizedTitle:"整型提升",charIndex:1876},{level:2,title:"显式转换",slug:"显式转换",normalizedTitle:"显式转换",charIndex:2332},{level:3,title:"static_cast",slug:"static-cast",normalizedTitle:"static_cast",charIndex:19},{level:3,title:"dynamic_cast",slug:"dynamic-cast",normalizedTitle:"dynamic_cast",charIndex:31},{level:3,title:"reinterpret_cast",slug:"reinterpret-cast",normalizedTitle:"reinterpret_cast",charIndex:55},{level:3,title:"const_cast",slug:"const-cast",normalizedTitle:"const_cast",charIndex:44},{level:2,title:"C语言中的强制类型转换",slug:"c语言中的强制类型转换",normalizedTitle:"c语言中的强制类型转换",charIndex:664},{level:2,title:"Summary",slug:"summary",normalizedTitle:"summary",charIndex:6505},{level:2,title:"static_cast 一些将会导致错误的情况。",slug:"static-cast-一些将会导致错误的情况。",normalizedTitle:"static_cast 一些将会导致错误的情况。",charIndex:7589},{level:4,title:"泛型(Generic Types)",slug:"泛型-generic-types",normalizedTitle:"泛型(generic types)",charIndex:7617},{level:4,title:"指针类型(Pointer Types)``",slug:"指针类型-pointer-types",normalizedTitle:"指针类型(pointer types)``",charIndex:8225},{level:5,title:"情况1：两个无关的类之间的转换",slug:"情况1-两个无关的类之间的转换",normalizedTitle:"情况1：两个无关的类之间的转换",charIndex:8719},{level:5,title:"情况2：转换到相关的类",slug:"情况2-转换到相关的类",normalizedTitle:"情况2：转换到相关的类",charIndex:9184},{level:5,title:"情况3：void之间的向前和向后转换",slug:"情况3-void之间的向前和向后转换",normalizedTitle:"情况3：void之间的向前和向后转换",charIndex:10482}],excerpt:"<p>C++中的类型转换， 四种cast: static_cast、dynamic_cast、const_cast和reinterpret_cast, 以及其他转换方法</p>\n",headersStr:"隐式转换 整型提升 显式转换 static_cast dynamic_cast reinterpret_cast const_cast C语言中的强制类型转换 Summary static_cast 一些将会导致错误的情况。 泛型(Generic Types) 指针类型(Pointer Types)`` 情况1：两个无关的类之间的转换 情况2：转换到相关的类 情况3：void之间的向前和向后转换",content:'C++中的类型转换， 四种cast: static_cast、dynamic_cast、const_cast和reinterpret_cast, 以及其他转换方法\n\n\n# 隐式转换\n\n在不同类型之间进行赋值，其根据类型不同得到不同的结果，如下为基本的转换规则:\n\n 1.  非布尔->布尔：0->false; 非0->true\n\n 2.  布尔->非布尔：false->0; true->1\n\n 3.  浮点->整数：近似处理，保留浮点数小数点之前的部分\n\n 4.  整数->浮点数：小数部分记为0，如果整数所占空间超过浮点类型容量，精度会产生损失\n\n 5.  给无符号类型一个超过其表示范围的值时，结果是初始值对无符号类型表示数值的总数取模以后的余数。例如unsigned char(8 bit) 可以表示0-255，如果赋一个区间以外的值，则实际结果为该值对256取模所得的余数。unsigned char x = -1; // x = 255\n\n 6.  当赋给带符号类型一个超过其表示范围的值时，结果是未定义的。此时程序可能继续工作、可能崩溃，也可能产生垃圾数据（未定义）\n\n 7.  无符号数转换为更大的数据类型时, 只需简单地在开头添加0，这种运算称为0扩展\n\n 8.  将有符号数转换为更大的数据类型需要执行符号扩展，规则是将当前数符号位扩展至所需要的位数\n\n 9.  当数据类型转换时，同时需要在不同数据大小，以及无符号和有符号之间转换时，C语言标准要求先进行数据大小的转换，之后再进行无符号和有符号之间的转换。C语言中的强制类型转换保持二进制位值不变，只是改变解释位的方式。\n\n 10. 将一个大的数据类型转换为小的数据类型时，不管是无符号数还是有符号数都是简单地进行位截断\n\n 11. 进行整数的算术运算时，当结果变量的位数不足以存放实际实际结果的位数时，运算的结果就会因截断而产生溢出\n     \n     #include <iostream>\n     #include <limits>\n     using namespace std;\n     \n     int main()\n     {\n         bool bValue = true;\n         char cValue = numeric_limits<char>::max();\n         short sValue = numeric_limits<short>::max();\n         int iValue = numeric_limits<int>::max();\n         long lValue = numeric_limits<long>::max();\n         long long llValue = numeric_limits<long long>::max();\n         float fValue = numeric_limits<float>::max();\n         double dValue = numeric_limits<double>::max();\n         long double ldValue = numeric_limits<long double>::max();\n     \n         //测试开始\n         cout << (bValue=cValue) << " " << (bValue=sValue) << " " << (bValue=iValue) <<endl;\n         cout << (bValue=lValue) << " " << (bValue=llValue) << " " << (bValue=fValue) <<endl;\n         cout << (bValue=dValue) << " " << (bValue=ldValue) << endl;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     \n     \n     以上输出为全1。\n\n\n# 整型提升\n\n负责把小整数装换成较大的整数类型，\n\n对于bool、char、signed char、unsigned char、short、unisned short等类型，只要他们所有可能的值都能存在int类型中，就会提升为int，否则提升为unsigned int。\n\nwchar_t、char16_t、char32_6提升成int、unsigned int、long、unsigned long、long long、unsigned long long中最小的一种，前提是能容纳原始类型所有可能的值\n\n无符号与有符号之间的转换有几种情况：\n\n 1. 如果无符号类型不小于带符号类型，则有符号类型转换成无符号类型，如int需要转换成unsigned int。如果有符号是负数，则取模运算\n 2. 如果带符号大于无符号且带符号类型可以容纳所有无符号值，则转换成带符号，否则转换成无符号。比如long和unsigned int，如果int和long大小相同，则long类型转换成unsigned int。\n\n\n# 显式转换\n\n\n# static_cast\n\nstatic_cast< new_type >(expression)\n\n\n1\n\n\n相当于传统的C语言里的强制转换: 把expression转换为new_type类型\n\ncompile time检查，用于非多态的转换，可以转换指针及其他\n\n没有运行时类型检查来保证转换的安全性\n\n用法\n\n 1. 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。\n    1. 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；\n    2. 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。\n 2. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。\n 3. 把空指针转换成目标类型的空指针。\n 4. 把任何类型的表达式转换成void类型。\n\nstatic_cast不能转换掉expression的const、volatile、或者__unaligned属性\n\nchar a = \'a\';\nint b = static_cast<int>(a);//正确，将char型数据转换成int型数据\ndouble *c = new double;\nvoid *d = static_cast<void*>(c);//正确，将double指针转换成void指针\nint e = 10;\nconst int f = static_cast<const int>(e);//正确，将int型数据转换成const int型数据\nconst int g = 20;\nint *h = static_cast<int*>(&g);//编译错误，static_cast不能转换掉g的const属性\nclass Base\n{};\nclass Derived : public Base\n{}\nBase* pB = new Base();\nif(Derived* pD = static_cast<Derived*>(pB))\n{} //下行转换是不安全的(坚决抵制这种方法)\nDerived* pD = new Derived();\nif(Base* pB = static_cast<Base*>(pD))\n{} //上行转换是安全的\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。\n\n\n# dynamic_cast\n\ndynamic_cast 是C++对多态支持的强制类型转换。 所以class 里面必须有 virtual function； 通过运行时类型识别(RTTI)，程序能够使用基类的指针或引用来检索这些指针或引用所指对象的实际派生类型。\n\n与其他强制类型转换不同，dynamic_cast涉及运行时类型检查(RTTI)。 如果绑定到引用或指针的对象不是目标类型的对象，则 dynamic_cast 失败。有两种情况:\n\n 1. to pointer : 如果转换到指针类型的dynamic_cast失败，则dynamic_cast的结果是 0 值；\n 2. to reference : 如果转换到引用类型的dynamic_cast失败，则抛出一个bad_cast类型的异常。\n\ndynamic_cast<type*>(expr) \t//type必须是一个类类型且必须是一个有效的指针\ndynamic_cast<type&>(expr) \t//type必须是一个类类型且必须是一个左值\ndynamic_cast<type&&>(expr) \t//type必须是一个类类型且必须是一个右值\n\n\n1\n2\n3\n\n\nexpr的类型必须符合以下三个条件中的任何一个：\n\n 1. expr的类型是目标类型type的公有派生类\n 2. expr的类型是目标type的共有基类\n 3. expr的类型就是目标type的类型。\n\n用法\n\n * dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换（cross cast）。\n * 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；\n * 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。\n * dynamic_cast是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。\n\nif(Derived *dp = dynamic_cast<Derived *>(bp)){\n    //使用dp指向的Derived对象 \n}\nelse{\n    //使用bp指向的Base对象 \n}\nvoid f(const Base &b){\n    try{\n        const Derived &d = dynamic_cast<const Base &>(b); \n        //使用b引用的Derived对象\n    }\n    catch(std::bad_cast){\n        //处理类型转换失败的情况\n    }\n}\n \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# reinterpret_cast\n\n仅仅重新解释类型，但没有进行二进制的转换：\n\n转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。\n\n在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。\n\n最普通的用途就是在函数指针类型之间进行转换。\n\n很难保证移植性。\n\n用法可以总结如下：\n\n 1. 去const属性用const_cast。\n 2. 基本类型转换用static_cast。\n 3. 多态类之间的类型转换用daynamic_cast。\n 4. 不同类型的指针类型转换用reinterpret_cast。\n\n通常为运算对象的位模式提供较低层次上的重新解释。即要求编译器将两种无关联的类型作转换。\n\n * reinterpret_cast本质上依赖于机器。要想安全地使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。\n * 较危险， 慎用\n\n\n# const_cast\n\n这个操作符可以暂时去掉变量const属性或者volatile属性的转换符，这样就可以更改const变量了。比如下面代码\n\nstring str = "hello";\nchar *_const = str.substr(0,3).c_str();//c_str()返回const char*类型，直接赋值给char *显然出错，这句话编译不能通过\nchar *_non_const = const_cast<char *> (str.substr(0,3).c_str());  //将const属性移除，可以通过编译了\n\n\n1\n2\n3\n\n * const_cast， const_cast 只能改变运算对象的low_level const\n * 一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了。\n * 如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。\n\n\n# C语言中的强制类型转换\n\n在引入命名的强制类型转换操作符之前，显式强制转换用圆括号将类型括起来实现：\n\nchar *pc = (char*) ip;\n\n\n1\n\n\n效果与使用 reinterpret_cast 符号相同，但这种强制转换的可视性比较差，难以跟踪错误的转换。\n\n标准 C++ 为了加强类型转换的可视性，引入命名的强制转换操作符，为程序员在必须使用强制转换时提供了更好的工具。例如，非指针的 static_cast 和const_cast 要比 reinterpret_cast 更安全。 结果使程序员（以及读者和操纵程序的工具）可清楚地辨别代码中每个显式的强制转换潜在的风险级别。\n\n虽然标准 C++ 仍然支持旧式强制转换符号，但是我们建议，只有在 C 语言或标准 C++ 之前的编译器上编写代码时，才使用这种语法。 旧式强制转换符号有下列两种形式：\n\ntype (expr); // Function-style cast notation\n(type) expr; // C-language-style cast notation\n\n\n1\n2\n\n\n旧式强制转换依赖于所涉及的数据类型，具有与 const_cast、 static_cast 和 reinterpret_cast 一样的行为。 在合法使用 static_cast 或 const_cast 的地方，旧式强制转换提供了与各自对应的命名强制转换一样的功能。 如果这两种强制转换均不合法，则旧式强制转换执行 reinterpret_cast 功能。 例如，我们可用旧式符号重写上一节的强制转换:\n\nint ival; double dval;      \nival += int (dval);         // static_cast: converts double to int\nconst char* pc_str;     \nstring_copy((char*)pc_str); // const_cast: casts away const\nint *ip;     \nchar *pc = (char*)ip;       // reinterpret_cast: treats int as char\n\n\n1\n2\n3\n4\n5\n6\n\n\n支持旧式强制转换符号是为了对“在标准 C++ 之前编写的程序”保持向后兼容性，并保持与 C 语言的兼容性。\n\n\n# Summary\n\nreinterpret_cast可以转换任意一个32bit整数，包括所有的指针和整数。可以把任何整数转成指针，也可以把任何指针转成整数，以及把指针转化为任意类型的指针，威力最为强大！但不能将非32bit的实例转成指针。总之，只要是32bit的东东，怎么转都行！\n\nstatic_cast和dynamic_cast可以执行指针到指针的转换，或实例本身到实例本身的转换，但不能在实例和指针之间转换。\n\nstatic_cast只能提供编译时的类型安全， 而dynamic_cast可以提供运行时类型安全。举个例子：\n\nclass a；\nclass b:a；\nclass c;\n\n\n1\n2\n3\n\n\n上面三个类a是基类，b继承a，c和ab没有关系。\n\n有一个函数\n\nvoid function(a &a); \n\n\n1\n\n\n现在有一个对象是b的实例b，一个c的实例c。\n\nfunction(static_cast<a&>(b)可以通过而 function(static_cast<a&>(c))不能通过编译，因为在编译的时候编译器已经知道c和a的类型不符，因此static_cast可以保证安全。\n\n下面我们骗一下编译器，先把c转成类型a\n\nb& ref_b = reinterpret_cast<b&>c; \n\n\n1\n\n\n然后function(static_cast<a&>(ref_b))就通过了！因为从编译器的角度来看，在编译时并不能知道ref_b实际上是c！\n\nfunction(dynamic_cast<a&>(ref_b))编译时也能过，但在运行时失败了，因为dynamic_cast在运行时会检查ref_b的实际类型，这样就骗不过去了。\n\n在应用多态编程时，当我们无法确定传过来的对象的实际类型时使用dynamic_cast，如果能保证对象的实际类型，用 static_cast 就可以了。\n\n 1. dynamic_cast:动态类型转换\n 2. static_cast:静态类型转换\n 3. reinterpret_cast:重新解释类型转换\n 4. const_cast:常量类型转换\n\n一些常规操作:\n\n 1. dynamic_cast 一般用在父类和子类指针或应用的互相转化;\n 2. static_cast 一般是普通数据类型(如int m =static_cast(3.14));\n 3. reinterpret_cast 很像c的一般暴力类型转换操作\n 4. const_cast 是把cosnt或volatile属性去掉\n\n\n# static_cast 一些将会导致错误的情况。\n\n# 泛型(Generic Types)\n\nfloat f = 12.3;\nfloat *pf = &f;\n// static cast<>\n// 成功编译, n = 12\nint n = static_cast<int>(f);\n\n// 错误,指向的类型是无关的(译注：即指针变量pf是float类型，现在要被转换为int类型)\nint* pn = static_cast<int*>(pf);\n\n//成功编译\nvoid* pv = static_cast<void*>(pf);\n\nint* pn2 = static_cast<int*>(pv); //成功编译, 但是 *pn2是无意义的内存(rubbish)\n// reinterpret_cast<>\n\nint i = reinterpret_cast<int>(f);     //错误,编译器知道你应该调用static_cast<>\nint* pi = reinterpret_cast<int*>(pf); //成功编译, 但是 *pi 实际上是无意义的内存,和 *pn2一样\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n简而言之，static_cast<> 将尝试转换，举例来说，如float-到-integer，而reinterpret_cast<>将改变编译器的意图重新将对象作为另一类型来处理\n\n# 指针类型(Pointer Types)``\n\n指针转换有点复杂，后面其情况都会使用下面的类：\n\nclass CBaseX\n{\n    public:\n        int x;\n        CBaseX() { x = 10; }\n        void foo() { printf("CBaseX::foo() x =%d/n", x); }\n};\n\nclass CBaseY\n{\n    public:\n        int y;\n        int* py;\n        CBaseY() { y = 20; py = &y; }\n        void bar() { printf("CBaseY::bar() y =%d, *py =%d/n", y, *py); }\n};\n\nclass CDerived : public CBaseX, public CBaseY\n{\n    public:\n    \tint z;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 情况1：两个无关的类之间的转换\n\n// Convert between CBaseX* and CBaseY*\n// CBaseX* 和 CBaseY*之间的转换\nCBaseX* pX = new CBaseX(); // Error, types pointed to are unrelated\nCBaseY* pY1 = static_cast<CBaseY*>(pX); // Compile OK, but pY2 is not CBaseX\n\nCBaseY* pY2 = reinterpret_cast<CBaseY*>(pX); // System crash!!!\n// pY2->bar();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n正如我们在泛型例子中所认识到的，如果你尝试转换一个对象到另一个无关的类static_cast<>将失败，而reinterpret_cast<>就总是成功“欺骗”编译器：那个对象就是那个无关类。但是在运行的时候由于编译器对被转换的对象会发生错误的解释, 程序会crash掉.\n\n# 情况2：转换到相关的类\n\nCDerived* pD = new CDerived();\nprintf("CDerived* pD = %x/n", (int)pD);\n// static_cast<> CDerived* -> CBaseY* -> CDerived*\nCBaseY* pY1 = pD; //成功编译，隐式static_cast<>转换\nprintf("CBaseY* pY1 = %x/n", (int)pY1);\n\nCDerived* pD1 = static_cast<CDerived*>(pY1);// 成功编译, 现在 pD1 = pD\nprintf("CDerived* pD1 = %x/n", (int)pD1);\n// reinterpret_cast\nCBaseY* pY2 = reinterpret_cast<CBaseY*>(pD);// 成功编译, 但是 pY2 不是 CBaseY*\nprintf("CBaseY* pY2 = %x/n", (int)pY2);\n\n// 无关的 static_cast<>\nCBaseY* pY3 = new CBaseY();\nprintf("CBaseY* pY3 = %x/n", (int)pY3);\n\nCDerived* pD3 = static_cast<CDerived*>(pY3);// 成功编译,尽管 pY3 只是一个 "新 CBaseY()"\nprintf("CDerived* pD3 = %x/n", (int)pD3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n---------------------- output ---------------------------\n\nCDerived* pD = 392fb8\n\nCBaseY* pY1 = 392fbc\n\nCDerived* pD1 = 392fb8\n\nCBaseY* pY2 = 392fb8\n\nCBaseY* pY3 = 390ff0\n\nCDerived* pD3 = 390fec\n\n注意：在将CDerived用隐式 static_cast<>转换到CBaseY(第5行)时，结果是(指向)CDerived*(的指针向后) 偏移了4(个字节)(译注：4为int类型在内存中所占字节数)。为了知道static_cast<> 实际如何，我们不得不要来看一下CDerived的内存布局。\n\nCDerived的内存布局包括两个对象，CBaseX 和 CBaseY，编译器也知道这一点。因此，当将CDerived* 转换到 CBaseY时，它给指针添加4个字节，同时当你将CBaseY转换到CDerived*时，它给指针减去4。然而，甚至它即便不是一个CDerived你也可以这样做。\n\n当然，这个问题只在如果你做了多继承时发生。在你将CDerived转换 到 CBaseX时static_cast<> 和 reinterpret_cast<>是没有区别的。\n\n# 情况3：void之间的向前和向后转换\n\n因为任何指针可以被转换到void，而void*可以被向后转换到任何指针(对于static_cast<> 和 reinterpret_cast<>转换都可以这样做)，如果没有小心处理的话错误可能发生。\n\nCDerived* pD = new CDerived();\nprintf("CDerived* pD = %x/n", (int)pD);\nCBaseY* pY = pD; // 成功编译, pY = pD + 4\nprintf("CBaseY* pY = %x/n", (int)pY);\nvoid* pV1 = pY; //成功编译, pV1 = pY\nprintf("void* pV1 = %x/n", (int)pV1);\n// pD2 = pY, 但是我们预期 pD2 = pY - 4\nCDerived* pD2 = static_cast<CDerived*>(pV1);\nprintf("CDerived* pD2 = %x/n", (int)pD2);\n// pD2->bar();// 系统崩溃\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n---------------------- 输出 ---------------------------\n\nCDerived* pD = 392fb8\n\nCBaseY* pY = 392fbc\n\nvoid* pV1 = 392fbcd\n\nCDerived* pD2 = 392fbc\n\n一旦我们已经转换指针为void，我们就不能轻易将其转换回原类。在上面的例子中，从一个void 返回CDerived的唯一方法是将其转换为CBaseY然后再转换为CDerived。 但是如果我们不能确定它是CBaseY* 还是 CDerived*，这时我们不得不用dynamic_cast<> 或typeid[2]。\n\n注释：\n\n 1. dynamic_cast<>, 从另一方面来说，可以防止一个泛型CBaseY* 被转换到CDerived*。\n\n 2. dynamic_cast<>, 需要类成为多态，即包括“虚”函数，并因此而不能成为void*。',normalizedContent:'c++中的类型转换， 四种cast: static_cast、dynamic_cast、const_cast和reinterpret_cast, 以及其他转换方法\n\n\n# 隐式转换\n\n在不同类型之间进行赋值，其根据类型不同得到不同的结果，如下为基本的转换规则:\n\n 1.  非布尔->布尔：0->false; 非0->true\n\n 2.  布尔->非布尔：false->0; true->1\n\n 3.  浮点->整数：近似处理，保留浮点数小数点之前的部分\n\n 4.  整数->浮点数：小数部分记为0，如果整数所占空间超过浮点类型容量，精度会产生损失\n\n 5.  给无符号类型一个超过其表示范围的值时，结果是初始值对无符号类型表示数值的总数取模以后的余数。例如unsigned char(8 bit) 可以表示0-255，如果赋一个区间以外的值，则实际结果为该值对256取模所得的余数。unsigned char x = -1; // x = 255\n\n 6.  当赋给带符号类型一个超过其表示范围的值时，结果是未定义的。此时程序可能继续工作、可能崩溃，也可能产生垃圾数据（未定义）\n\n 7.  无符号数转换为更大的数据类型时, 只需简单地在开头添加0，这种运算称为0扩展\n\n 8.  将有符号数转换为更大的数据类型需要执行符号扩展，规则是将当前数符号位扩展至所需要的位数\n\n 9.  当数据类型转换时，同时需要在不同数据大小，以及无符号和有符号之间转换时，c语言标准要求先进行数据大小的转换，之后再进行无符号和有符号之间的转换。c语言中的强制类型转换保持二进制位值不变，只是改变解释位的方式。\n\n 10. 将一个大的数据类型转换为小的数据类型时，不管是无符号数还是有符号数都是简单地进行位截断\n\n 11. 进行整数的算术运算时，当结果变量的位数不足以存放实际实际结果的位数时，运算的结果就会因截断而产生溢出\n     \n     #include <iostream>\n     #include <limits>\n     using namespace std;\n     \n     int main()\n     {\n         bool bvalue = true;\n         char cvalue = numeric_limits<char>::max();\n         short svalue = numeric_limits<short>::max();\n         int ivalue = numeric_limits<int>::max();\n         long lvalue = numeric_limits<long>::max();\n         long long llvalue = numeric_limits<long long>::max();\n         float fvalue = numeric_limits<float>::max();\n         double dvalue = numeric_limits<double>::max();\n         long double ldvalue = numeric_limits<long double>::max();\n     \n         //测试开始\n         cout << (bvalue=cvalue) << " " << (bvalue=svalue) << " " << (bvalue=ivalue) <<endl;\n         cout << (bvalue=lvalue) << " " << (bvalue=llvalue) << " " << (bvalue=fvalue) <<endl;\n         cout << (bvalue=dvalue) << " " << (bvalue=ldvalue) << endl;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     \n     \n     以上输出为全1。\n\n\n# 整型提升\n\n负责把小整数装换成较大的整数类型，\n\n对于bool、char、signed char、unsigned char、short、unisned short等类型，只要他们所有可能的值都能存在int类型中，就会提升为int，否则提升为unsigned int。\n\nwchar_t、char16_t、char32_6提升成int、unsigned int、long、unsigned long、long long、unsigned long long中最小的一种，前提是能容纳原始类型所有可能的值\n\n无符号与有符号之间的转换有几种情况：\n\n 1. 如果无符号类型不小于带符号类型，则有符号类型转换成无符号类型，如int需要转换成unsigned int。如果有符号是负数，则取模运算\n 2. 如果带符号大于无符号且带符号类型可以容纳所有无符号值，则转换成带符号，否则转换成无符号。比如long和unsigned int，如果int和long大小相同，则long类型转换成unsigned int。\n\n\n# 显式转换\n\n\n# static_cast\n\nstatic_cast< new_type >(expression)\n\n\n1\n\n\n相当于传统的c语言里的强制转换: 把expression转换为new_type类型\n\ncompile time检查，用于非多态的转换，可以转换指针及其他\n\n没有运行时类型检查来保证转换的安全性\n\n用法\n\n 1. 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。\n    1. 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；\n    2. 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。\n 2. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。\n 3. 把空指针转换成目标类型的空指针。\n 4. 把任何类型的表达式转换成void类型。\n\nstatic_cast不能转换掉expression的const、volatile、或者__unaligned属性\n\nchar a = \'a\';\nint b = static_cast<int>(a);//正确，将char型数据转换成int型数据\ndouble *c = new double;\nvoid *d = static_cast<void*>(c);//正确，将double指针转换成void指针\nint e = 10;\nconst int f = static_cast<const int>(e);//正确，将int型数据转换成const int型数据\nconst int g = 20;\nint *h = static_cast<int*>(&g);//编译错误，static_cast不能转换掉g的const属性\nclass base\n{};\nclass derived : public base\n{}\nbase* pb = new base();\nif(derived* pd = static_cast<derived*>(pb))\n{} //下行转换是不安全的(坚决抵制这种方法)\nderived* pd = new derived();\nif(base* pb = static_cast<base*>(pd))\n{} //上行转换是安全的\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。\n\n\n# dynamic_cast\n\ndynamic_cast 是c++对多态支持的强制类型转换。 所以class 里面必须有 virtual function； 通过运行时类型识别(rtti)，程序能够使用基类的指针或引用来检索这些指针或引用所指对象的实际派生类型。\n\n与其他强制类型转换不同，dynamic_cast涉及运行时类型检查(rtti)。 如果绑定到引用或指针的对象不是目标类型的对象，则 dynamic_cast 失败。有两种情况:\n\n 1. to pointer : 如果转换到指针类型的dynamic_cast失败，则dynamic_cast的结果是 0 值；\n 2. to reference : 如果转换到引用类型的dynamic_cast失败，则抛出一个bad_cast类型的异常。\n\ndynamic_cast<type*>(expr) \t//type必须是一个类类型且必须是一个有效的指针\ndynamic_cast<type&>(expr) \t//type必须是一个类类型且必须是一个左值\ndynamic_cast<type&&>(expr) \t//type必须是一个类类型且必须是一个右值\n\n\n1\n2\n3\n\n\nexpr的类型必须符合以下三个条件中的任何一个：\n\n 1. expr的类型是目标类型type的公有派生类\n 2. expr的类型是目标type的共有基类\n 3. expr的类型就是目标type的类型。\n\n用法\n\n * dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换（cross cast）。\n * 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；\n * 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。\n * dynamic_cast是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。\n\nif(derived *dp = dynamic_cast<derived *>(bp)){\n    //使用dp指向的derived对象 \n}\nelse{\n    //使用bp指向的base对象 \n}\nvoid f(const base &b){\n    try{\n        const derived &d = dynamic_cast<const base &>(b); \n        //使用b引用的derived对象\n    }\n    catch(std::bad_cast){\n        //处理类型转换失败的情况\n    }\n}\n \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# reinterpret_cast\n\n仅仅重新解释类型，但没有进行二进制的转换：\n\n转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。\n\n在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。\n\n最普通的用途就是在函数指针类型之间进行转换。\n\n很难保证移植性。\n\n用法可以总结如下：\n\n 1. 去const属性用const_cast。\n 2. 基本类型转换用static_cast。\n 3. 多态类之间的类型转换用daynamic_cast。\n 4. 不同类型的指针类型转换用reinterpret_cast。\n\n通常为运算对象的位模式提供较低层次上的重新解释。即要求编译器将两种无关联的类型作转换。\n\n * reinterpret_cast本质上依赖于机器。要想安全地使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。\n * 较危险， 慎用\n\n\n# const_cast\n\n这个操作符可以暂时去掉变量const属性或者volatile属性的转换符，这样就可以更改const变量了。比如下面代码\n\nstring str = "hello";\nchar *_const = str.substr(0,3).c_str();//c_str()返回const char*类型，直接赋值给char *显然出错，这句话编译不能通过\nchar *_non_const = const_cast<char *> (str.substr(0,3).c_str());  //将const属性移除，可以通过编译了\n\n\n1\n2\n3\n\n * const_cast， const_cast 只能改变运算对象的low_level const\n * 一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了。\n * 如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。\n\n\n# c语言中的强制类型转换\n\n在引入命名的强制类型转换操作符之前，显式强制转换用圆括号将类型括起来实现：\n\nchar *pc = (char*) ip;\n\n\n1\n\n\n效果与使用 reinterpret_cast 符号相同，但这种强制转换的可视性比较差，难以跟踪错误的转换。\n\n标准 c++ 为了加强类型转换的可视性，引入命名的强制转换操作符，为程序员在必须使用强制转换时提供了更好的工具。例如，非指针的 static_cast 和const_cast 要比 reinterpret_cast 更安全。 结果使程序员（以及读者和操纵程序的工具）可清楚地辨别代码中每个显式的强制转换潜在的风险级别。\n\n虽然标准 c++ 仍然支持旧式强制转换符号，但是我们建议，只有在 c 语言或标准 c++ 之前的编译器上编写代码时，才使用这种语法。 旧式强制转换符号有下列两种形式：\n\ntype (expr); // function-style cast notation\n(type) expr; // c-language-style cast notation\n\n\n1\n2\n\n\n旧式强制转换依赖于所涉及的数据类型，具有与 const_cast、 static_cast 和 reinterpret_cast 一样的行为。 在合法使用 static_cast 或 const_cast 的地方，旧式强制转换提供了与各自对应的命名强制转换一样的功能。 如果这两种强制转换均不合法，则旧式强制转换执行 reinterpret_cast 功能。 例如，我们可用旧式符号重写上一节的强制转换:\n\nint ival; double dval;      \nival += int (dval);         // static_cast: converts double to int\nconst char* pc_str;     \nstring_copy((char*)pc_str); // const_cast: casts away const\nint *ip;     \nchar *pc = (char*)ip;       // reinterpret_cast: treats int as char\n\n\n1\n2\n3\n4\n5\n6\n\n\n支持旧式强制转换符号是为了对“在标准 c++ 之前编写的程序”保持向后兼容性，并保持与 c 语言的兼容性。\n\n\n# summary\n\nreinterpret_cast可以转换任意一个32bit整数，包括所有的指针和整数。可以把任何整数转成指针，也可以把任何指针转成整数，以及把指针转化为任意类型的指针，威力最为强大！但不能将非32bit的实例转成指针。总之，只要是32bit的东东，怎么转都行！\n\nstatic_cast和dynamic_cast可以执行指针到指针的转换，或实例本身到实例本身的转换，但不能在实例和指针之间转换。\n\nstatic_cast只能提供编译时的类型安全， 而dynamic_cast可以提供运行时类型安全。举个例子：\n\nclass a；\nclass b:a；\nclass c;\n\n\n1\n2\n3\n\n\n上面三个类a是基类，b继承a，c和ab没有关系。\n\n有一个函数\n\nvoid function(a &a); \n\n\n1\n\n\n现在有一个对象是b的实例b，一个c的实例c。\n\nfunction(static_cast<a&>(b)可以通过而 function(static_cast<a&>(c))不能通过编译，因为在编译的时候编译器已经知道c和a的类型不符，因此static_cast可以保证安全。\n\n下面我们骗一下编译器，先把c转成类型a\n\nb& ref_b = reinterpret_cast<b&>c; \n\n\n1\n\n\n然后function(static_cast<a&>(ref_b))就通过了！因为从编译器的角度来看，在编译时并不能知道ref_b实际上是c！\n\nfunction(dynamic_cast<a&>(ref_b))编译时也能过，但在运行时失败了，因为dynamic_cast在运行时会检查ref_b的实际类型，这样就骗不过去了。\n\n在应用多态编程时，当我们无法确定传过来的对象的实际类型时使用dynamic_cast，如果能保证对象的实际类型，用 static_cast 就可以了。\n\n 1. dynamic_cast:动态类型转换\n 2. static_cast:静态类型转换\n 3. reinterpret_cast:重新解释类型转换\n 4. const_cast:常量类型转换\n\n一些常规操作:\n\n 1. dynamic_cast 一般用在父类和子类指针或应用的互相转化;\n 2. static_cast 一般是普通数据类型(如int m =static_cast(3.14));\n 3. reinterpret_cast 很像c的一般暴力类型转换操作\n 4. const_cast 是把cosnt或volatile属性去掉\n\n\n# static_cast 一些将会导致错误的情况。\n\n# 泛型(generic types)\n\nfloat f = 12.3;\nfloat *pf = &f;\n// static cast<>\n// 成功编译, n = 12\nint n = static_cast<int>(f);\n\n// 错误,指向的类型是无关的(译注：即指针变量pf是float类型，现在要被转换为int类型)\nint* pn = static_cast<int*>(pf);\n\n//成功编译\nvoid* pv = static_cast<void*>(pf);\n\nint* pn2 = static_cast<int*>(pv); //成功编译, 但是 *pn2是无意义的内存(rubbish)\n// reinterpret_cast<>\n\nint i = reinterpret_cast<int>(f);     //错误,编译器知道你应该调用static_cast<>\nint* pi = reinterpret_cast<int*>(pf); //成功编译, 但是 *pi 实际上是无意义的内存,和 *pn2一样\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n简而言之，static_cast<> 将尝试转换，举例来说，如float-到-integer，而reinterpret_cast<>将改变编译器的意图重新将对象作为另一类型来处理\n\n# 指针类型(pointer types)``\n\n指针转换有点复杂，后面其情况都会使用下面的类：\n\nclass cbasex\n{\n    public:\n        int x;\n        cbasex() { x = 10; }\n        void foo() { printf("cbasex::foo() x =%d/n", x); }\n};\n\nclass cbasey\n{\n    public:\n        int y;\n        int* py;\n        cbasey() { y = 20; py = &y; }\n        void bar() { printf("cbasey::bar() y =%d, *py =%d/n", y, *py); }\n};\n\nclass cderived : public cbasex, public cbasey\n{\n    public:\n    \tint z;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 情况1：两个无关的类之间的转换\n\n// convert between cbasex* and cbasey*\n// cbasex* 和 cbasey*之间的转换\ncbasex* px = new cbasex(); // error, types pointed to are unrelated\ncbasey* py1 = static_cast<cbasey*>(px); // compile ok, but py2 is not cbasex\n\ncbasey* py2 = reinterpret_cast<cbasey*>(px); // system crash!!!\n// py2->bar();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n正如我们在泛型例子中所认识到的，如果你尝试转换一个对象到另一个无关的类static_cast<>将失败，而reinterpret_cast<>就总是成功“欺骗”编译器：那个对象就是那个无关类。但是在运行的时候由于编译器对被转换的对象会发生错误的解释, 程序会crash掉.\n\n# 情况2：转换到相关的类\n\ncderived* pd = new cderived();\nprintf("cderived* pd = %x/n", (int)pd);\n// static_cast<> cderived* -> cbasey* -> cderived*\ncbasey* py1 = pd; //成功编译，隐式static_cast<>转换\nprintf("cbasey* py1 = %x/n", (int)py1);\n\ncderived* pd1 = static_cast<cderived*>(py1);// 成功编译, 现在 pd1 = pd\nprintf("cderived* pd1 = %x/n", (int)pd1);\n// reinterpret_cast\ncbasey* py2 = reinterpret_cast<cbasey*>(pd);// 成功编译, 但是 py2 不是 cbasey*\nprintf("cbasey* py2 = %x/n", (int)py2);\n\n// 无关的 static_cast<>\ncbasey* py3 = new cbasey();\nprintf("cbasey* py3 = %x/n", (int)py3);\n\ncderived* pd3 = static_cast<cderived*>(py3);// 成功编译,尽管 py3 只是一个 "新 cbasey()"\nprintf("cderived* pd3 = %x/n", (int)pd3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n---------------------- output ---------------------------\n\ncderived* pd = 392fb8\n\ncbasey* py1 = 392fbc\n\ncderived* pd1 = 392fb8\n\ncbasey* py2 = 392fb8\n\ncbasey* py3 = 390ff0\n\ncderived* pd3 = 390fec\n\n注意：在将cderived用隐式 static_cast<>转换到cbasey(第5行)时，结果是(指向)cderived*(的指针向后) 偏移了4(个字节)(译注：4为int类型在内存中所占字节数)。为了知道static_cast<> 实际如何，我们不得不要来看一下cderived的内存布局。\n\ncderived的内存布局包括两个对象，cbasex 和 cbasey，编译器也知道这一点。因此，当将cderived* 转换到 cbasey时，它给指针添加4个字节，同时当你将cbasey转换到cderived*时，它给指针减去4。然而，甚至它即便不是一个cderived你也可以这样做。\n\n当然，这个问题只在如果你做了多继承时发生。在你将cderived转换 到 cbasex时static_cast<> 和 reinterpret_cast<>是没有区别的。\n\n# 情况3：void之间的向前和向后转换\n\n因为任何指针可以被转换到void，而void*可以被向后转换到任何指针(对于static_cast<> 和 reinterpret_cast<>转换都可以这样做)，如果没有小心处理的话错误可能发生。\n\ncderived* pd = new cderived();\nprintf("cderived* pd = %x/n", (int)pd);\ncbasey* py = pd; // 成功编译, py = pd + 4\nprintf("cbasey* py = %x/n", (int)py);\nvoid* pv1 = py; //成功编译, pv1 = py\nprintf("void* pv1 = %x/n", (int)pv1);\n// pd2 = py, 但是我们预期 pd2 = py - 4\ncderived* pd2 = static_cast<cderived*>(pv1);\nprintf("cderived* pd2 = %x/n", (int)pd2);\n// pd2->bar();// 系统崩溃\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n---------------------- 输出 ---------------------------\n\ncderived* pd = 392fb8\n\ncbasey* py = 392fbc\n\nvoid* pv1 = 392fbcd\n\ncderived* pd2 = 392fbc\n\n一旦我们已经转换指针为void，我们就不能轻易将其转换回原类。在上面的例子中，从一个void 返回cderived的唯一方法是将其转换为cbasey然后再转换为cderived。 但是如果我们不能确定它是cbasey* 还是 cderived*，这时我们不得不用dynamic_cast<> 或typeid[2]。\n\n注释：\n\n 1. dynamic_cast<>, 从另一方面来说，可以防止一个泛型cbasey* 被转换到cderived*。\n\n 2. dynamic_cast<>, 需要类成为多态，即包括“虚”函数，并因此而不能成为void*。',charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"C++ Glimpse",frontmatter:{title:"C++ Glimpse",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/8744f7/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/00.C++%20Glimpse.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/00.C++ Glimpse.md",key:"v-18718c04",path:"/pages/8744f7/",headers:[{level:2,title:"关键字是最好的边界：C++ Keywords",slug:"关键字是最好的边界-c-keywords",normalizedTitle:"关键字是最好的边界：c++ keywords",charIndex:61},{level:2,title:"C++ Preprocess（预处理）",slug:"c-preprocess-预处理",normalizedTitle:"c++ preprocess（预处理）",charIndex:3364},{level:3,title:"conditionally ：#if #else #elif #ifdef #ifndef #endif #elifdef, #elifndef (since C++23)",slug:"conditionally-if-else-elif-ifdef-ifndef-endif-elifdef-elifndef-since-c-23",normalizedTitle:"conditionally ：#if #else #elif #ifdef #ifndef #endif #elifdef, #elifndef (since c++23)",charIndex:3858},{level:3,title:"replace：",slug:"replace",normalizedTitle:"replace：",charIndex:3953},{level:3,title:"Include",slug:"include",normalizedTitle:"include",charIndex:4344},{level:3,title:"error",slug:"error",normalizedTitle:"error",charIndex:3597},{level:3,title:"Implementation defined :   behavior control",slug:"implementation-defined-behavior-control",normalizedTitle:"implementation defined :   behavior control",charIndex:null},{level:3,title:"File name and line information",slug:"file-name-and-line-information",normalizedTitle:"file name and line information",charIndex:4844},{level:3,title:"其他一些预处理指令:  defined export (C++20) import (C++20) module (C++20)",slug:"其他一些预处理指令-defined-export-c-20-import-c-20-module-c-20",normalizedTitle:"其他一些预处理指令:  defined export (c++20) import (c++20) module (c++20)",charIndex:null},{level:2,title:"C++ Expression(表达式)",slug:"c-expression-表达式",normalizedTitle:"c++ expression(表达式)",charIndex:4968},{level:3,title:"Operators 运算符",slug:"operators-运算符",normalizedTitle:"operators 运算符",charIndex:4996},{level:3,title:"Primary expressions",slug:"primary-expressions",normalizedTitle:"primary expressions",charIndex:7478},{level:3,title:"Unevaluated expressions： typeid、sizeof、noexcept 和 decltype (C++11 起)",slug:"unevaluated-expressions-typeid、sizeof、noexcept-和-decltype-c-11-起",normalizedTitle:"unevaluated expressions： typeid、sizeof、noexcept 和 decltype (c++11 起)",charIndex:7878},{level:3,title:"Discarded-value expressions ：  void, volatile",slug:"discarded-value-expressions-void-volatile",normalizedTitle:"discarded-value expressions ：  void, volatile",charIndex:null},{level:2,title:"C++ Statement (语句)",slug:"c-statement-语句",normalizedTitle:"c++ statement (语句)",charIndex:8e3},{level:2,title:"C++ 11 新增关键字",slug:"c-11-新增关键字",normalizedTitle:"c++ 11 新增关键字",charIndex:8926},{level:2,title:"C++ 17 新增关键字",slug:"c-17-新增关键字",normalizedTitle:"c++ 17 新增关键字",charIndex:9170},{level:2,title:"C++ 20 新增关键字",slug:"c-20-新增关键字",normalizedTitle:"c++ 20 新增关键字",charIndex:9187},{level:2,title:"TM_TS (Transactional Memory Technical Specification)",slug:"tm-ts-transactional-memory-technical-specification",normalizedTitle:"tm_ts (transactional memory technical specification)",charIndex:9382},{level:3,title:"特殊含义的标识符",slug:"特殊含义的标识符",normalizedTitle:"特殊含义的标识符",charIndex:9569},{level:2,title:"C++ Websites for reference",slug:"c-websites-for-reference",normalizedTitle:"c++ websites for reference",charIndex:9757}],excerpt:"<p>关键字， 最基础的用法， 以及一些常用的参考网站， 以期可以能够对繁杂的内容确定边界， 日后可以有目标地不断填充</p>\n",headersStr:"关键字是最好的边界：C++ Keywords C++ Preprocess（预处理） conditionally ：#if #else #elif #ifdef #ifndef #endif #elifdef, #elifndef (since C++23) replace： Include error Implementation defined :   behavior control File name and line information 其他一些预处理指令:  defined export (C++20) import (C++20) module (C++20) C++ Expression(表达式) Operators 运算符 Primary expressions Unevaluated expressions： typeid、sizeof、noexcept 和 decltype (C++11 起) Discarded-value expressions ：  void, volatile C++ Statement (语句) C++ 11 新增关键字 C++ 17 新增关键字 C++ 20 新增关键字 TM_TS (Transactional Memory Technical Specification) 特殊含义的标识符 C++ Websites for reference",content:'关键字， 最基础的用法， 以及一些常用的参考网站， 以期可以能够对繁杂的内容确定边界， 日后可以有目标地不断填充\n\n\n# 关键字是最好的边界：C++ Keywords\n\n一些常见的C++关键字\n\nKEYWORDS                     DESCRIPTION   KEYWORDS                 DESCRIPTION\nand                                        auto (1)                 \nbool                                       break                    \ncase                                       catch                    \nchar                                       char8_t (since C++20)    \nchar16_t (since C++11)                     char32_t (since C++11)   \nclass (1)                                  const                    \nconstexpr (since C++11)                    const_cast               \ncontinue                                   decltype (since C++11)   \ndefault (1)                                delete (1)               \ndo                                         double                   \ndynamic_cast                               else                     \nenum                                       explicit                 \nextern(1)                                  false                    \nfloat                                      for                      \nfriend                                     goto                     \nif                                         inline (1)               \nint                                        long                     \nnamespace                                  new                      \nnoexcept (since C++11)                     not                      \nnullptr (since C++11)                      operator                 \nor                                         or_eq                    \nprivate                                    protected                \npublic                                     reinterpret_cast         \nreturn                                     short                    \nsigned                                     sizeof (1)               \nstatic                                     static_cast              \nstruct (1)                                 switch                   \ntemplate                                   this                     \nthread_local (since C++11)                 throw                    \ntrue                                       try                      \ntypedef                                    typeid                   \ntypename                                   union                    \nunsigned                                   using (1)                \nvirtual                                    void                     \nvolatile                                   wchar_t                  \nwhile                                      xor                      \nxor_eq                                                              \n\n一些不那么常见的关键字：\n\nKEYWORDS                  DESCRIPTION   KEYWORDS                  DESCRIPTION\nalignas (since C++11)                   alignof (since C++11)     \nand_eq                                  asm                       \natomic_cancel (TM TS)                   atomic_commit (TM TS)     \natomic_noexcept (TM TS)                 bitand                    \nbitor                                   compl                     \nconcept (since C++20)                   consteval (since C++20)   \nconstinit (since C++20)                 co_await (since C++20)    \nco_return (since C++20)                 co_yield (since C++20)    \n\n\n# C++ Preprocess（预处理）\n\n一些预处理指令, 由C++ 预处理器（preprocessor）进行处理；\n\nIF      IFDEF    INCLUDE   DEFINED                             EXPORT (C++20)\nelif    ifndef   line      __has_include (since C++17)         import (C++20)\nelse    define   error     __has_cpp_attribute (since C++20)   module (C++20)\nendif   undef    pragma                                        \n\nfollowing tokens are recognized by the preprocessor outside the context of a preprocessor directive:\n\n * _Pragma (since C++11)\n\n\n 1. # conditionally ：#if #else #elif #ifdef #ifndef #endif #elifdef, #elifndef (since C++23)\n\n\n 2. # replace：\n    \n    * #define #undef\n    * # : 在运行形参替换的基础上以引号包围，实际上创建一个字符串字面量。\n    * ##: 在运行形参替换的基础上将结果进行拼接。\n    * 其他的一些Macro:\n      * _FILE_ 展开成当前文件名，作为字符串字面量，可用 #line 指令更改(宏常量)\n      * __LINE: 展开成源文件行号，整数常量，可用 #line 指令更改(宏常量)\n      * __DATE: 展开成翻译日期，形式为 "Mmm dd yyyy" 的字符串。如果月中日期数小于 10 则 "dd" 的首字符为空格。月份名如同以 std::asctime() 生成(宏常量)\n      * _TIME_: 展开成翻译时间，形式为 "hh:mm:ss" 的字符串字面量(宏常量)\n\n\n 3. # Include\n    \n    1. #include\n    2. __has_include (C++17 起) 提供的可以判断是否include这个h文件\n    3. __has_cpp_attribute (C++20 起)\n\n\n 4. # error\n    \n    1. #error\n\n\n 5. # Implementation defined : behavior control\n    \n    1. #pragma\n    2. _Pragma(C++11 起)\n    3. #pragma STDC\n    4. #pragma once: 编译器只对其分析一次，即使它在同一源文件中（直接或间接）被包含了多次也是如此。\n    \n    类似的标准方式:\n\n#ifndef LIBRARY_FILENAME_H\n#define LIBRARY_FILENAME_H\n// 头文件的内容\n#endif /* LIBRARY_FILENAME_H */\n#pragma pack: 控制后续定义的类和union的最大对齐方式;\n\n\n1\n2\n3\n4\n5\n\n\n\n 6. # File name and line information\n    \n    * #line\n\n\n 7. # 其他一些预处理指令: defined export (C++20) import (C++20) module (C++20)\n\n\n# C++ Expression(表达式)\n\n\n 1. # Operators 运算符\n    \n    Common operators\n    \n    ASSIGNMENT   INCREMENT DECREMENT   ARITHMETIC   LOGICAL   COMPARISON   MEMBER ACCESS\n    a = b        ++a                   +a           !a        a == b       a[b]\n    a += b       --a                   -a           a && b    a != b       *a\n    a -= b       a++                   a + b        a || b    a < b        &a\n    a *= b       a--                   a - b                  a > b        a->b\n    a /= b                             a * b                  a <= b       a.b\n    a %= b                             a / b                  a >= b       a->*b\n    a &= b                             a % b                  a <=> b      a.*b\n    a |= b                             ~a\n    a ^= b                             a & b\n    a <<= b                            a | b\n    a >>= b                            a ^ b\n                                       a << b\n                                       a >> b\n    \n    SPECIAL OPERATORS\n    static_cast converts one type to another related type\n    dynamic_cast converts within inheritance hierarchies\n    const_cast adds or removes cv qualifiers\n    reinterpret_cast converts type to unrelated type\n    C-style cast converts one type to another by a mix of\n    static_cast, const_cast, and reinterpret_cast\n    new creates objects with dynamic storage duration\n    delete destructs objects previously created by the new\n    expression and releases obtained memory area sizeof queries\n    the size of a type\n    sizeof... queries the size of a parameter pack (since C++11)\n    typeid queries the type information of a type\n    noexcept checks if an expression can throw an exception\n    (since C++11)\n    alignof queries alignment requirements of a type (since\n    C++11)\n\n一些可以用别名代替的运算符：\n\nPRIMARY   ALTERNATIVE   含义\n&&        and           逻辑与\n||        or            逻辑或\n!         not           逻辑非\n&         bitand        按位与\n|         bitor         按位或\n&=        and_eq        按位与后赋值\n|=        or_eq         按位或后赋值\n!=        not_eq        按位取反后赋值\n^         xor           按位异或\n^=        xor_eq        按位异或后赋值\n~         compl         按位取反(Compliment)\n\nOperator overloading : operator\n\n 1. Conversions\n    1. const_cast\n    2. static_cast\n    3. dynamic_cast\n    4. reinterpret_cast\n    5. Other form of conversions\n 2. Memory allocation\n    1. new\n    2. delete(1)\n 3. Other\n    1. 常量表达式： constexpr (C++11 起)\n    2. sizeof(1)\n    3. alignof （alignas)\n    4. typeid\n    5. throw\n\n\n# Primary expressions\n\n 1. 字面量\n\n 2. CHAR           WCHAR_T           CHAR16_T (C++11 起)     CHAR32_T (C++11 起)   CHAR8_T (C++20 起)\n    float          double            long                                        \n    const char[]   const wchar_t[]   Bool （true or false)   nullptr              Std::size_t\n    \n    LAMBDA 表达式     (C++11 起)\n    折叠表达式          (C++17 起)\n    requires 表达式   (C++20 起)\n\n\n# Unevaluated expressions： typeid、sizeof、noexcept 和 decltype (C++11 起)\n\n\n# Discarded-value expressions ： void, volatile\n\n\n# C++ Statement (语句)\n\n 1.  标签：\n     \n     * Goto\n     * Switch语句中的case标签\n     * switch语句中default标签\n\n 2.  表达式语句（expression statement）；\n\n 3.  复合语句（compound statement）；\n\n 4.  选择语句（selection statement）；\n\n 5.  * If.. Else: if\n     * switch ... case ...\n     * If consteval\n\n 6.  循环语句（iteration statement）；\n\n 7.  * while\n     * do-while\n     * For …\n     * for–range-for (C++11)\n\n 8.  跳转语句（jump statement）；\n\n 9.  * Break\n     * Continue\n     * Return …\n     * Return\n     * goto\n     * continue – break – goto – return\n\n 10. 声明语句（declaration statement）；\n\n 11. try 块: Try … catch …\n\n 12. atomic 与 synchronized 块(TM TS)。 atomic 与 synchronized 块用来实现事务性内存。 synchronized and atomic (TM TS)\n\nSYNCHRONIZED 复合语句      (1)   (TM TS)\natomic_noexcept 复合语句   (2)   (TM TS)\natomic_cancel 复合语句     (3)   (TM TS)\natomic_commit 复合语句     (4)   (TM TS)\n\n(1) synchronized 块，与所有 synchronized 块在一个全序中执行； (2) 在发生异常时中止的 atomic 块； (3) 在发生异常时回滚的 atomic 块；\n\n\n# C++ 11 新增关键字\n\n * lignas (C++11 起)\n * alignof (C++11 起)\n * char16_t (C++11 起)\n * char32_t (C++11 起)\n * constexpr (C++11 起)\n * decltype (C++11 起)\n * noexcept (C++11 起)\n * nullptr (C++11 起)\n * static_assert (C++11 起)\n * thread_local (C++11 起)\n\n\n# C++ 17 新增关键字\n\n\n# C++ 20 新增关键字\n\n * char8_t (C++20 起)\n * concept (C++20 起)\n * consteval (C++20 起)\n * constinit (C++20 起)\n * co_await (C++20 起)\n * co_return (C++20 起)\n * co_yield (C++20 起)\n * requires (C++20 起)\n\n\n# TM_TS (Transactional Memory Technical Specification)\n\n * atomic_cancel (TM TS)\n * atomic_commit (TM TS)\n * atomic_noexcept (TM TS)\n * reflexpr (reflection TS)\n * synchronized (TM TS)\n\n\n# 特殊含义的标识符\n\n它们可用作对象或函数的名字，但在某些语境拥有特殊含义: (module 与 import 指令是预处理指令) override (C++11) final (C++11) import (C++20) module (C++20) transaction_safe (TM TS) transaction_safe_dynamic (TM TS)\n\n\n# C++ Websites for reference\n\n * C++ 标准基金会的官方网站: https://isocpp.org/\n   \n\n * http://www.cplusplus.com/\n   \n\n * https://en.cppreference.com/ 或者中文版 https://zh.cppreference.com/, 一些专用名词可以方便对照;\n   \n\n * C++ 标准委员会的文档列表: https://open-std.org/JTC1/SC22/WG21/docs/papers/\n   \n\n * 一些常用的额标准, 包括POSIX, C, C++: https://open-std.org/\n   ',normalizedContent:'关键字， 最基础的用法， 以及一些常用的参考网站， 以期可以能够对繁杂的内容确定边界， 日后可以有目标地不断填充\n\n\n# 关键字是最好的边界：c++ keywords\n\n一些常见的c++关键字\n\nkeywords                     description   keywords                 description\nand                                        auto (1)                 \nbool                                       break                    \ncase                                       catch                    \nchar                                       char8_t (since c++20)    \nchar16_t (since c++11)                     char32_t (since c++11)   \nclass (1)                                  const                    \nconstexpr (since c++11)                    const_cast               \ncontinue                                   decltype (since c++11)   \ndefault (1)                                delete (1)               \ndo                                         double                   \ndynamic_cast                               else                     \nenum                                       explicit                 \nextern(1)                                  false                    \nfloat                                      for                      \nfriend                                     goto                     \nif                                         inline (1)               \nint                                        long                     \nnamespace                                  new                      \nnoexcept (since c++11)                     not                      \nnullptr (since c++11)                      operator                 \nor                                         or_eq                    \nprivate                                    protected                \npublic                                     reinterpret_cast         \nreturn                                     short                    \nsigned                                     sizeof (1)               \nstatic                                     static_cast              \nstruct (1)                                 switch                   \ntemplate                                   this                     \nthread_local (since c++11)                 throw                    \ntrue                                       try                      \ntypedef                                    typeid                   \ntypename                                   union                    \nunsigned                                   using (1)                \nvirtual                                    void                     \nvolatile                                   wchar_t                  \nwhile                                      xor                      \nxor_eq                                                              \n\n一些不那么常见的关键字：\n\nkeywords                  description   keywords                  description\nalignas (since c++11)                   alignof (since c++11)     \nand_eq                                  asm                       \natomic_cancel (tm ts)                   atomic_commit (tm ts)     \natomic_noexcept (tm ts)                 bitand                    \nbitor                                   compl                     \nconcept (since c++20)                   consteval (since c++20)   \nconstinit (since c++20)                 co_await (since c++20)    \nco_return (since c++20)                 co_yield (since c++20)    \n\n\n# c++ preprocess（预处理）\n\n一些预处理指令, 由c++ 预处理器（preprocessor）进行处理；\n\nif      ifdef    include   defined                             export (c++20)\nelif    ifndef   line      __has_include (since c++17)         import (c++20)\nelse    define   error     __has_cpp_attribute (since c++20)   module (c++20)\nendif   undef    pragma                                        \n\nfollowing tokens are recognized by the preprocessor outside the context of a preprocessor directive:\n\n * _pragma (since c++11)\n\n\n 1. # conditionally ：#if #else #elif #ifdef #ifndef #endif #elifdef, #elifndef (since c++23)\n\n\n 2. # replace：\n    \n    * #define #undef\n    * # : 在运行形参替换的基础上以引号包围，实际上创建一个字符串字面量。\n    * ##: 在运行形参替换的基础上将结果进行拼接。\n    * 其他的一些macro:\n      * _file_ 展开成当前文件名，作为字符串字面量，可用 #line 指令更改(宏常量)\n      * __line: 展开成源文件行号，整数常量，可用 #line 指令更改(宏常量)\n      * __date: 展开成翻译日期，形式为 "mmm dd yyyy" 的字符串。如果月中日期数小于 10 则 "dd" 的首字符为空格。月份名如同以 std::asctime() 生成(宏常量)\n      * _time_: 展开成翻译时间，形式为 "hh:mm:ss" 的字符串字面量(宏常量)\n\n\n 3. # include\n    \n    1. #include\n    2. __has_include (c++17 起) 提供的可以判断是否include这个h文件\n    3. __has_cpp_attribute (c++20 起)\n\n\n 4. # error\n    \n    1. #error\n\n\n 5. # implementation defined : behavior control\n    \n    1. #pragma\n    2. _pragma(c++11 起)\n    3. #pragma stdc\n    4. #pragma once: 编译器只对其分析一次，即使它在同一源文件中（直接或间接）被包含了多次也是如此。\n    \n    类似的标准方式:\n\n#ifndef library_filename_h\n#define library_filename_h\n// 头文件的内容\n#endif /* library_filename_h */\n#pragma pack: 控制后续定义的类和union的最大对齐方式;\n\n\n1\n2\n3\n4\n5\n\n\n\n 6. # file name and line information\n    \n    * #line\n\n\n 7. # 其他一些预处理指令: defined export (c++20) import (c++20) module (c++20)\n\n\n# c++ expression(表达式)\n\n\n 1. # operators 运算符\n    \n    common operators\n    \n    assignment   increment decrement   arithmetic   logical   comparison   member access\n    a = b        ++a                   +a           !a        a == b       a[b]\n    a += b       --a                   -a           a && b    a != b       *a\n    a -= b       a++                   a + b        a || b    a < b        &a\n    a *= b       a--                   a - b                  a > b        a->b\n    a /= b                             a * b                  a <= b       a.b\n    a %= b                             a / b                  a >= b       a->*b\n    a &= b                             a % b                  a <=> b      a.*b\n    a |= b                             ~a\n    a ^= b                             a & b\n    a <<= b                            a | b\n    a >>= b                            a ^ b\n                                       a << b\n                                       a >> b\n    \n    special operators\n    static_cast converts one type to another related type\n    dynamic_cast converts within inheritance hierarchies\n    const_cast adds or removes cv qualifiers\n    reinterpret_cast converts type to unrelated type\n    c-style cast converts one type to another by a mix of\n    static_cast, const_cast, and reinterpret_cast\n    new creates objects with dynamic storage duration\n    delete destructs objects previously created by the new\n    expression and releases obtained memory area sizeof queries\n    the size of a type\n    sizeof... queries the size of a parameter pack (since c++11)\n    typeid queries the type information of a type\n    noexcept checks if an expression can throw an exception\n    (since c++11)\n    alignof queries alignment requirements of a type (since\n    c++11)\n\n一些可以用别名代替的运算符：\n\nprimary   alternative   含义\n&&        and           逻辑与\n||        or            逻辑或\n!         not           逻辑非\n&         bitand        按位与\n|         bitor         按位或\n&=        and_eq        按位与后赋值\n|=        or_eq         按位或后赋值\n!=        not_eq        按位取反后赋值\n^         xor           按位异或\n^=        xor_eq        按位异或后赋值\n~         compl         按位取反(compliment)\n\noperator overloading : operator\n\n 1. conversions\n    1. const_cast\n    2. static_cast\n    3. dynamic_cast\n    4. reinterpret_cast\n    5. other form of conversions\n 2. memory allocation\n    1. new\n    2. delete(1)\n 3. other\n    1. 常量表达式： constexpr (c++11 起)\n    2. sizeof(1)\n    3. alignof （alignas)\n    4. typeid\n    5. throw\n\n\n# primary expressions\n\n 1. 字面量\n\n 2. char           wchar_t           char16_t (c++11 起)     char32_t (c++11 起)   char8_t (c++20 起)\n    float          double            long                                        \n    const char[]   const wchar_t[]   bool （true or false)   nullptr              std::size_t\n    \n    lambda 表达式     (c++11 起)\n    折叠表达式          (c++17 起)\n    requires 表达式   (c++20 起)\n\n\n# unevaluated expressions： typeid、sizeof、noexcept 和 decltype (c++11 起)\n\n\n# discarded-value expressions ： void, volatile\n\n\n# c++ statement (语句)\n\n 1.  标签：\n     \n     * goto\n     * switch语句中的case标签\n     * switch语句中default标签\n\n 2.  表达式语句（expression statement）；\n\n 3.  复合语句（compound statement）；\n\n 4.  选择语句（selection statement）；\n\n 5.  * if.. else: if\n     * switch ... case ...\n     * if consteval\n\n 6.  循环语句（iteration statement）；\n\n 7.  * while\n     * do-while\n     * for …\n     * for–range-for (c++11)\n\n 8.  跳转语句（jump statement）；\n\n 9.  * break\n     * continue\n     * return …\n     * return\n     * goto\n     * continue – break – goto – return\n\n 10. 声明语句（declaration statement）；\n\n 11. try 块: try … catch …\n\n 12. atomic 与 synchronized 块(tm ts)。 atomic 与 synchronized 块用来实现事务性内存。 synchronized and atomic (tm ts)\n\nsynchronized 复合语句      (1)   (tm ts)\natomic_noexcept 复合语句   (2)   (tm ts)\natomic_cancel 复合语句     (3)   (tm ts)\natomic_commit 复合语句     (4)   (tm ts)\n\n(1) synchronized 块，与所有 synchronized 块在一个全序中执行； (2) 在发生异常时中止的 atomic 块； (3) 在发生异常时回滚的 atomic 块；\n\n\n# c++ 11 新增关键字\n\n * lignas (c++11 起)\n * alignof (c++11 起)\n * char16_t (c++11 起)\n * char32_t (c++11 起)\n * constexpr (c++11 起)\n * decltype (c++11 起)\n * noexcept (c++11 起)\n * nullptr (c++11 起)\n * static_assert (c++11 起)\n * thread_local (c++11 起)\n\n\n# c++ 17 新增关键字\n\n\n# c++ 20 新增关键字\n\n * char8_t (c++20 起)\n * concept (c++20 起)\n * consteval (c++20 起)\n * constinit (c++20 起)\n * co_await (c++20 起)\n * co_return (c++20 起)\n * co_yield (c++20 起)\n * requires (c++20 起)\n\n\n# tm_ts (transactional memory technical specification)\n\n * atomic_cancel (tm ts)\n * atomic_commit (tm ts)\n * atomic_noexcept (tm ts)\n * reflexpr (reflection ts)\n * synchronized (tm ts)\n\n\n# 特殊含义的标识符\n\n它们可用作对象或函数的名字，但在某些语境拥有特殊含义: (module 与 import 指令是预处理指令) override (c++11) final (c++11) import (c++20) module (c++20) transaction_safe (tm ts) transaction_safe_dynamic (tm ts)\n\n\n# c++ websites for reference\n\n * c++ 标准基金会的官方网站: https://isocpp.org/\n   \n\n * http://www.cplusplus.com/\n   \n\n * https://en.cppreference.com/ 或者中文版 https://zh.cppreference.com/, 一些专用名词可以方便对照;\n   \n\n * c++ 标准委员会的文档列表: https://open-std.org/jtc1/sc22/wg21/docs/papers/\n   \n\n * 一些常用的额标准, 包括posix, c, c++: https://open-std.org/\n   ',charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"class vs. typename",frontmatter:{title:"class vs. typename",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/2b0a8f/"},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/03.typename%20vs%20class.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/03.typename vs class.md",key:"v-16253573",path:"/pages/2b0a8f/",headers:[{level:2,title:"1.  共同点",slug:"_1-共同点",normalizedTitle:"1.  共同点",charIndex:null},{level:2,title:"2.   typename 独有的功能",slug:"_2-typename-独有的功能",normalizedTitle:"2.   typename 独有的功能",charIndex:null},{level:2,title:"3. class 独有的功能",slug:"_3-class-独有的功能",normalizedTitle:"3. class 独有的功能",charIndex:1382}],excerpt:"<p>在class template/function template 的声明中， 既可以使用class也可以使用typename来对类型T进行表示， 所以他们有什么区别呢？</p>\n",headersStr:"1.  共同点 2.   typename 独有的功能 3. class 独有的功能",content:"在class template/function template 的声明中， 既可以使用class也可以使用typename来对类型T进行表示， 所以他们有什么区别呢？\n\n\n# 1. 共同点\n\n在定义类模板或者函数模板时，typename 和 class 关键字都可以用于指定模板参数中的类型。也就是说，以下两种用法是完全等价的。这在大多数文章中都有提到。\n\ntemplate<typename T> /* class or function declaration */;\ntemplate<class T>  /* class or function declaration */;\n\n\n1\n2\n\n\nStan Lippman曾在其博客中表示，最早 Stroustrup 使用 class 来声明模板参数列表中的类型是为了避免增加不必要的关键字；后来标准委员会认为这样混用可能造成概念上的混淆才加上了 typename 关键字。\n\n\n# 2. typename 独有的功能\n\n由于 C++ 允许在类内定义类型别名，且其使用方法与通过类型名访问类成员的方法相同。故而，在类定义不可知的时候，编译器无法知晓类似 Type::foo 的写法具体指的是一个类型还是类内成员。这种情况下变量的类型发生了嵌套依赖类型(nested depended name)\n\n在下面的两段代码中，类模板 Bar 的原意是使用类 Foo 实例化，而后引用其中的 bar_type 定义名为 bar 的类内成员。然而，就 T::bar_type 而言，编译器在编译期无法确定它究竟是不是一个类型。此时就需要 typename 关键字来辅助编译器的判断。typename 的作用就是告诉 c++ 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有 typename，编译器没有任何办法知道 T::LengthType 是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。\n\nEXP 1:\n\nclass Foo {\n public:\n typedef int bar_type;\n};\n \ntemplate<typename T>\nclass Bar {\n T::bar_type bar; // Wrong !\n typename T::bar_type bar; // Right !\n}; \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nEXP 2：\n\nclass MyArray { \n    public：\n    typedef int LengthType;\n    ...\n}\n\ntemplate<class T>\nvoid MyMethod( T myarr ) { \n    typedef typename T::LengthType LengthType; \n    LengthType length = myarr.GetLength; \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这是常规的情形， <u>要注意的是，对于在编译期能够判断类型的场景，例如在上面例子中直接使用 Foo::bar_type 时，使用冗余的 typename 却会报错。</u>\n\n\n# 3. class 独有的功能\n\nclass 关键字最众所周知的功能是声明或定义一个类。这当然是其相对 typename 的一个独有功能。为了完整性，这里也列出。除此之外，在模板的使用中，class 关键字也有其特有的功能。而这是绝大多数文章不会提及的。\n\nC++ 的标准模板库中有名为 std::stack 的容器适配器，它能适配许多容器作为底层，实现栈的功能。其声明为\n\ntemplate <typename T, typename Containter = std::deque<T> >\nclass stack;\n\n\n1\n2\n\n\n因此，在使用中，我们可以使用 std::stack<int> 来声明一个以 std::deque<int> 保存整型变量的栈；也可以使用 std::stack<int, std::vector<int> > 来声明一个以 std::vector<int> 保存整型变量的栈。\n\n是否有可能以类似 Stack<int, std::vector> 的形式，来达到同样的目的？\n\n所以我们需要有类似这样的声明：\n\ntemplate <typename T,\n  template <typename E, typename = std::allocater<E> > class Container = std::deque>\nclass Stack;\n\n\n1\n2\n3\n\n\n由于 Container 必须是一个容器类模板，所以，如果不适用具体的模板参数实例化，就必须将其声明为一个类模板。故此，Container 之前需要保留标准库中容器类模板的模板参数。注意此处使用了标准库提供的内存分配器。\n\n此处 class 特有的功能，体现在 class Container 之处。此处虽然是在声明 Stack 这个类模板，但是这里的 class 不能替换为 typename；否则编译器会报错。\n\n不过，在 C++17标准中，这样的情况也允许使用 typename 了。参见此处。",normalizedContent:"在class template/function template 的声明中， 既可以使用class也可以使用typename来对类型t进行表示， 所以他们有什么区别呢？\n\n\n# 1. 共同点\n\n在定义类模板或者函数模板时，typename 和 class 关键字都可以用于指定模板参数中的类型。也就是说，以下两种用法是完全等价的。这在大多数文章中都有提到。\n\ntemplate<typename t> /* class or function declaration */;\ntemplate<class t>  /* class or function declaration */;\n\n\n1\n2\n\n\nstan lippman曾在其博客中表示，最早 stroustrup 使用 class 来声明模板参数列表中的类型是为了避免增加不必要的关键字；后来标准委员会认为这样混用可能造成概念上的混淆才加上了 typename 关键字。\n\n\n# 2. typename 独有的功能\n\n由于 c++ 允许在类内定义类型别名，且其使用方法与通过类型名访问类成员的方法相同。故而，在类定义不可知的时候，编译器无法知晓类似 type::foo 的写法具体指的是一个类型还是类内成员。这种情况下变量的类型发生了嵌套依赖类型(nested depended name)\n\n在下面的两段代码中，类模板 bar 的原意是使用类 foo 实例化，而后引用其中的 bar_type 定义名为 bar 的类内成员。然而，就 t::bar_type 而言，编译器在编译期无法确定它究竟是不是一个类型。此时就需要 typename 关键字来辅助编译器的判断。typename 的作用就是告诉 c++ 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有 typename，编译器没有任何办法知道 t::lengthtype 是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。\n\nexp 1:\n\nclass foo {\n public:\n typedef int bar_type;\n};\n \ntemplate<typename t>\nclass bar {\n t::bar_type bar; // wrong !\n typename t::bar_type bar; // right !\n}; \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nexp 2：\n\nclass myarray { \n    public：\n    typedef int lengthtype;\n    ...\n}\n\ntemplate<class t>\nvoid mymethod( t myarr ) { \n    typedef typename t::lengthtype lengthtype; \n    lengthtype length = myarr.getlength; \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这是常规的情形， <u>要注意的是，对于在编译期能够判断类型的场景，例如在上面例子中直接使用 foo::bar_type 时，使用冗余的 typename 却会报错。</u>\n\n\n# 3. class 独有的功能\n\nclass 关键字最众所周知的功能是声明或定义一个类。这当然是其相对 typename 的一个独有功能。为了完整性，这里也列出。除此之外，在模板的使用中，class 关键字也有其特有的功能。而这是绝大多数文章不会提及的。\n\nc++ 的标准模板库中有名为 std::stack 的容器适配器，它能适配许多容器作为底层，实现栈的功能。其声明为\n\ntemplate <typename t, typename containter = std::deque<t> >\nclass stack;\n\n\n1\n2\n\n\n因此，在使用中，我们可以使用 std::stack<int> 来声明一个以 std::deque<int> 保存整型变量的栈；也可以使用 std::stack<int, std::vector<int> > 来声明一个以 std::vector<int> 保存整型变量的栈。\n\n是否有可能以类似 stack<int, std::vector> 的形式，来达到同样的目的？\n\n所以我们需要有类似这样的声明：\n\ntemplate <typename t,\n  template <typename e, typename = std::allocater<e> > class container = std::deque>\nclass stack;\n\n\n1\n2\n3\n\n\n由于 container 必须是一个容器类模板，所以，如果不适用具体的模板参数实例化，就必须将其声明为一个类模板。故此，container 之前需要保留标准库中容器类模板的模板参数。注意此处使用了标准库提供的内存分配器。\n\n此处 class 特有的功能，体现在 class container 之处。此处虽然是在声明 stack 这个类模板，但是这里的 class 不能替换为 typename；否则编译器会报错。\n\n不过，在 c++17标准中，这样的情况也允许使用 typename 了。参见此处。",charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"typedef",frontmatter:{title:"typedef",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/ab4daf/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/02.typedef.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/02.typedef.md",key:"v-602d1c42",path:"/pages/ab4daf/",headers:[{level:2,title:"定义一种类型的别名",slug:"定义一种类型的别名",normalizedTitle:"定义一种类型的别名",charIndex:74},{level:3,title:"typedef 定义基础类型，int，  long",slug:"typedef-定义基础类型-int-long",normalizedTitle:"typedef 定义基础类型，int，  long",charIndex:null},{level:3,title:"typedef 定义复合类型，如指针和数组。",slug:"typedef-定义复合类型-如指针和数组。",normalizedTitle:"typedef 定义复合类型，如指针和数组。",charIndex:411},{level:3,title:"typedef定义struct类型",slug:"typedef定义struct类型",normalizedTitle:"typedef定义struct类型",charIndex:1163},{level:3,title:"typedef 有const的情况",slug:"typedef-有const的情况",normalizedTitle:"typedef 有const的情况",charIndex:1924},{level:3,title:"typedef 与 #define的区别",slug:"typedef-与-define的区别",normalizedTitle:"typedef 与 #define的区别",charIndex:2485},{level:2,title:"简化复杂的声明",slug:"简化复杂的声明",normalizedTitle:"简化复杂的声明",charIndex:2950},{level:2,title:"跨平台类型定义",slug:"跨平台类型定义",normalizedTitle:"跨平台类型定义",charIndex:4951},{level:2,title:"注意事项：",slug:"注意事项",normalizedTitle:"注意事项：",charIndex:5310},{level:3,title:"typedef是一个存储类的关键字",slug:"typedef是一个存储类的关键字",normalizedTitle:"typedef是一个存储类的关键字",charIndex:5320}],excerpt:"<p>一些大程序里面， 很多时候上来先用typedef定义了很多struct， enum或者union类型， 我们先看看typedef这个关键字</p>\n",headersStr:"定义一种类型的别名 typedef 定义基础类型，int，  long typedef 定义复合类型，如指针和数组。 typedef定义struct类型 typedef 有const的情况 typedef 与 #define的区别 简化复杂的声明 跨平台类型定义 注意事项： typedef是一个存储类的关键字",content:'一些大程序里面， 很多时候上来先用typedef定义了很多struct， enum或者union类型， 我们先看看typedef这个关键字\n\n\n# 定义一种类型的别名\n\n\n# typedef 定义基础类型，int， long\n\ntypedef 使用最多的地方是创建易于记忆的类型名，例如：\n\ntypedef int size;\ntypedef long byte_4;  // 给已知数据类型long起个新名字，叫byte_4。 \nvoid measure(size * psz); \nsize array[4];\nsize len = file.getlength();\nstd::vector<size> vs; \n\n\n1\n2\n3\n4\n5\n6\n\n\n这里定义了一个 int 的同义字，名为 size， typedef 并不创建新的类型。它仅为现有类型添加一个同义字。你可以在需要 int 的地方使用 size：\n\n\n# typedef 定义复合类型，如指针和数组。\n\n例如，像下面这样重复定义有 81 个字符元素的数组：\n\nchar line[81];\nchar text[81];\n\n\n1\n2\n\n\n可以使用typedef定义相同类型和大小的数组，可以这样：\n\ntypedef char Line[81]; \nLine text, secondline;\ngetline(text);\n\n\n1\n2\n3\n\n\n也可以用typedef定义一个指针类型：\n\nchar* pa, pb;         // 这是不对的，它只声明了一个指向字符变量的指针, 和一个字符变量；\ntypedef char * pstr;  // 可以这样\npstr pa, pb;\nint mystrcmp(pstr, pstr);\n\n\n1\n2\n3\n4\n\n\n但是这里也有一些陷阱。标准函数 strcmp()有两个‘const char *’类型的参数。因此，它可能会误导我们象下面这样声明 mystrcmp()：\n\nint mystrcmp(const pstr, const pstr); \n\n\n1\n\n\n这是错误的，按照顺序，‘const pstr’被解释为‘char * const’（一个指向 char 的常量指针），而不是‘const char *’（指向常量 char 的指针）。这个问题很容易解决：\n\ntypedef const char * cpstr; \nint mystrcmp(cpstr, cpstr); // 现在是正确的\n\n\n1\n2\n\n\n记住： 不管什么时候，只要为指针声明 typedef，那么都要在 typedef 名称中加一个 const，以使得该指针所指数据为常量量（常量指针），而指针本身为常量（指针常量）。\n\n\n# typedef定义struct类型\n\ntypedef struct tagMyStruct \n{ \n    int iNum; \n    long lLength; \n} MyStruct; \n\n\n1\n2\n3\n4\n5\n\n\n这语句实际上完成以下两个操作：\n\n1）定义一个新的struct\n\nstruct tagMyStruct \n{ \n    int iNum; \n    long lLength; \n}; \n\n\n1\n2\n3\n4\n5\n\n\n分析：tagMyStruct称为“tag”，即“标签”，实际上是一个临时名字，struct 关键字和tagMyStruct一起，构成了这个结构类型，不论是否有typedef，这个结构都存在。\n\n我们可以用struct tagMyStruct varName来定义变量，但要注意，使用tagMyStruct varName来定义变量是不对的，因为struct 和tagMyStruct合在一起才能表示一个结构类型。\n\n2）typedef为这个新的结构起了一个名字，叫MyStruct。\n\ntypedef struct tagMyStruct MyStruct; \n\n\n1\n\n\n因此，MyStruct实际上相当于struct tagMyStruct，我们可以使用MyStruct varName来定义变量。\n\n3）规范做法：\n\nstruct tagNode \n{ \n    char *pItem; \n    struct tagNode *pNext; \n}; \ntypedef struct tagNode *pNode; \n\n\n1\n2\n3\n4\n5\n6\n\n\n除了对struct， 在一些代码中经常看到对enum， union来进行typedef， 来形成整个程序的类型系统。\n\n\n# typedef 有const的情况\n\ntypedef char* PSTR;\nint mystrcmp(const PSTR, const PSTR);\n\n\n1\n2\n\n\nconst PSTR实际上相当于const char吗？不是的，它实际上相当于char const。\n\n原因在于const给予了整个指针本身以常量性，也就是形成了常量指针char* const。\n\n简单来说，当const和typedef一起出现时，typedef不再是简单的字符串替换。\n\n下面的代码中编译器会报一个错误\n\ntypedef char * pStr; \nchar string[4] = "abc"; \nconst char *p1 = string; \nconst pStr p2 = string; \np1++; \np2++;  // error!  const pStr p2并不等于const char * p2。\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中const pStr p2和const long x本质上没有区别，都是对变量进行只读限制，只不过此处变量p2的数据类型是我们自己定义的而不是系统固有类型而已。const pStr p2的真正含义是：限定数据类型为char *的变量p2为只读，因此p2++错误。\n\n\n# typedef 与 #define的区别\n\nchar* pa, pb;         // 这是不对的，它只声明了一个指向字符变量的指针, 和一个字符变量；\n// #define char* pstr // 如果是这样则是不对的， 因为#define只是等价替换祖父穿， 对于第二个pb则仍然为char类型\ntypedef char * pstr;  // 可以这样\npstr pa, pb;\nint mystrcmp(pstr, pstr);\n\n\n1\n2\n3\n4\n5\n\n\n#define只是在预处理的时候进行简单的字符串替换， typedef是重新在整个程序中定义一个新的类型\n\n不仅仅如此：\n\n 1. #define宏定义有一个特别的长处：可以使用 #ifdef ,#ifndef等来进行逻辑判断，还可以使用#undef来取消定义。\n 2. typedef也有一个特别的长处：它符合范围规则，使用typedef定义的变量类型其作用范围限制在所定义的函数或者文件内（取决于此变量定义的位置），而宏定义则没有这种特性。\n\n\n# 简化复杂的声明\n\n在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例：\n\n 1. 原声明：\n\nint *(*a[5])(int, char*);  // 含有5个函数指针组成的数组\n\n\n1\n\n\n变量名为a，也可以直接用一个新别名 pFun 替换a就可以了：\n\ntypedef int *(*pFun)(int, char*); \npFun a[5]; //  原声明使用pFun表示\n\n\n1\n2\n\n 2. 原声明：\n\nvoid (*b[10]) (void (*)());\n\n\n1\n\n\n变量名为b，先替换右边部分括号里的，pFunParam为别名一：\n\ntypedef void (*pFunParam)();\n\n\n1\n\n\n再替换左边的变量b，pFunx为别名二：\n\n typedef void (*pFunx)(pFunParam);\n\n\n1\n\n\n原声明的最简化版：\n\npFunx b[10];\n\n\n1\n\n 3. 原声明：\n\ndoube(*)() (*e)[9]; \n\n\n1\n\n\n变量名为e，先替换左边部分，pFuny为别名一：\n\ntypedef double(*pFuny)();\n\n\n1\n\n\n再替换右边的变量e，pFunParamy为别名二\n\ntypedef pFuny (*pFunParamy)[9];\n\n\n1\n\n\n原声明的最简化版：\n\npFunParamy e;\n\n\n1\n\n 4. 原声明：\n\n   double(* (*pa)[9] )();      // 此蓝色部分为个人理解，未找到原文出处 \n\n　typedef double(*pFun)();        //首先为上面表达式蓝色部分声明一个新类型 \n　typedef pFun (*pFunParam)[9];  //整体声明一个新类型 \n　pFunParam pa;       //使用定义的新类型来声明对象，等价于double(*(*pa)[9])(); \n\n\n1\n2\n3\n4\n5\n\n\n理解复杂声明可用的“右左法则”：\n\n从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：\n\nint (*func)(int *p);\n\n\n1\n\n\n首先找到变量名func，外面有一对圆括号，而且左边是一个*号，*这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明 (func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有int类型的形参，返回值类型是int。\n\nint (*func[5])(int *);\n\n\n1\n\n\nfunc 右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的不是修饰func，而是修饰 func[5]的，原因是[]运算符优先级比高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指 针，它指向的函数具有int*类型的形参，返回值类型为int。\n\n也可以归纳为2个固定的模式：\n\ntype (*)(....) //函数指针 \ntype (*)[]     //数组指针\n\n\n1\n2\n\n\n上面讨论的 typedef 行为有点像 #define 宏，用其实际类型替代同义字。不同点是 typedef 在编译时被解释，因此让编译器来应付超越预处理器能力的文本替换。例如：\n\ntypedef int (*PF) (const char *, const char *);\n\n\n1\n\n\n这个声明引入了 PF 类型作为函数指针的同义字，该函数有两个 const char * 类型的参数以及一个 int 类型的返回值。如果要使用下列形式的函数声明，那么上述这个 typedef 是不可或缺的：\n\nPF Register(PF pf);\n\n\n1\n\n\nRegister() 的参数是一个 PF 类型的回调函数，返回某个函数的地址，其署名与先前注册的名字相同。做一次深呼吸。下面我展示一下如果不用 typedef，我们是如何实现这个声明的：\n\nint (*Register (int (*pf)(const char *, const char *))) (const char *, const char *); \n\n\n1\n\n\n很少有程序员理解它是什么意思，更不用说这种费解的代码所带来的出错风险了。显然，这里使用 typedef 不是一种特权，而是一种必需。持怀疑态度的人可能会问：“OK，有人还会写这样的代码吗？”，快速浏览一下揭示 signal()函数的头文件 ，一个有同样接口的函数。\n\n\n# 跨平台类型定义\n\n定义一个叫 REAL 的浮点类型，为：\n\ntypedef long double REAL;  // 在目标平台一上，让它表示最高精度的类型\ntypedef double REAL; \t   // 在不支持 long double 的平台二上\ntypedef float REAL;  \t   // 在连 double 都不支持的平台三上，可以这样定义\n\n\n1\n2\n3\n\n\n当在不同的平台时，只要修改 typedef 本身就行，不用对代码其他部分作修改。这个微小的变动可以通过条件编译来自动实现。\n\n标准库广泛使用了这个技巧，比如size_t。\n\n此外，因为typedef是定义了一种类型的别名，不是简单的字符串替换（#define），所以它比宏更稳健（虽然用宏有时也可以完成以上的用途）。\n\n\n# 注意事项：\n\n\n# typedef是一个存储类的关键字\n\n同auto、extern、mutable、static、register等一样，他们在语法上是一个存储类的关键字， 虽然它并不真正影响对象的存储特性，如：\n\ntypedef static int INT2;  // error\ntypedef register int FAST_COUNTER; // error\n\n\n1\n2\n\n\n编译将失败，会提示“指定了一个以上的存储类”。。因为符号 typedef 已经占据了存储类关键字的位置，在 typedef 声明中不能用 register（或任何其它存储类关键字）。s\n\nExtra Reference： Using typedef to Curb Miscreant Code [使用 typedef 抑制劣质代码]',normalizedContent:'一些大程序里面， 很多时候上来先用typedef定义了很多struct， enum或者union类型， 我们先看看typedef这个关键字\n\n\n# 定义一种类型的别名\n\n\n# typedef 定义基础类型，int， long\n\ntypedef 使用最多的地方是创建易于记忆的类型名，例如：\n\ntypedef int size;\ntypedef long byte_4;  // 给已知数据类型long起个新名字，叫byte_4。 \nvoid measure(size * psz); \nsize array[4];\nsize len = file.getlength();\nstd::vector<size> vs; \n\n\n1\n2\n3\n4\n5\n6\n\n\n这里定义了一个 int 的同义字，名为 size， typedef 并不创建新的类型。它仅为现有类型添加一个同义字。你可以在需要 int 的地方使用 size：\n\n\n# typedef 定义复合类型，如指针和数组。\n\n例如，像下面这样重复定义有 81 个字符元素的数组：\n\nchar line[81];\nchar text[81];\n\n\n1\n2\n\n\n可以使用typedef定义相同类型和大小的数组，可以这样：\n\ntypedef char line[81]; \nline text, secondline;\ngetline(text);\n\n\n1\n2\n3\n\n\n也可以用typedef定义一个指针类型：\n\nchar* pa, pb;         // 这是不对的，它只声明了一个指向字符变量的指针, 和一个字符变量；\ntypedef char * pstr;  // 可以这样\npstr pa, pb;\nint mystrcmp(pstr, pstr);\n\n\n1\n2\n3\n4\n\n\n但是这里也有一些陷阱。标准函数 strcmp()有两个‘const char *’类型的参数。因此，它可能会误导我们象下面这样声明 mystrcmp()：\n\nint mystrcmp(const pstr, const pstr); \n\n\n1\n\n\n这是错误的，按照顺序，‘const pstr’被解释为‘char * const’（一个指向 char 的常量指针），而不是‘const char *’（指向常量 char 的指针）。这个问题很容易解决：\n\ntypedef const char * cpstr; \nint mystrcmp(cpstr, cpstr); // 现在是正确的\n\n\n1\n2\n\n\n记住： 不管什么时候，只要为指针声明 typedef，那么都要在 typedef 名称中加一个 const，以使得该指针所指数据为常量量（常量指针），而指针本身为常量（指针常量）。\n\n\n# typedef定义struct类型\n\ntypedef struct tagmystruct \n{ \n    int inum; \n    long llength; \n} mystruct; \n\n\n1\n2\n3\n4\n5\n\n\n这语句实际上完成以下两个操作：\n\n1）定义一个新的struct\n\nstruct tagmystruct \n{ \n    int inum; \n    long llength; \n}; \n\n\n1\n2\n3\n4\n5\n\n\n分析：tagmystruct称为“tag”，即“标签”，实际上是一个临时名字，struct 关键字和tagmystruct一起，构成了这个结构类型，不论是否有typedef，这个结构都存在。\n\n我们可以用struct tagmystruct varname来定义变量，但要注意，使用tagmystruct varname来定义变量是不对的，因为struct 和tagmystruct合在一起才能表示一个结构类型。\n\n2）typedef为这个新的结构起了一个名字，叫mystruct。\n\ntypedef struct tagmystruct mystruct; \n\n\n1\n\n\n因此，mystruct实际上相当于struct tagmystruct，我们可以使用mystruct varname来定义变量。\n\n3）规范做法：\n\nstruct tagnode \n{ \n    char *pitem; \n    struct tagnode *pnext; \n}; \ntypedef struct tagnode *pnode; \n\n\n1\n2\n3\n4\n5\n6\n\n\n除了对struct， 在一些代码中经常看到对enum， union来进行typedef， 来形成整个程序的类型系统。\n\n\n# typedef 有const的情况\n\ntypedef char* pstr;\nint mystrcmp(const pstr, const pstr);\n\n\n1\n2\n\n\nconst pstr实际上相当于const char吗？不是的，它实际上相当于char const。\n\n原因在于const给予了整个指针本身以常量性，也就是形成了常量指针char* const。\n\n简单来说，当const和typedef一起出现时，typedef不再是简单的字符串替换。\n\n下面的代码中编译器会报一个错误\n\ntypedef char * pstr; \nchar string[4] = "abc"; \nconst char *p1 = string; \nconst pstr p2 = string; \np1++; \np2++;  // error!  const pstr p2并不等于const char * p2。\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中const pstr p2和const long x本质上没有区别，都是对变量进行只读限制，只不过此处变量p2的数据类型是我们自己定义的而不是系统固有类型而已。const pstr p2的真正含义是：限定数据类型为char *的变量p2为只读，因此p2++错误。\n\n\n# typedef 与 #define的区别\n\nchar* pa, pb;         // 这是不对的，它只声明了一个指向字符变量的指针, 和一个字符变量；\n// #define char* pstr // 如果是这样则是不对的， 因为#define只是等价替换祖父穿， 对于第二个pb则仍然为char类型\ntypedef char * pstr;  // 可以这样\npstr pa, pb;\nint mystrcmp(pstr, pstr);\n\n\n1\n2\n3\n4\n5\n\n\n#define只是在预处理的时候进行简单的字符串替换， typedef是重新在整个程序中定义一个新的类型\n\n不仅仅如此：\n\n 1. #define宏定义有一个特别的长处：可以使用 #ifdef ,#ifndef等来进行逻辑判断，还可以使用#undef来取消定义。\n 2. typedef也有一个特别的长处：它符合范围规则，使用typedef定义的变量类型其作用范围限制在所定义的函数或者文件内（取决于此变量定义的位置），而宏定义则没有这种特性。\n\n\n# 简化复杂的声明\n\n在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例：\n\n 1. 原声明：\n\nint *(*a[5])(int, char*);  // 含有5个函数指针组成的数组\n\n\n1\n\n\n变量名为a，也可以直接用一个新别名 pfun 替换a就可以了：\n\ntypedef int *(*pfun)(int, char*); \npfun a[5]; //  原声明使用pfun表示\n\n\n1\n2\n\n 2. 原声明：\n\nvoid (*b[10]) (void (*)());\n\n\n1\n\n\n变量名为b，先替换右边部分括号里的，pfunparam为别名一：\n\ntypedef void (*pfunparam)();\n\n\n1\n\n\n再替换左边的变量b，pfunx为别名二：\n\n typedef void (*pfunx)(pfunparam);\n\n\n1\n\n\n原声明的最简化版：\n\npfunx b[10];\n\n\n1\n\n 3. 原声明：\n\ndoube(*)() (*e)[9]; \n\n\n1\n\n\n变量名为e，先替换左边部分，pfuny为别名一：\n\ntypedef double(*pfuny)();\n\n\n1\n\n\n再替换右边的变量e，pfunparamy为别名二\n\ntypedef pfuny (*pfunparamy)[9];\n\n\n1\n\n\n原声明的最简化版：\n\npfunparamy e;\n\n\n1\n\n 4. 原声明：\n\n   double(* (*pa)[9] )();      // 此蓝色部分为个人理解，未找到原文出处 \n\n　typedef double(*pfun)();        //首先为上面表达式蓝色部分声明一个新类型 \n　typedef pfun (*pfunparam)[9];  //整体声明一个新类型 \n　pfunparam pa;       //使用定义的新类型来声明对象，等价于double(*(*pa)[9])(); \n\n\n1\n2\n3\n4\n5\n\n\n理解复杂声明可用的“右左法则”：\n\n从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：\n\nint (*func)(int *p);\n\n\n1\n\n\n首先找到变量名func，外面有一对圆括号，而且左边是一个*号，*这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明 (func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有int类型的形参，返回值类型是int。\n\nint (*func[5])(int *);\n\n\n1\n\n\nfunc 右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的不是修饰func，而是修饰 func[5]的，原因是[]运算符优先级比高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指 针，它指向的函数具有int*类型的形参，返回值类型为int。\n\n也可以归纳为2个固定的模式：\n\ntype (*)(....) //函数指针 \ntype (*)[]     //数组指针\n\n\n1\n2\n\n\n上面讨论的 typedef 行为有点像 #define 宏，用其实际类型替代同义字。不同点是 typedef 在编译时被解释，因此让编译器来应付超越预处理器能力的文本替换。例如：\n\ntypedef int (*pf) (const char *, const char *);\n\n\n1\n\n\n这个声明引入了 pf 类型作为函数指针的同义字，该函数有两个 const char * 类型的参数以及一个 int 类型的返回值。如果要使用下列形式的函数声明，那么上述这个 typedef 是不可或缺的：\n\npf register(pf pf);\n\n\n1\n\n\nregister() 的参数是一个 pf 类型的回调函数，返回某个函数的地址，其署名与先前注册的名字相同。做一次深呼吸。下面我展示一下如果不用 typedef，我们是如何实现这个声明的：\n\nint (*register (int (*pf)(const char *, const char *))) (const char *, const char *); \n\n\n1\n\n\n很少有程序员理解它是什么意思，更不用说这种费解的代码所带来的出错风险了。显然，这里使用 typedef 不是一种特权，而是一种必需。持怀疑态度的人可能会问：“ok，有人还会写这样的代码吗？”，快速浏览一下揭示 signal()函数的头文件 ，一个有同样接口的函数。\n\n\n# 跨平台类型定义\n\n定义一个叫 real 的浮点类型，为：\n\ntypedef long double real;  // 在目标平台一上，让它表示最高精度的类型\ntypedef double real; \t   // 在不支持 long double 的平台二上\ntypedef float real;  \t   // 在连 double 都不支持的平台三上，可以这样定义\n\n\n1\n2\n3\n\n\n当在不同的平台时，只要修改 typedef 本身就行，不用对代码其他部分作修改。这个微小的变动可以通过条件编译来自动实现。\n\n标准库广泛使用了这个技巧，比如size_t。\n\n此外，因为typedef是定义了一种类型的别名，不是简单的字符串替换（#define），所以它比宏更稳健（虽然用宏有时也可以完成以上的用途）。\n\n\n# 注意事项：\n\n\n# typedef是一个存储类的关键字\n\n同auto、extern、mutable、static、register等一样，他们在语法上是一个存储类的关键字， 虽然它并不真正影响对象的存储特性，如：\n\ntypedef static int int2;  // error\ntypedef register int fast_counter; // error\n\n\n1\n2\n\n\n编译将失败，会提示“指定了一个以上的存储类”。。因为符号 typedef 已经占据了存储类关键字的位置，在 typedef 声明中不能用 register（或任何其它存储类关键字）。s\n\nextra reference： using typedef to curb miscreant code [使用 typedef 抑制劣质代码]',charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"const",frontmatter:{title:"const",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/b9de04/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/04.const.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/04.const.md",key:"v-52de352b",path:"/pages/b9de04/",headers:[{level:2,title:"const修饰一般变量",slug:"const修饰一般变量",normalizedTitle:"const修饰一般变量",charIndex:20},{level:2,title:"const修饰指针",slug:"const修饰指针",normalizedTitle:"const修饰指针",charIndex:570},{level:2,title:"const修饰引用",slug:"const修饰引用",normalizedTitle:"const修饰引用",charIndex:949},{level:2,title:"const修饰函数参数",slug:"const修饰函数参数",normalizedTitle:"const修饰函数参数",charIndex:1228},{level:2,title:"const修饰函数返回值",slug:"const修饰函数返回值",normalizedTitle:"const修饰函数返回值",charIndex:1548},{level:2,title:"const修饰类成员变量",slug:"const修饰类成员变量",normalizedTitle:"const修饰类成员变量",charIndex:2439},{level:2,title:"const修饰类成员函数",slug:"const修饰类成员函数",normalizedTitle:"const修饰类成员函数",charIndex:2713},{level:2,title:"const修饰类常量对象",slug:"const修饰类常量对象",normalizedTitle:"const修饰类常量对象",charIndex:3999},{level:2,title:"const和#define的区别",slug:"const和-define的区别",normalizedTitle:"const和#define的区别",charIndex:4413},{level:2,title:"使用const的一些建议",slug:"使用const的一些建议",normalizedTitle:"使用const的一些建议",charIndex:4663}],excerpt:"<p>一些const关键字常见的情况</p>\n",headersStr:"const修饰一般变量 const修饰指针 const修饰引用 const修饰函数参数 const修饰函数返回值 const修饰类成员变量 const修饰类成员函数 const修饰类常量对象 const和#define的区别 使用const的一些建议",content:'一些const关键字常见的情况\n\n\n# const修饰一般变量\n\nconst int a = 7; \nint b = a; // 正确\na = 8;    // 错误，不能改\n\n\n1\n2\n3\n\n\n即使用指针修改也是不可以的：\n\n#include<iostream>\nusing namespace std; \nint main(void)\n{\n    const int  a = 7;\n    int  *p = (int*)&a;\n    *p = 8;\n    cout<<a;  // 这里仍然输出a=7\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果需要修改， 可以通过用volatile来修饰const，\n\n#include<iostream>\nusing namespace std;\nint main(void)\n{\n    volatile const int  a = 7;\n    int  *p = (int*)&a;\n    *p = 8;\n    cout<<a; // 这里输出a=8\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# const修饰指针\n\nConst 在指针的不同位置， 代表的含义也不一样， C++ primer里面会分为顶层const和底层const， 顶层const指指针本身是个const， 底层const指指针所指的对象是个const：\n\nint* const x  = &y；                 //顶层const: const指针 --\x3e 指针指向的地址不能做修改\nconst int* x = &y；                  //底层const: const对象 --\x3e 变量的指向内容不能做修改, \n    \t\t\t\t\t\t\t  \t// y为一个const变量， 或者一个常规变量提升为一个const变量\nconst int* const x  = &y；           //Both两者都不能做修改\n\n\n1\n2\n3\n4\n\n\n\n# const修饰引用\n\nconst引用就是指向const对象的引用，普通变量可以绑定到const 引用, 但是const变量不可以绑定到普通的引用上\n\nint var1 = 1, var2 = 2;\nint &a = 0; // 一般引用无法绑定到字面值常量\nconst int &b = 0; //const引用可以绑定字面常量值\nint &c = var1 + var2; //错误，左值引用不可绑定右值, var1+var2为右值\nconst int &d = var1 + var2; //const引用可以绑定右值\n\n\n1\n2\n3\n4\n5\n\n\n\n# const修饰函数参数\n\n传入const变量，一般这种情况不需要 const 修饰，因为函数会自动产生临时变量复制实参值。\n\n传入const指针和const引用， 可以防止传入引用或指针改变原来的实参值\n\n#include <iostream>\nusing namespace std;\n\nvoid func(const int &a){\n    int &b = a;\n    b = 10;\n}\n\nint main(){\n    int a = 0;\n    func(a);\n    cout << a << endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# const修饰函数返回值\n\nconst 修饰内置类型的返回值，修饰与不修饰返回值作用一样。\n\nconst 修饰自定义类型的作为返回值，此时**返回的值不能作为左值使用，既不能被赋值，也不能被修改。**这时候返回值为一个常量值，可以降低用户错误而造成的意外\n\n#include <iostream>\n#include <string>\nusing namespace std;\nclass A\n{\nprivate:\n    int _a;\n    string _str;\npublic:\n    A(int a, string str):_a(a), _str(str){}\n    const A operator+(const A &rhs);\n\n    friend ostream &operator<<(ostream &os, const A &a)\n    {\n        os << a._str << " : " << a._a;\n        return os;\n    }\n};\n\nconst A A::operator+(const A &rhs)\n{\n    return A(this->_a + rhs._a, this->_str + rhs._str);\n}\n\nint main(int argc, char *argv[])\n{\n    A a1(1, "a1");\n    A a2(2, "a2");\n    A a3(3, "a3");\n    cout << (a1 + a2) << endl;\n    (a1 + a2) = a3;   //错误， 但是如果去掉const，这里会有怎样的变化\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nconst 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让使用者做什么。\n\n\n# const修饰类成员变量\n\n这个const关键字在修饰成员变量时，与上文提及的使用雷同，const变量主要在初始化列表中赋值，并且不能进行修改。\n\n    class object\n    { \n        …\n        const int value;         //const变量不能被修改 （int const value也可以）\n        …\n        object (int x): value(x) { } ;  // 构造函数初始化const变量\n     } \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# const修饰类成员函数\n\nconst 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。\n\n**注意：**const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。\n\n下面的 get_cm()const; 函数用到了 const 成员函数：\n\n#include<iostream>\nusing namespace std;\nclass Test\n{\npublic:\n    Test(){}\n    Test(int _m):_cm(_m){}\n    int get_cm()const\n    {\n       return _cm;\n    }\n \nprivate:\n    int _cm;\n};\n \n \n \nvoid Cmf(const Test& _tt)\n{\n    cout<<_tt.get_cm();\n}\n \nint main(void)\n{\n    Test t(8);\n    Cmf(t);\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n如果 get_cm() 去掉 const 修饰，则 Cmf 传递的 const _tt 即使没有改变对象的值，编译器也认为函数会改变对象的值，所以尽量将所有的不需要改变对象内容的函数都作为 const 成员函数。\n\n如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用 mutable 关键字修饰这个成员，mutable 的意思也是易变的，容易改变的意思，被 mutable 关键字修饰的成员可以处于不断变化中，如下面的例子。\n\n#include<iostream>\nusing namespace std;\nclass Test\n{\npublic:\n    Test(int _m,int _t):_cm(_m),_ct(_t){}\n    void Kf()const\n    {\n        ++_cm; // 错误\n        ++_ct; // 正确\n    }\nprivate:\n    int _cm;\n    mutable int _ct;\n};\n \nint main(void)\n{\n    Test t(8,7);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这里我们在 Kf() const 中通过 ++_ct; 修改 _ct 的值，但是通过 ++_cm 修改 _cm 则会报错。因为 ++_cm 没有用 mutable 修饰。\n\n\n# const修饰类常量对象\n\n常量对象所有成员默认添加了const修饰字，也就是所有的成员变量都不能进行修改。可以认为是关闭了写权限，所以const对象只能调用const成员函数，因为非const成员函数都有修改成员变量的权限。\n\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n    A(){cout << "non-const" << endl;}\n    void test() const{cout << "const" << endl;} //把这里的const去掉看看会发生什么\n};\n\nint main(int argc, char *argv[])\n{\n    const A a1;\n    a1.test();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# const和#define的区别\n\n 1. 宏定义是在预编译阶段进行文本替换，而const是在编译阶段进行代码的语义约束。\n 2. 由于二者所生效的阶段不同，所以能够起的作用也不同。const常量具有具体的类型，会在编译阶段进行类型检查，产生的代码显然会更加安全。（当然宏定义会更加灵活，可以定义代码或字符串，相对来讲如果要进行大量的宏替换，预编译时间会更长。）\n 3. 宏定义很多时候是展开给立即数，多次替换需要多次分配内存，而const可以通过全局的符号表，仅保存一份copy就完事了。\n\n\n# 使用const的一些建议\n\n 1. 要大胆的使用const，这将给你带来无尽的益处，但前提是你必须搞清楚原委；\n\n 2. 要避免最一般的赋值操作错误，如将const变量赋值；\n\n 3. 在参数中使用const应该使用引用或指针，而不是一般的对象实例，原因同上；\n\n 4. const在成员函数中的三种用法（参数、返回值、函数）要很好的使用；\n\n 5. 不要轻易的将函数的返回值类型定为const；\n\n 6. 除了重载操作符外一般不要将返回值类型定为对某个对象的const引用；',normalizedContent:'一些const关键字常见的情况\n\n\n# const修饰一般变量\n\nconst int a = 7; \nint b = a; // 正确\na = 8;    // 错误，不能改\n\n\n1\n2\n3\n\n\n即使用指针修改也是不可以的：\n\n#include<iostream>\nusing namespace std; \nint main(void)\n{\n    const int  a = 7;\n    int  *p = (int*)&a;\n    *p = 8;\n    cout<<a;  // 这里仍然输出a=7\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果需要修改， 可以通过用volatile来修饰const，\n\n#include<iostream>\nusing namespace std;\nint main(void)\n{\n    volatile const int  a = 7;\n    int  *p = (int*)&a;\n    *p = 8;\n    cout<<a; // 这里输出a=8\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# const修饰指针\n\nconst 在指针的不同位置， 代表的含义也不一样， c++ primer里面会分为顶层const和底层const， 顶层const指指针本身是个const， 底层const指指针所指的对象是个const：\n\nint* const x  = &y；                 //顶层const: const指针 --\x3e 指针指向的地址不能做修改\nconst int* x = &y；                  //底层const: const对象 --\x3e 变量的指向内容不能做修改, \n    \t\t\t\t\t\t\t  \t// y为一个const变量， 或者一个常规变量提升为一个const变量\nconst int* const x  = &y；           //both两者都不能做修改\n\n\n1\n2\n3\n4\n\n\n\n# const修饰引用\n\nconst引用就是指向const对象的引用，普通变量可以绑定到const 引用, 但是const变量不可以绑定到普通的引用上\n\nint var1 = 1, var2 = 2;\nint &a = 0; // 一般引用无法绑定到字面值常量\nconst int &b = 0; //const引用可以绑定字面常量值\nint &c = var1 + var2; //错误，左值引用不可绑定右值, var1+var2为右值\nconst int &d = var1 + var2; //const引用可以绑定右值\n\n\n1\n2\n3\n4\n5\n\n\n\n# const修饰函数参数\n\n传入const变量，一般这种情况不需要 const 修饰，因为函数会自动产生临时变量复制实参值。\n\n传入const指针和const引用， 可以防止传入引用或指针改变原来的实参值\n\n#include <iostream>\nusing namespace std;\n\nvoid func(const int &a){\n    int &b = a;\n    b = 10;\n}\n\nint main(){\n    int a = 0;\n    func(a);\n    cout << a << endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# const修饰函数返回值\n\nconst 修饰内置类型的返回值，修饰与不修饰返回值作用一样。\n\nconst 修饰自定义类型的作为返回值，此时**返回的值不能作为左值使用，既不能被赋值，也不能被修改。**这时候返回值为一个常量值，可以降低用户错误而造成的意外\n\n#include <iostream>\n#include <string>\nusing namespace std;\nclass a\n{\nprivate:\n    int _a;\n    string _str;\npublic:\n    a(int a, string str):_a(a), _str(str){}\n    const a operator+(const a &rhs);\n\n    friend ostream &operator<<(ostream &os, const a &a)\n    {\n        os << a._str << " : " << a._a;\n        return os;\n    }\n};\n\nconst a a::operator+(const a &rhs)\n{\n    return a(this->_a + rhs._a, this->_str + rhs._str);\n}\n\nint main(int argc, char *argv[])\n{\n    a a1(1, "a1");\n    a a2(2, "a2");\n    a a3(3, "a3");\n    cout << (a1 + a2) << endl;\n    (a1 + a2) = a3;   //错误， 但是如果去掉const，这里会有怎样的变化\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nconst 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让使用者做什么。\n\n\n# const修饰类成员变量\n\n这个const关键字在修饰成员变量时，与上文提及的使用雷同，const变量主要在初始化列表中赋值，并且不能进行修改。\n\n    class object\n    { \n        …\n        const int value;         //const变量不能被修改 （int const value也可以）\n        …\n        object (int x): value(x) { } ;  // 构造函数初始化const变量\n     } \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# const修饰类成员函数\n\nconst 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。\n\n**注意：**const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。\n\n下面的 get_cm()const; 函数用到了 const 成员函数：\n\n#include<iostream>\nusing namespace std;\nclass test\n{\npublic:\n    test(){}\n    test(int _m):_cm(_m){}\n    int get_cm()const\n    {\n       return _cm;\n    }\n \nprivate:\n    int _cm;\n};\n \n \n \nvoid cmf(const test& _tt)\n{\n    cout<<_tt.get_cm();\n}\n \nint main(void)\n{\n    test t(8);\n    cmf(t);\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n如果 get_cm() 去掉 const 修饰，则 cmf 传递的 const _tt 即使没有改变对象的值，编译器也认为函数会改变对象的值，所以尽量将所有的不需要改变对象内容的函数都作为 const 成员函数。\n\n如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用 mutable 关键字修饰这个成员，mutable 的意思也是易变的，容易改变的意思，被 mutable 关键字修饰的成员可以处于不断变化中，如下面的例子。\n\n#include<iostream>\nusing namespace std;\nclass test\n{\npublic:\n    test(int _m,int _t):_cm(_m),_ct(_t){}\n    void kf()const\n    {\n        ++_cm; // 错误\n        ++_ct; // 正确\n    }\nprivate:\n    int _cm;\n    mutable int _ct;\n};\n \nint main(void)\n{\n    test t(8,7);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这里我们在 kf() const 中通过 ++_ct; 修改 _ct 的值，但是通过 ++_cm 修改 _cm 则会报错。因为 ++_cm 没有用 mutable 修饰。\n\n\n# const修饰类常量对象\n\n常量对象所有成员默认添加了const修饰字，也就是所有的成员变量都不能进行修改。可以认为是关闭了写权限，所以const对象只能调用const成员函数，因为非const成员函数都有修改成员变量的权限。\n\n#include <iostream>\nusing namespace std;\n\nclass a\n{\npublic:\n    a(){cout << "non-const" << endl;}\n    void test() const{cout << "const" << endl;} //把这里的const去掉看看会发生什么\n};\n\nint main(int argc, char *argv[])\n{\n    const a a1;\n    a1.test();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# const和#define的区别\n\n 1. 宏定义是在预编译阶段进行文本替换，而const是在编译阶段进行代码的语义约束。\n 2. 由于二者所生效的阶段不同，所以能够起的作用也不同。const常量具有具体的类型，会在编译阶段进行类型检查，产生的代码显然会更加安全。（当然宏定义会更加灵活，可以定义代码或字符串，相对来讲如果要进行大量的宏替换，预编译时间会更长。）\n 3. 宏定义很多时候是展开给立即数，多次替换需要多次分配内存，而const可以通过全局的符号表，仅保存一份copy就完事了。\n\n\n# 使用const的一些建议\n\n 1. 要大胆的使用const，这将给你带来无尽的益处，但前提是你必须搞清楚原委；\n\n 2. 要避免最一般的赋值操作错误，如将const变量赋值；\n\n 3. 在参数中使用const应该使用引用或指针，而不是一般的对象实例，原因同上；\n\n 4. const在成员函数中的三种用法（参数、返回值、函数）要很好的使用；\n\n 5. 不要轻易的将函数的返回值类型定为const；\n\n 6. 除了重载操作符外一般不要将返回值类型定为对某个对象的const引用；',charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"extern",frontmatter:{title:"extern",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/5bac8e/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/05.extern.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/05.extern.md",key:"v-6a18abfa",path:"/pages/5bac8e/",headers:[{level:2,title:"extern  +  non-const var",slug:"extern-non-const-var",normalizedTitle:"extern  +  non-const var",charIndex:null},{level:2,title:"extern +  const var",slug:"extern-const-var",normalizedTitle:"extern +  const var",charIndex:null},{level:2,title:"extern 和 static",slug:"extern-和-static",normalizedTitle:"extern 和 static",charIndex:1197},{level:2,title:'extern "C"',slug:"extern-c",normalizedTitle:"extern &quot;c&quot;",charIndex:null},{level:2,title:"一些问题：",slug:"一些问题",normalizedTitle:"一些问题：",charIndex:4372},{level:3,title:"问题(1)：extern 变量",slug:"问题-1-extern-变量",normalizedTitle:"问题(1)：extern 变量",charIndex:4382},{level:3,title:"问题(2)：单方面修改extern函数原型",slug:"问题-2-单方面修改extern函数原型",normalizedTitle:"问题(2)：单方面修改extern函数原型",charIndex:4845},{level:3,title:"问题(3)：extern “C”",slug:"问题-3-extern-c",normalizedTitle:"问题(3)：extern “c”",charIndex:5101},{level:3,title:"问题(4)：extern 非 static 函数",slug:"问题-4-extern-非-static-函数",normalizedTitle:"问题(4)：extern 非 static 函数",charIndex:5573}],excerpt:"<p>extern关键字的含义， 用法以及在编译的时候是如何进行链接的</p>\n",headersStr:'extern  +  non-const var extern +  const var extern 和 static extern "C" 一些问题： 问题(1)：extern 变量 问题(2)：单方面修改extern函数原型 问题(3)：extern “C” 问题(4)：extern 非 static 函数',content:'extern关键字的含义， 用法以及在编译的时候是如何进行链接的\n\n 1. 置于变量或者函数前: 表明该变量或者函数定义在别的文件中\n 2. 在变量或者函数之前加上extern关键字表明这是一个声明, 其定义可能在其他文件处, 注意不能对变量进行初始化或者对函数进行定义, 否则表明这是一个定义而不是声明.\n\n\n# extern + non-const var\n\n最常见的用法，当链接器在一个全局变量声明前看到extern关键字，它会尝试在其他文件中寻找这个变量的定义。这里强调全局且非常量的原因是，全局非常量的变量默认是外部链接的。\n\n//fileA.cpp\nint i = 1;     //声明并定义全局变量i\n \n//fileB.cpp\nextern int i;  //声明i，链接全局变量\n \n//fileC.cpp\nextern int i = 2;    //错误，多重定义\nint i;               //错误，这是一个定义，导致多重定义\n\nmain() {\n  extern int i;    //正确\n  int i = 5;       //正确，新的局部变量i;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# extern + const var\n\n常量全局变量默认是内部链接的，所以想要在文件间传递常量全局变量需要在定义时指明extern，如下所示：\n\n//fileA.cpp\nextern const int i = 1;    //定义\n \n//fileB.cpp                \nextern const int i;        //声明\n\n\n1\n2\n3\n4\n5\n\n * 默认情况下, const修饰的全局常量据有跟static相同的特性， const 对象仅在本文件内有效, 但是可以通过 extern 关键字来使得 const 对象在多个文件中共享. 如在.h文件中声明 extern const char g_str[]; 在.cpp中别忘了定义: const char g_str[ ] = "123456";\n\n所以当const单独使用时它就与static相同，而当与extern一起合作的时候，它的特性就跟extern的一样了\n\n所以对const没有什么可以过多的描述，只是要注意，const char* g_str = "123456" 与 const char g_str[] ="123465"是不同的， 前面那个const 修饰的是char 而不是g_str,它的g_str并不是常量，如果让char g_str遵守const的全局常量的规则，最好这么定义const char const g_str="123456". 这个话题在 const关键字中讨论\n\n\n# extern 和 static\n\n(1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.\n\n(2) static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.\n\nstatic 作用范围是内部连接的关系, 和extern有点相反.它和对象本身是分开存储的,extern也是分开存储的,但是extern可以被其他的对象用extern 引用,而static 不可以,只允许对象本身用它. 具体差别首先，static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；最后，static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它,如:\n\n(1) test1.h:\n\n#ifndef TEST1H\n#define TEST1H\nstatic char g_str[] = "123456";\nvoid fun1();\n#endif\n\n\n1\n2\n3\n4\n5\n\n\n(2) test1.cpp:\n\n#include "test1.h"\nvoid fun1() {  cout << g_str << endl; }\n\n\n1\n2\n\n\n(3) test2.cpp\n\n#include "test1.h"\nvoid fun2() {  cout << g_str << endl; }\n\n\n1\n2\n\n\n以上两个编译单元可以连接成功, 当你打开test1.obj时，你可以在它里面找到字符串"123456", 同时你也可以在test2.obj中找到它们，它们之所以可以连接成功而没有报重复定义的错误是因为虽然它们有相同的内容，但是存储的物理地址并不一样，就像是两个不同变量赋了相同的值一样，而这两个变量分别作用于它们各自的编译单元。 也许你比较较真，自己偷偷的跟踪调试上面的代码,结果你发现两个编译单元（test1,test2）的g_str的内存地址相同，于是你下结论static修饰的变量也可以作用于其他模块，但是我要告诉你，那是你的编译器在欺骗你，大多数编译器都对代码都有优化功能，以达到生成的目标程序更节省内存，执行效率更高，当编译器在连接各个编译单元的时候，它会把相同内容的内存只拷贝一份，比如上面的"123456", 位于两个编译单元中的变量都是同样的内容，那么在连接的时候它在内存中就只会存在一份了，如果你把上面的代码改成下面的样子，你马上就可以拆穿编译器的谎言:\n\ntest1.cpp:\n\n#include "test1.h"\nvoid fun1()\n{\n    g_str[0] = \'\'a\'\';\n    cout << g_str << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\ntest2.cpp:\n\n#include "test1.h"\nvoid fun2() { cout << g_str << endl; }\n\n\n1\n2\n\n\nmain function:\n\nvoid main(){\n    fun1(); // a23456\n    fun2(); // 123456\n}\n\n\n1\n2\n3\n4\n\n\n这个时候你在跟踪代码时，就会发现两个编译单元中的g_str地址并不相同，因为你在一处修改了它，所以编译器被强行的恢复内存的原貌，在内存中存在了两份拷贝给两个模块中的变量使用。正是因为static有以上的特性，所以一般定义static全局变量时，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染.\n\n\n# extern "C"\n\n 1. extern"C": 让编译器以 C 语言的命名规则来查找函数\n 2. extern“C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。因为 C++ 重载, 而 C 不重载, 函数名编译的结果都不一样, 因此如果 C++ 直接调用 C 的函数, 因为二者编译的不同, 就会失败.\n\n在C++中，当与字符串连用时，extern指明当前声明使用了其他语言的链接规范，如extern "C"，就指明使用C语言的链接规范。原因是，C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时无法找到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。C和C++对函数的处理方式是不同的.extern "C"是使C++能够调用C写作的库文件的一个手段，如果要对编译器提示使用C的方式来处理函数的话，那么就要使用extern "C"来说明。\n\n// 声明printf函数使用C链接\nextern "C" int printf(const char *fmt, ...);\n\n//声明指定的头文件内所有的东西都使用 C 链接\nextern "C" {\n    #include <stdio.h>\n}\n\n// 声明函数ShowChar和GetChar使用 C 链接\nextern "C" {\n    char ShowChar(char ch);\n    char GetChar(void);\n}\n\n// 定义函数 ShowChar 和 GetChar 使用 C 链接\nextern "C" char ShowChar(char ch) {\n    putchar(ch);\n    return ch;\n}\n\nextern "C" char GetChar(void) {\n    char ch;\n    ch = getchar();\n    return ch;\n}\n\n// 声明全局变量 errno 为C链接\nextern "C" int errno;\n\n//又比如，在程序中常见的代码段\n#ifdef __cplusplus \nextern "C" { \n   #endif \n\n/**** some declaration or so *****/ \n#ifdef __cplusplus \n} \n#endif\n\n//这里__cplusplus是cpp中的自定义宏，定义了这个宏就表明这是一段cpp的代码，也就是说，//上面的代码的含义是:如果这是一段cpp的代码，那么加入extern "C"{和}处理其中的代码。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n * extern和static是一对矛盾的修饰符, 二者不能同时修饰一个变量, 因为static表明变量的链接性是内部的, 而extern恰好相反.\n\n注意事项：\n\n * 不要把变量定义放入.h文件，这样容易导致重复定义错误\n\n * 尽量使用static关键字把变量定义限制于该源文件作用域，除非变量被设计成全局的。\n\n * 可以在头文件中声明一个变量，在用的时候包含这个头文件就声明了这个变量。\n\n\n# 一些问题：\n\n\n# 问题(1)：extern 变量\n\n在一个源文件里定义了一个数组：char a[6];\n\n在另外一个文件里用下列语句进行了声明：extern char *a；\n\n请问，这样可以吗？\n\n答案与分析：\n\n1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char *a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。\n\n2)、例子分析如下，如果a[ ] = "abcd",则外部变量a=0x61626364 (abcd的ASCII码值)，*a显然没有意义\n\na指向的空间（0x61626364）没有意义，易出现非法内存访问。\n\n3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。\n\n4)、extern用在变量声明中常常有这样一个作用，在*.*c文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在.h中并用extern来声明。\n\n\n# 问题(2)：单方面修改extern函数原型\n\n当函数提供方单方面修改函数原型时，如果使用方不知情继续沿用原来的extern申明，这样编译时编译器不会报错。但是在运行过程中，因为少了或者多了输入参数，往往会照成系统错误，这种情况应该如何解决？\n\n答案与分析：\n\n这种情况的处理没有一个很完美的方案，通常是提供方在自己的xxx_pub.h中提供对外部接口的声明，然后调用方include该头文件，从而省去extern这一步。以避免这种错误。\n\n剑有双锋，对extern的应用，不同的场合应该选择不同的做法。\n\n\n# 问题(3)：extern “C”\n\n在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？\n\n答案与分析：\n\nC++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。\n\n下面是一个典型的用法：\n\n//在.h文件的头上\n#ifdef __cplusplus\n#if __cplusplus\nextern "C"{\n#endif\n#endif /* __cplusplus */\n\n    …\n    …\n\n//.h文件结束的地方\n#ifdef __cplusplus\n#if __cplusplus\n}\n#endif\n#endif /* __cplusplus */ \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 问题(4)：extern 非 static 函数\n\n常常见extern放在函数的前面成为函数声明的一部分，那么，C语言的关键字extern在函数的声明中起什么作用？\n\n答案与分析：\n\n如果函数的声明中带有关键字extern，仅仅是暗示这个函数可能在别的源文件里定义，没有其它作用。即extern int f(); 和 int f();两个函数声明没有明显的区别\n\n当然，用处还是有的，就是在程序中取代include “*.h”来声明函数，在一些复杂的项目中，我比较习惯在所有的函数声明前添加extern修饰。关于这样做的原因和利弊可见下面的这个例子：“用extern修饰的全局变量”\n\n(1) 在test1.h中有下列声明:\n\n#ifndef TEST1H\n#define TEST1H\n\nextern char g_str[]; // 声明全局变量g_str\nvoid fun1();\n\n#endif\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n(2) 在test1.cpp中\n\n#include "test1.h"\nchar g_str[] = "123456"; // 定义全局变量g_str\nvoid fun1() { cout << g_str << endl; }\n\n\n1\n2\n3\n\n\n(3) 以上是test1模块， 它的编译和连接都可以通过,如果我们还有test2模块也想使用g_str,只需要在原文件中引用就可以了\n\n#include "test1.h"\nvoid fun2()  { cout << g_str << endl;  }\n\n\n1\n2\n\n\n以上test1和test2可以同时编译连接通过，如果你感兴趣的话可以用ultraEdit打开test1.obj,你可以在里面找到"123456"这个字符串,但是你却不能在test2.obj里面找到，这是因为g_str是整个工程的全局变量，在内存中只存在一份,test2.obj这个编译单元不需要再有一份了，不然会在连接时报告重复定义这个错误!\n\n(4) 有些人喜欢把全局变量的声明和定义放在一起，这样可以防止忘记了定义，如把上面test1.h改为\n\nextern char g_str[] = "123456"; // 这个时候相当于没有extern\n\n\n1\n\n\n然后把test1.cpp中的g_str的定义去掉,这个时候再编译连接test1和test2两个模块时，会报连接错误，这是因为你把全局变量g_str的定义放在了头文件之后，test1.cpp这个模块包含了test1.h所以定义了一次g_str,而test2.cpp也包含了test1.h所以再一次定义了g_str,这个时候连接器在连接test1和test2时发现两个g_str。如果一定要把g_str的定义放在test1.h中的话，那么就把test2的代码中#include "test1.h"去掉 换成:\n\nextern char g_str[];\nvoid fun2()  { cout << g_str << endl;  }\n\n\n1\n2\n\n\n这个时候编译器就知道g_str是引自于外部的一个编译模块了，不会在本模块中再重复定义一个出来，但是这样做会非常不方便，因为无法再在test2.cpp中使用#include "test1.h", 所以test1.h中声明的其他函数也无法使用了，除非都用extern修饰，声明的函数就要一大串，而且头文件的作用本来就是要给外部提供接口使用的，所以，只在头文件中做声明，真理总是这么简单粗暴。',normalizedContent:'extern关键字的含义， 用法以及在编译的时候是如何进行链接的\n\n 1. 置于变量或者函数前: 表明该变量或者函数定义在别的文件中\n 2. 在变量或者函数之前加上extern关键字表明这是一个声明, 其定义可能在其他文件处, 注意不能对变量进行初始化或者对函数进行定义, 否则表明这是一个定义而不是声明.\n\n\n# extern + non-const var\n\n最常见的用法，当链接器在一个全局变量声明前看到extern关键字，它会尝试在其他文件中寻找这个变量的定义。这里强调全局且非常量的原因是，全局非常量的变量默认是外部链接的。\n\n//filea.cpp\nint i = 1;     //声明并定义全局变量i\n \n//fileb.cpp\nextern int i;  //声明i，链接全局变量\n \n//filec.cpp\nextern int i = 2;    //错误，多重定义\nint i;               //错误，这是一个定义，导致多重定义\n\nmain() {\n  extern int i;    //正确\n  int i = 5;       //正确，新的局部变量i;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# extern + const var\n\n常量全局变量默认是内部链接的，所以想要在文件间传递常量全局变量需要在定义时指明extern，如下所示：\n\n//filea.cpp\nextern const int i = 1;    //定义\n \n//fileb.cpp                \nextern const int i;        //声明\n\n\n1\n2\n3\n4\n5\n\n * 默认情况下, const修饰的全局常量据有跟static相同的特性， const 对象仅在本文件内有效, 但是可以通过 extern 关键字来使得 const 对象在多个文件中共享. 如在.h文件中声明 extern const char g_str[]; 在.cpp中别忘了定义: const char g_str[ ] = "123456";\n\n所以当const单独使用时它就与static相同，而当与extern一起合作的时候，它的特性就跟extern的一样了\n\n所以对const没有什么可以过多的描述，只是要注意，const char* g_str = "123456" 与 const char g_str[] ="123465"是不同的， 前面那个const 修饰的是char 而不是g_str,它的g_str并不是常量，如果让char g_str遵守const的全局常量的规则，最好这么定义const char const g_str="123456". 这个话题在 const关键字中讨论\n\n\n# extern 和 static\n\n(1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.\n\n(2) static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.\n\nstatic 作用范围是内部连接的关系, 和extern有点相反.它和对象本身是分开存储的,extern也是分开存储的,但是extern可以被其他的对象用extern 引用,而static 不可以,只允许对象本身用它. 具体差别首先，static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；最后，static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它,如:\n\n(1) test1.h:\n\n#ifndef test1h\n#define test1h\nstatic char g_str[] = "123456";\nvoid fun1();\n#endif\n\n\n1\n2\n3\n4\n5\n\n\n(2) test1.cpp:\n\n#include "test1.h"\nvoid fun1() {  cout << g_str << endl; }\n\n\n1\n2\n\n\n(3) test2.cpp\n\n#include "test1.h"\nvoid fun2() {  cout << g_str << endl; }\n\n\n1\n2\n\n\n以上两个编译单元可以连接成功, 当你打开test1.obj时，你可以在它里面找到字符串"123456", 同时你也可以在test2.obj中找到它们，它们之所以可以连接成功而没有报重复定义的错误是因为虽然它们有相同的内容，但是存储的物理地址并不一样，就像是两个不同变量赋了相同的值一样，而这两个变量分别作用于它们各自的编译单元。 也许你比较较真，自己偷偷的跟踪调试上面的代码,结果你发现两个编译单元（test1,test2）的g_str的内存地址相同，于是你下结论static修饰的变量也可以作用于其他模块，但是我要告诉你，那是你的编译器在欺骗你，大多数编译器都对代码都有优化功能，以达到生成的目标程序更节省内存，执行效率更高，当编译器在连接各个编译单元的时候，它会把相同内容的内存只拷贝一份，比如上面的"123456", 位于两个编译单元中的变量都是同样的内容，那么在连接的时候它在内存中就只会存在一份了，如果你把上面的代码改成下面的样子，你马上就可以拆穿编译器的谎言:\n\ntest1.cpp:\n\n#include "test1.h"\nvoid fun1()\n{\n    g_str[0] = \'\'a\'\';\n    cout << g_str << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\ntest2.cpp:\n\n#include "test1.h"\nvoid fun2() { cout << g_str << endl; }\n\n\n1\n2\n\n\nmain function:\n\nvoid main(){\n    fun1(); // a23456\n    fun2(); // 123456\n}\n\n\n1\n2\n3\n4\n\n\n这个时候你在跟踪代码时，就会发现两个编译单元中的g_str地址并不相同，因为你在一处修改了它，所以编译器被强行的恢复内存的原貌，在内存中存在了两份拷贝给两个模块中的变量使用。正是因为static有以上的特性，所以一般定义static全局变量时，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染.\n\n\n# extern "c"\n\n 1. extern"c": 让编译器以 c 语言的命名规则来查找函数\n 2. extern“c”的主要作用就是为了能够正确实现c++代码调用其他c语言代码。加上extern “c”后，会指示编译器这部分代码按c语言的进行编译，而不是c++的。由于c++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而c语言并不支持函数重载，因此编译c语言代码的函数时不会带上函数的参数类型，一般只包括函数名。因为 c++ 重载, 而 c 不重载, 函数名编译的结果都不一样, 因此如果 c++ 直接调用 c 的函数, 因为二者编译的不同, 就会失败.\n\n在c++中，当与字符串连用时，extern指明当前声明使用了其他语言的链接规范，如extern "c"，就指明使用c语言的链接规范。原因是，c++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而c语言则不会，因此会造成链接时无法找到对应函数的情况，此时c函数就需要用extern “c”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。c和c++对函数的处理方式是不同的.extern "c"是使c++能够调用c写作的库文件的一个手段，如果要对编译器提示使用c的方式来处理函数的话，那么就要使用extern "c"来说明。\n\n// 声明printf函数使用c链接\nextern "c" int printf(const char *fmt, ...);\n\n//声明指定的头文件内所有的东西都使用 c 链接\nextern "c" {\n    #include <stdio.h>\n}\n\n// 声明函数showchar和getchar使用 c 链接\nextern "c" {\n    char showchar(char ch);\n    char getchar(void);\n}\n\n// 定义函数 showchar 和 getchar 使用 c 链接\nextern "c" char showchar(char ch) {\n    putchar(ch);\n    return ch;\n}\n\nextern "c" char getchar(void) {\n    char ch;\n    ch = getchar();\n    return ch;\n}\n\n// 声明全局变量 errno 为c链接\nextern "c" int errno;\n\n//又比如，在程序中常见的代码段\n#ifdef __cplusplus \nextern "c" { \n   #endif \n\n/**** some declaration or so *****/ \n#ifdef __cplusplus \n} \n#endif\n\n//这里__cplusplus是cpp中的自定义宏，定义了这个宏就表明这是一段cpp的代码，也就是说，//上面的代码的含义是:如果这是一段cpp的代码，那么加入extern "c"{和}处理其中的代码。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n * extern和static是一对矛盾的修饰符, 二者不能同时修饰一个变量, 因为static表明变量的链接性是内部的, 而extern恰好相反.\n\n注意事项：\n\n * 不要把变量定义放入.h文件，这样容易导致重复定义错误\n\n * 尽量使用static关键字把变量定义限制于该源文件作用域，除非变量被设计成全局的。\n\n * 可以在头文件中声明一个变量，在用的时候包含这个头文件就声明了这个变量。\n\n\n# 一些问题：\n\n\n# 问题(1)：extern 变量\n\n在一个源文件里定义了一个数组：char a[6];\n\n在另外一个文件里用下列语句进行了声明：extern char *a；\n\n请问，这样可以吗？\n\n答案与分析：\n\n1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型t的指针并不等价于类型t的数组。extern char *a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。\n\n2)、例子分析如下，如果a[ ] = "abcd",则外部变量a=0x61626364 (abcd的ascii码值)，*a显然没有意义\n\na指向的空间（0x61626364）没有意义，易出现非法内存访问。\n\n3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。\n\n4)、extern用在变量声明中常常有这样一个作用，在*.*c文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在.h中并用extern来声明。\n\n\n# 问题(2)：单方面修改extern函数原型\n\n当函数提供方单方面修改函数原型时，如果使用方不知情继续沿用原来的extern申明，这样编译时编译器不会报错。但是在运行过程中，因为少了或者多了输入参数，往往会照成系统错误，这种情况应该如何解决？\n\n答案与分析：\n\n这种情况的处理没有一个很完美的方案，通常是提供方在自己的xxx_pub.h中提供对外部接口的声明，然后调用方include该头文件，从而省去extern这一步。以避免这种错误。\n\n剑有双锋，对extern的应用，不同的场合应该选择不同的做法。\n\n\n# 问题(3)：extern “c”\n\n在c++环境下使用c函数的时候，常常会出现编译器无法找到obj模块中的c函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？\n\n答案与分析：\n\nc++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而c语言则不会，因此会造成链接时找不到对应函数的情况，此时c函数就需要用extern “c”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。\n\n下面是一个典型的用法：\n\n//在.h文件的头上\n#ifdef __cplusplus\n#if __cplusplus\nextern "c"{\n#endif\n#endif /* __cplusplus */\n\n    …\n    …\n\n//.h文件结束的地方\n#ifdef __cplusplus\n#if __cplusplus\n}\n#endif\n#endif /* __cplusplus */ \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 问题(4)：extern 非 static 函数\n\n常常见extern放在函数的前面成为函数声明的一部分，那么，c语言的关键字extern在函数的声明中起什么作用？\n\n答案与分析：\n\n如果函数的声明中带有关键字extern，仅仅是暗示这个函数可能在别的源文件里定义，没有其它作用。即extern int f(); 和 int f();两个函数声明没有明显的区别\n\n当然，用处还是有的，就是在程序中取代include “*.h”来声明函数，在一些复杂的项目中，我比较习惯在所有的函数声明前添加extern修饰。关于这样做的原因和利弊可见下面的这个例子：“用extern修饰的全局变量”\n\n(1) 在test1.h中有下列声明:\n\n#ifndef test1h\n#define test1h\n\nextern char g_str[]; // 声明全局变量g_str\nvoid fun1();\n\n#endif\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n(2) 在test1.cpp中\n\n#include "test1.h"\nchar g_str[] = "123456"; // 定义全局变量g_str\nvoid fun1() { cout << g_str << endl; }\n\n\n1\n2\n3\n\n\n(3) 以上是test1模块， 它的编译和连接都可以通过,如果我们还有test2模块也想使用g_str,只需要在原文件中引用就可以了\n\n#include "test1.h"\nvoid fun2()  { cout << g_str << endl;  }\n\n\n1\n2\n\n\n以上test1和test2可以同时编译连接通过，如果你感兴趣的话可以用ultraedit打开test1.obj,你可以在里面找到"123456"这个字符串,但是你却不能在test2.obj里面找到，这是因为g_str是整个工程的全局变量，在内存中只存在一份,test2.obj这个编译单元不需要再有一份了，不然会在连接时报告重复定义这个错误!\n\n(4) 有些人喜欢把全局变量的声明和定义放在一起，这样可以防止忘记了定义，如把上面test1.h改为\n\nextern char g_str[] = "123456"; // 这个时候相当于没有extern\n\n\n1\n\n\n然后把test1.cpp中的g_str的定义去掉,这个时候再编译连接test1和test2两个模块时，会报连接错误，这是因为你把全局变量g_str的定义放在了头文件之后，test1.cpp这个模块包含了test1.h所以定义了一次g_str,而test2.cpp也包含了test1.h所以再一次定义了g_str,这个时候连接器在连接test1和test2时发现两个g_str。如果一定要把g_str的定义放在test1.h中的话，那么就把test2的代码中#include "test1.h"去掉 换成:\n\nextern char g_str[];\nvoid fun2()  { cout << g_str << endl;  }\n\n\n1\n2\n\n\n这个时候编译器就知道g_str是引自于外部的一个编译模块了，不会在本模块中再重复定义一个出来，但是这样做会非常不方便，因为无法再在test2.cpp中使用#include "test1.h", 所以test1.h中声明的其他函数也无法使用了，除非都用extern修饰，声明的函数就要一大串，而且头文件的作用本来就是要给外部提供接口使用的，所以，只在头文件中做声明，真理总是这么简单粗暴。',charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"pointer",frontmatter:{title:"pointer",date:"2022-06-27T08:07:28.000Z",categories:["C++"],tags:[null],permalink:"/pages/c08a6e/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/06.pointer.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/06.pointer.md",key:"v-9b512a1a",path:"/pages/c08a6e/",headers:[{level:2,title:"引用与指针那些事",slug:"引用与指针那些事",normalizedTitle:"引用与指针那些事",charIndex:2},{level:2,title:"函数指针和指针函数",slug:"函数指针和指针函数",normalizedTitle:"函数指针和指针函数",charIndex:15}],headersStr:"引用与指针那些事 函数指针和指针函数",content:'# 引用与指针那些事\n\n\n# 函数指针和指针函数\n\n#include <iostream>\nusing namespace std;\n/*! \\brief Possible kinds of TypeVars. */\nenum TypeKind {\n\n kType = 0,\n /*! \\brief Template variable in shape expression. */\n kShapeVar = 1,\n kBaseType = 2,\n kConstraint = 4,\n kAdtHandle = 5,\n kTypeData = 6\n};\n\nunion TypeValue {\n char c;\n unsigned char uc;\n long l;\n};\n\nconst double* f1(const double arr[], int n) { return arr; }\nconst double* f2(const double arr[], int n) { return arr + 1; }\nconst double* f3(const double* arr, int n) { return arr + 2; }\n\nint main(int argc, char* argv[]) {\n TypeKind a = kShapeVar;\n TypeValue b;\n b.c = \'L\';\n cout << "test for union:b.c " << b.c << endl;\n\n b.l = 1234;\n cout << "test for union:b.l " << b.l << endl;\n cout << "test for union:b.c " << b.c << endl;\n\n double at[3] = {12.1, 3.4, 4.5};\n const double* (*pfunc)(const double*, int) = f1;\n cout << "test for function pointer: Point1: " << *pfunc(at, 3) << endl;\n\n const double* (*pfunc1[3])(const double*, int) = {f1, f2, f3};\n cout << "test for function pointer: Point1: " << *pfunc1[2](at, 3) << endl;\n cout << "test for function pointer: Point12: " << *pfunc1[0](at, 3) << endl;\n cout << "test for function pointer: Point1: " << *((*pfunc1[2])(at, 3)) << endl;\n cout << "test for enum: " << a << endl;\n\n cout << "hello word" << endl;\n\n\n\n cout << "test for singleton";\n\n return 0;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n',normalizedContent:'# 引用与指针那些事\n\n\n# 函数指针和指针函数\n\n#include <iostream>\nusing namespace std;\n/*! \\brief possible kinds of typevars. */\nenum typekind {\n\n ktype = 0,\n /*! \\brief template variable in shape expression. */\n kshapevar = 1,\n kbasetype = 2,\n kconstraint = 4,\n kadthandle = 5,\n ktypedata = 6\n};\n\nunion typevalue {\n char c;\n unsigned char uc;\n long l;\n};\n\nconst double* f1(const double arr[], int n) { return arr; }\nconst double* f2(const double arr[], int n) { return arr + 1; }\nconst double* f3(const double* arr, int n) { return arr + 2; }\n\nint main(int argc, char* argv[]) {\n typekind a = kshapevar;\n typevalue b;\n b.c = \'l\';\n cout << "test for union:b.c " << b.c << endl;\n\n b.l = 1234;\n cout << "test for union:b.l " << b.l << endl;\n cout << "test for union:b.c " << b.c << endl;\n\n double at[3] = {12.1, 3.4, 4.5};\n const double* (*pfunc)(const double*, int) = f1;\n cout << "test for function pointer: point1: " << *pfunc(at, 3) << endl;\n\n const double* (*pfunc1[3])(const double*, int) = {f1, f2, f3};\n cout << "test for function pointer: point1: " << *pfunc1[2](at, 3) << endl;\n cout << "test for function pointer: point12: " << *pfunc1[0](at, 3) << endl;\n cout << "test for function pointer: point1: " << *((*pfunc1[2])(at, 3)) << endl;\n cout << "test for enum: " << a << endl;\n\n cout << "hello word" << endl;\n\n\n\n cout << "test for singleton";\n\n return 0;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n',charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"static",frontmatter:{title:"static",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/9b131d/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/07.static.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/07.static.md",key:"v-a31e7cfa",path:"/pages/9b131d/",headers:[{level:2,title:"C 语言中的 static:",slug:"c-语言中的-static",normalizedTitle:"c 语言中的 static:",charIndex:184},{level:3,title:"static 全局变量",slug:"static-全局变量",normalizedTitle:"static 全局变量",charIndex:396},{level:3,title:"static 局部变量",slug:"static-局部变量",normalizedTitle:"static 局部变量",charIndex:2056},{level:3,title:"static 函数",slug:"static-函数",normalizedTitle:"static 函数",charIndex:2739},{level:2,title:"C++类的static成员变量:",slug:"c-类的static成员变量",normalizedTitle:"c++类的static成员变量:",charIndex:3080},{level:3,title:"成员变量的几种情况:",slug:"成员变量的几种情况",normalizedTitle:"成员变量的几种情况:",charIndex:4866},{level:4,title:"静态变量",slug:"静态变量",normalizedTitle:"静态变量",charIndex:214},{level:4,title:"常量",slug:"常量",normalizedTitle:"常量",charIndex:4454},{level:4,title:"引用变量",slug:"引用变量",normalizedTitle:"引用变量",charIndex:5155},{level:4,title:"静态常量",slug:"静态常量",normalizedTitle:"静态常量",charIndex:5231},{level:4,title:"static member var.：",slug:"static-member-var",normalizedTitle:"static member var.：",charIndex:5397},{level:4,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:6579},{level:2,title:"C++ 类的Static成员函数",slug:"c-类的static成员函数",normalizedTitle:"c++ 类的static成员函数",charIndex:6718},{level:2,title:"拷贝构造函数的问题",slug:"拷贝构造函数的问题",normalizedTitle:"拷贝构造函数的问题",charIndex:8970}],excerpt:"<p>static关键字的含义， example以及程序底层的数据划分</p>\n",headersStr:"C 语言中的 static: static 全局变量 static 局部变量 static 函数 C++类的static成员变量: 成员变量的几种情况: 静态变量 常量 引用变量 静态常量 static member var.： 优点 C++ 类的Static成员函数 拷贝构造函数的问题",content:'static关键字的含义， example以及程序底层的数据划分\n\n这里是cpp reference上面static关键字的链接： https://en.cppreference.com/w/cpp/keyword/static\n\n从汇编层面， 解释static变量是存在于什么地方， 存在于什么样代码段或者数据段上面？ (这涉及到汇编和编译的更细节的知识)\n\n\n# C 语言中的 static:\n\n修饰函数内部变量，即函数内的静态变量。这种变量的生存期长于该函数，使得函数具有一定的“状态”。使用静态变量的函数一般是不可重入的，也不是线程安全的，比如strtok(3)。\n\n在函数体之外，修饰全局变量或函数，表示该变量或函数只在本文件可见，其他文件看不到也访问不到该变量或函数。专业的说法叫“具有internal linkage”（不暴露给别的translation unit）。\n\n\n# static 全局变量\n\n//Example 1\n#include <iostream.h> \n\nvoid fn();\nstatic int n=5;    // 静态全局变量 \nint j = 3;  // 默认为extern， 全局变量\nvoid main()\n{\n\tn=20;\n\tcout<<n<<endl;\n\tfn();\n} \n\nvoid fn()\n{\n\tn++;\n\tcout<<n<<endl;\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nstatic 修饰全局变量，限制该变量的作用域为当前文件，就是说这个变量能在当前文件中作为全局变量被访问，但不能再其他文件中被访问\n\n全局变量 j 和静态变量 i 都存放于程序的全局数据区域，它们的生存周期都是程序的整个运行期，但是 j 在函数外定义， 是一个全局变量，可以通过extern在其他文件中使用，而 i 的使用的static修饰，只能在file A中使用，例如在file B中：\n\nextern int j; //OK\nextern int i; // error: i在文件B中不可见， 只在 file A 中可见\nint a = j; // OK\nint b = i; // error\n\n\n1\n2\n3\n4\n\n\n也就是说，在声明全局的static变量时，static没有改变它的生存周期，也即存储位置（因为全局变量本来就存储在全局数据域），而是将变量的作用域限制在当前文件中。\n\n静态全局变量有以下特点：\n\n 1. 该变量在全局数据区分配内存；\n    \n    \n\n 2. 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；\n\n 3. 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；\n\n 4. 静态变量都在全局数据区分配内存，包括静态局部/全局变量。对于一个完整的程序，在内存中的分布情况如上图，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区。**自动变量一般会随着函数的退出而释放空间，**而全局数据区的数据并不会因为函数的退出而释放空间。\n\nExample 1中的代码中将\n\nstatic int n=5; // 定义静态全局变量\n\n\n1\n\n\n改为\n\nint n=; // 定义全局变量\n\n\n1\n\n\n程序照样正常运行。 定义全局变量就可以实现变量在文件中的共享，但静态全局变量还有以下好处：\n\n 1. 静态全局变量不能被其它文件所用；\n 2. 其它文件中可以定义相同名字的变量，不会发生冲突；\n\n将上述示例代码改为如下：\n\n//Example 2\n//File A\n#include <iostream.h> \n\nvoid fn();\nstatic int n; //定义静态全局变量 \n\nvoid main()\n{\n\tn=20;\n\tcout<<n<<endl;\n\tfn();\n} \n\n//File B\n#include <iostream.h> \nextern int n;\nvoid fn()\n{\n\tn++;\n\tcout<<n<<endl;\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n编译并运行Example 2，会发现上述代码可以分别通过编译，但运行时出现错误。 这就是因为静态全局变量不能被其它文件所用，即使在其它文件中使用extern 进行声明也不行。\n\n我们将\n\nstatic int n; //定义静态全局变量\n\n\n1\n\n\n改为\n\nint n; //定义全局变量\n\n\n1\n\n\n再次编译运行程序，程序可正常运行。\n\n因此，在一个文件中，静态全局变量和全局变量功能相同；而在两个文件中，要使用同一个变量，则只能使用全局变量而不能使用静态全局变量。\n\n\n# static 局部变量\n\n//Example 3\n#include <iostream.h>\nvoid fn();  // forward declaration\nvoid main()\n{\n\tfn(); //10\n\tfn(); //11\n\tfn(); //12\n}\n\nvoid fn()\n{\n\tstatic n=10; // 函数体内部的变量叫局部变量，加上关键字static，就成为一个静态局部变量。\n\tcout<<n<<endl;\n\tn++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n在函数体内的变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。\n\n但有时候我们需要在两次调用同一个函数的时候对变量的值进行保存和处理。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制。\n\n静态局部变量可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。\n\nstatic 局部变量特点：\n\n 1. 静态局部变量在全局数据区分配内存；\n 2. 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；\n 3. 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；\n 4. 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；\n\n\n# static 函数\n\n在函数的返回类型前加上static关键字, 函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。\n\n//Example 4\n#include <iostream.h>\nstatic void fn();//声明静态函数\n\nvoid main()\n{\n    fn();\n}\n\nvoid fn()//定义静态函数\n{\n    int n=10;\n    cout<<n<<endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nstatic 函数特点：（类似于静态全局变量）\n\n 1. 静态函数不能被其它文件所用；\n 2. 其它文件中可以定义相同名字的函数，不会发生冲突；\n\n\n# C++类的static成员变量:\n\n在类内成员变量的声明前加上关键字static，该数据成员就成为类内的静态数据成员。\n\n//Example 5\n#include <iostream.h>\nclass Myclass\n{\npublic:\n\tMyclass(int a,int b,int c);\n\tvoid GetSum();\nprivate:\n\tint a,b,c;\n\tstatic int Sum;   //声明静态数据成员\n};\n\nint Myclass::Sum=0;    //定义并初始化静态数据成员\n\nMyclass::Myclass(int a,int b,int c)\n{\n\tthis->a=a;\n\tthis->b=b;\n\tthis->c=c;\n\tSum+=a+b+c;\n}\n\nvoid Myclass::GetSum()\n{\n\tcout<<"Sum="<<Sum<<endl;\n}\n\nvoid main()\n{\n\tMyclass M(1,2,3);\n\tM.GetSum();\n\tMyclass N(4,5,6);\n\tN.GetSum();\n\tM.GetSum();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n何时采用静态数据成员？\n\n设置静态成员（变量和函数）这种机制的目的是将某些和类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于理解和维护。**如果想在同类的多个对象之间实现数据共享，又不要用全局变量，那么就可以使用静态成员变量。**也即，静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处：\n\n 1. 不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，节省存储空间。\n 2. 一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。\n\n你也许会问，用全局变量不是也可以达到这个效果吗？\n\n同全局变量相比，使用静态数据成员有两个优势：\n\n 1. 静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。\n 2. 可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。\n\n用于修饰类的数据成员，即所谓“静态成员”。这种数据成员的生存期大于class的对象（实例/instance）。静态数据成员是每个class有一份，普通数据成员是每个instance 有一份。\n\nclass CTypeInit{\n    public:\n    \tCTypeInit(int c) : m_c(c),m_ra(c) { }\n    private:\n        int m_a;          //通过初始化列表初始化，或者构造函数初始化\n        /*引用*/\n        int &m_ra;        //只能通过初始化列表初始化\n        /*静态变量*/\n        static int m_b;            \n        /*常量*/\n        const int m_c;            \n\n        /*静态整型常量*/\n        static const int m_d;    \n        /*静态非整型常量*/\n        static const double m_e;\n};\n\n//静态成员变量，必须在类外初始化,且要去掉static关键字\nint CTypeInit::m_b = 6;\nconst int CTypeInit::m_d = 6;\nconst double CTypeInit::m_e = 3.1415926;\n\nint main()\n{\n    CTypeInit obT(2);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 成员变量的几种情况:\n\n# 静态变量\n\nstatic int m_b;\n\n\n1\n\n\nstatic成员变量需要在类定义体外进行初始化与定义，因为static数据成员独立该类的任意对象存在，它是与类关联的对象，不与类对象关联。例如：上述程序中的c变量的初始化。\n\n 1. 只能在类外初始化\n 2. 不能通过初始化列表初始化，\n 3. 不能在类内进行初始化，\n 4. 不能在构造函数中初始化，\n\n# 常量\n\nconst int m_c;\n\n\n1\n\n\n 1. 只能通过初始化列表初始化\n\n 2. 不能在类内进行初始化\n\n 3. 不能在构造函数中初始化\n\n 4. 不能在类外初始化\n\n# 引用变量\n\nint &m_ra;\n\n\n1\n\n\n只能通过初始化列表初始化且必须用变量初始化，不能在类的定义外（内）初始化，不能通过构造函数初始化。\n\n# 静态常量\n\nstatic const int m_d;\n\n\n1\n\n 1. 能否在类中初始化，取决于编译器\n 2. 能在在类外初始化，但不能带static\n\n类的静态成员属于类作用域，但不属于类对象，它的生命周期和普通的全局静态变量一样，程序运行时进行分配内存和初始化，程序结束时则被释放。所以不能在类的构造函数中进行初始化。\n\n# static member var.：\n\n 1.  静态成员变量是该类的所有对象所共有的。对于普通成员变量，每个类对象都有自己的一份拷贝。而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；\n\n 2.  因为静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它；\n\n 3.  静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。在Example 5中，语句int Myclass::Sum=0;是定义并初始化静态成员变量。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。\n\n 4.  static 成员变量和普通 static 变量一样，编译时在静态数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。\n\n 5.  静态数据成员初始化与一般数据成员初始化不同。初始化时可以不加 static，但必须要有数据类型。被 private、protected、public 修饰的 static 成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞\n\n 6.  类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名＞\n\n 7.  类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问。\n\n 8.  静态数据成员和普通数据成员一样遵从public,protected,private访问规则；\n\n 9.  如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；\n\n 10. sizeof 运算符不会计算 静态成员变量。\n     \n     class CMyclass{\n         int n;\n         static int s;\n     };    //则sizeof（CMyclass）等于4\n     \n     \n     1\n     2\n     3\n     4\n     \n\n# 优点\n\n 1. static成员的名字是在类的作用域中，因此可以避免与其它类成员或全局对象名字冲突。\n 2. 可以实施封装，static成员可以是私有的，而全局对象不可以。\n 3. 阅读程序容易看出static成员与某个类相关联，这种可见性可以清晰地反映程序员的意图。\n\n\n# C++ 类的Static成员函数\n\n静态成员函数为类服务而不是为某一个类的具体对象服务。静态成员函数与静态成员变量一样，都是类的内部实现，属于类定义的一部分。普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。\n\n普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体地属于类的某个具体对象的。当函数被调用时，系统会把当前对象的起始地址赋给 this 指针。通常情况下，this是缺省的。如函数fn()实际上是this->fn()。\n\n与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。从另一个角度来看，由于静态成员函数和静态成员变量在类实例化之前就已经存在可以访问，而此时非静态成员还是不存在的，因此静态成员不能访问非静态成员。\n\n//Example 6\n#include <iostream>\nusing namespace std;\n\nclass Student{\nprivate:\n   char *name;\n   int age;\n   float score;\n   static int num;  \t//学生人数\n   static float total;  //总分\npublic:\n   Student(char *, int, float);\n   void say();\n   static float getAverage();  //静态成员函数，用来获得平均成绩\n};\n\nint Student::num = 0;\nfloat Student::total = 0;\n\nStudent::Student(char *name, int age, float score)\n{\n   this->name = name;\n   this->age = age;\n   this->score = score;\n   num++;\n   total += score;\n}\n\nvoid Student::say()\n{\n   cout<<name<<"的年龄是 "<<age<<"，成绩是 "<<score<<"（当前共"<<num<<"名学生）"<<endl;\n}\n\nfloat Student::getAverage()\n{\n   return total / num;\n}\n\nint main()\n{\n   (new Student("小明", 15, 90))->say();\n   (new Student("李磊", 16, 80))->say();\n   (new Student("张华", 16, 99))->say();\n   (new Student("王康", 14, 60))->say();\n   cout<<"平均成绩为 "<<Student::getAverage()<<endl;\n   return 0;\n}\n\n运行结果：\n小明的年龄是 15，成绩是 90（当前共1名学生）\n李磊的年龄是 16，成绩是 80（当前共2名学生）\n张华的年龄是 16，成绩是 99（当前共3名学生）\n王康的年龄是 14，成绩是 60（当前共4名学生）\n平均成绩为 82.25\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n静态成员函数的特点：\n\n 1. 出现在类外的函数定义不能指定关键字static；\n 2. 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而静态成员函数（仅）可以访问static成员变量、static成员函数。\n 3. 因为static成员函数没有this指针，所以静态成员函数不可以访问非静态成员。\n 4. 静态数据成员与类的大小无关，因为静态成员只是作用在类的范围而已。\n 5. 非静态成员函数可以任意地访问静态成员函数和静态数据成员；\n 6. 由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；\n 7. 调用静态成员函数，两种方式：\n\n * 通过成员访问操作符(.)和(->)，也即通过类对象或指向类对象的指针调用静态成员函数。\n * 直接通过类来调用静态成员函数。＜类名＞::＜静态成员函数名＞（＜参数表＞）。也即，静态成员不需要通过对象就能访问。\n\n成员函数特点：\n\n 1. 函数体内作用范围为该函数体，该变量内存只被分配一次，具有记忆能力（内存分配在静态区，在第一次调用的时候分配内存，函数调用结束内存并不释放）\n 2. 在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；（模块，{}括起来的语句块都是，不同的文件也是不同的模块）\n 3. 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；\n 4. 在类中的static成员变量属于整个类所拥有，对类的所有实例只有一份拷贝；\n\n\n# 拷贝构造函数的问题\n\n在使用包含静态成员的类时，有时候会调用拷贝构造函数生成临时的隐藏的类对象，而这个临时对象在消亡时会调用析构函数有可能会对静态变量做操作（例如total_num--），可是这些对象在生成时却没有执行构造函数中的total_num++的操作。解决方案是为这个类写一个拷贝构造函数，在该拷贝构造函数中完成total_num++的操作。\n\n#include <iostream>\nusing namespace std;\nclass test2\n{\n    public:\n        test2(int num) : y(num){}\n        ~test2(){}\n\n        static void testStaticFun()\n        {\n            cout << "y = " << y << endl;     // Error:静态成员函数不能访问非静态成员， static成员函数没有this指针\n        }\n\n        void testFun()\n        {\n            cout << "x = " << x << endl; \n        }\n    private:\n        static int x;   // 静态成员变量的引用性说明\n        int y;\n};\n\nint test2::x = 10;      // 静态成员变量的定义性说明\nint main(void)\n{\n    test2 t(100);\n    t.testFun();\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n静态整型常量和静态非整形常量在类定义内部初始化时，在VC6.0中都不能编译通过，而在GCC中都可以编译通过，在不同编译器下有不同的结果，但前三个是确定的。当然，如果不习惯类内初始化，可以将静态常量和静态变量的初始化统一起来，将静态常量和静态变量的初始化全部都移动类定义之外初始化（推荐使用这种方式）。另外，如果编译器不支持类内初始化，而此时类在编译期又恰恰需要定义的成员常量的值，身出如此左右为难的境地，我们应该考虑使用enum！因为enum 本质也是一个整型常量。',normalizedContent:'static关键字的含义， example以及程序底层的数据划分\n\n这里是cpp reference上面static关键字的链接： https://en.cppreference.com/w/cpp/keyword/static\n\n从汇编层面， 解释static变量是存在于什么地方， 存在于什么样代码段或者数据段上面？ (这涉及到汇编和编译的更细节的知识)\n\n\n# c 语言中的 static:\n\n修饰函数内部变量，即函数内的静态变量。这种变量的生存期长于该函数，使得函数具有一定的“状态”。使用静态变量的函数一般是不可重入的，也不是线程安全的，比如strtok(3)。\n\n在函数体之外，修饰全局变量或函数，表示该变量或函数只在本文件可见，其他文件看不到也访问不到该变量或函数。专业的说法叫“具有internal linkage”（不暴露给别的translation unit）。\n\n\n# static 全局变量\n\n//example 1\n#include <iostream.h> \n\nvoid fn();\nstatic int n=5;    // 静态全局变量 \nint j = 3;  // 默认为extern， 全局变量\nvoid main()\n{\n\tn=20;\n\tcout<<n<<endl;\n\tfn();\n} \n\nvoid fn()\n{\n\tn++;\n\tcout<<n<<endl;\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nstatic 修饰全局变量，限制该变量的作用域为当前文件，就是说这个变量能在当前文件中作为全局变量被访问，但不能再其他文件中被访问\n\n全局变量 j 和静态变量 i 都存放于程序的全局数据区域，它们的生存周期都是程序的整个运行期，但是 j 在函数外定义， 是一个全局变量，可以通过extern在其他文件中使用，而 i 的使用的static修饰，只能在file a中使用，例如在file b中：\n\nextern int j; //ok\nextern int i; // error: i在文件b中不可见， 只在 file a 中可见\nint a = j; // ok\nint b = i; // error\n\n\n1\n2\n3\n4\n\n\n也就是说，在声明全局的static变量时，static没有改变它的生存周期，也即存储位置（因为全局变量本来就存储在全局数据域），而是将变量的作用域限制在当前文件中。\n\n静态全局变量有以下特点：\n\n 1. 该变量在全局数据区分配内存；\n    \n    \n\n 2. 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；\n\n 3. 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；\n\n 4. 静态变量都在全局数据区分配内存，包括静态局部/全局变量。对于一个完整的程序，在内存中的分布情况如上图，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区。**自动变量一般会随着函数的退出而释放空间，**而全局数据区的数据并不会因为函数的退出而释放空间。\n\nexample 1中的代码中将\n\nstatic int n=5; // 定义静态全局变量\n\n\n1\n\n\n改为\n\nint n=; // 定义全局变量\n\n\n1\n\n\n程序照样正常运行。 定义全局变量就可以实现变量在文件中的共享，但静态全局变量还有以下好处：\n\n 1. 静态全局变量不能被其它文件所用；\n 2. 其它文件中可以定义相同名字的变量，不会发生冲突；\n\n将上述示例代码改为如下：\n\n//example 2\n//file a\n#include <iostream.h> \n\nvoid fn();\nstatic int n; //定义静态全局变量 \n\nvoid main()\n{\n\tn=20;\n\tcout<<n<<endl;\n\tfn();\n} \n\n//file b\n#include <iostream.h> \nextern int n;\nvoid fn()\n{\n\tn++;\n\tcout<<n<<endl;\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n编译并运行example 2，会发现上述代码可以分别通过编译，但运行时出现错误。 这就是因为静态全局变量不能被其它文件所用，即使在其它文件中使用extern 进行声明也不行。\n\n我们将\n\nstatic int n; //定义静态全局变量\n\n\n1\n\n\n改为\n\nint n; //定义全局变量\n\n\n1\n\n\n再次编译运行程序，程序可正常运行。\n\n因此，在一个文件中，静态全局变量和全局变量功能相同；而在两个文件中，要使用同一个变量，则只能使用全局变量而不能使用静态全局变量。\n\n\n# static 局部变量\n\n//example 3\n#include <iostream.h>\nvoid fn();  // forward declaration\nvoid main()\n{\n\tfn(); //10\n\tfn(); //11\n\tfn(); //12\n}\n\nvoid fn()\n{\n\tstatic n=10; // 函数体内部的变量叫局部变量，加上关键字static，就成为一个静态局部变量。\n\tcout<<n<<endl;\n\tn++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n在函数体内的变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。\n\n但有时候我们需要在两次调用同一个函数的时候对变量的值进行保存和处理。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制。\n\n静态局部变量可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。\n\nstatic 局部变量特点：\n\n 1. 静态局部变量在全局数据区分配内存；\n 2. 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；\n 3. 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；\n 4. 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；\n\n\n# static 函数\n\n在函数的返回类型前加上static关键字, 函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。\n\n//example 4\n#include <iostream.h>\nstatic void fn();//声明静态函数\n\nvoid main()\n{\n    fn();\n}\n\nvoid fn()//定义静态函数\n{\n    int n=10;\n    cout<<n<<endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nstatic 函数特点：（类似于静态全局变量）\n\n 1. 静态函数不能被其它文件所用；\n 2. 其它文件中可以定义相同名字的函数，不会发生冲突；\n\n\n# c++类的static成员变量:\n\n在类内成员变量的声明前加上关键字static，该数据成员就成为类内的静态数据成员。\n\n//example 5\n#include <iostream.h>\nclass myclass\n{\npublic:\n\tmyclass(int a,int b,int c);\n\tvoid getsum();\nprivate:\n\tint a,b,c;\n\tstatic int sum;   //声明静态数据成员\n};\n\nint myclass::sum=0;    //定义并初始化静态数据成员\n\nmyclass::myclass(int a,int b,int c)\n{\n\tthis->a=a;\n\tthis->b=b;\n\tthis->c=c;\n\tsum+=a+b+c;\n}\n\nvoid myclass::getsum()\n{\n\tcout<<"sum="<<sum<<endl;\n}\n\nvoid main()\n{\n\tmyclass m(1,2,3);\n\tm.getsum();\n\tmyclass n(4,5,6);\n\tn.getsum();\n\tm.getsum();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n何时采用静态数据成员？\n\n设置静态成员（变量和函数）这种机制的目的是将某些和类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于理解和维护。**如果想在同类的多个对象之间实现数据共享，又不要用全局变量，那么就可以使用静态成员变量。**也即，静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处：\n\n 1. 不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，节省存储空间。\n 2. 一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。\n\n你也许会问，用全局变量不是也可以达到这个效果吗？\n\n同全局变量相比，使用静态数据成员有两个优势：\n\n 1. 静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。\n 2. 可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。\n\n用于修饰类的数据成员，即所谓“静态成员”。这种数据成员的生存期大于class的对象（实例/instance）。静态数据成员是每个class有一份，普通数据成员是每个instance 有一份。\n\nclass ctypeinit{\n    public:\n    \tctypeinit(int c) : m_c(c),m_ra(c) { }\n    private:\n        int m_a;          //通过初始化列表初始化，或者构造函数初始化\n        /*引用*/\n        int &m_ra;        //只能通过初始化列表初始化\n        /*静态变量*/\n        static int m_b;            \n        /*常量*/\n        const int m_c;            \n\n        /*静态整型常量*/\n        static const int m_d;    \n        /*静态非整型常量*/\n        static const double m_e;\n};\n\n//静态成员变量，必须在类外初始化,且要去掉static关键字\nint ctypeinit::m_b = 6;\nconst int ctypeinit::m_d = 6;\nconst double ctypeinit::m_e = 3.1415926;\n\nint main()\n{\n    ctypeinit obt(2);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 成员变量的几种情况:\n\n# 静态变量\n\nstatic int m_b;\n\n\n1\n\n\nstatic成员变量需要在类定义体外进行初始化与定义，因为static数据成员独立该类的任意对象存在，它是与类关联的对象，不与类对象关联。例如：上述程序中的c变量的初始化。\n\n 1. 只能在类外初始化\n 2. 不能通过初始化列表初始化，\n 3. 不能在类内进行初始化，\n 4. 不能在构造函数中初始化，\n\n# 常量\n\nconst int m_c;\n\n\n1\n\n\n 1. 只能通过初始化列表初始化\n\n 2. 不能在类内进行初始化\n\n 3. 不能在构造函数中初始化\n\n 4. 不能在类外初始化\n\n# 引用变量\n\nint &m_ra;\n\n\n1\n\n\n只能通过初始化列表初始化且必须用变量初始化，不能在类的定义外（内）初始化，不能通过构造函数初始化。\n\n# 静态常量\n\nstatic const int m_d;\n\n\n1\n\n 1. 能否在类中初始化，取决于编译器\n 2. 能在在类外初始化，但不能带static\n\n类的静态成员属于类作用域，但不属于类对象，它的生命周期和普通的全局静态变量一样，程序运行时进行分配内存和初始化，程序结束时则被释放。所以不能在类的构造函数中进行初始化。\n\n# static member var.：\n\n 1.  静态成员变量是该类的所有对象所共有的。对于普通成员变量，每个类对象都有自己的一份拷贝。而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；\n\n 2.  因为静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它；\n\n 3.  静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。在example 5中，语句int myclass::sum=0;是定义并初始化静态成员变量。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。\n\n 4.  static 成员变量和普通 static 变量一样，编译时在静态数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。\n\n 5.  静态数据成员初始化与一般数据成员初始化不同。初始化时可以不加 static，但必须要有数据类型。被 private、protected、public 修饰的 static 成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞\n\n 6.  类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名＞\n\n 7.  类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问。\n\n 8.  静态数据成员和普通数据成员一样遵从public,protected,private访问规则；\n\n 9.  如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；\n\n 10. sizeof 运算符不会计算 静态成员变量。\n     \n     class cmyclass{\n         int n;\n         static int s;\n     };    //则sizeof（cmyclass）等于4\n     \n     \n     1\n     2\n     3\n     4\n     \n\n# 优点\n\n 1. static成员的名字是在类的作用域中，因此可以避免与其它类成员或全局对象名字冲突。\n 2. 可以实施封装，static成员可以是私有的，而全局对象不可以。\n 3. 阅读程序容易看出static成员与某个类相关联，这种可见性可以清晰地反映程序员的意图。\n\n\n# c++ 类的static成员函数\n\n静态成员函数为类服务而不是为某一个类的具体对象服务。静态成员函数与静态成员变量一样，都是类的内部实现，属于类定义的一部分。普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。\n\n普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体地属于类的某个具体对象的。当函数被调用时，系统会把当前对象的起始地址赋给 this 指针。通常情况下，this是缺省的。如函数fn()实际上是this->fn()。\n\n与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。从另一个角度来看，由于静态成员函数和静态成员变量在类实例化之前就已经存在可以访问，而此时非静态成员还是不存在的，因此静态成员不能访问非静态成员。\n\n//example 6\n#include <iostream>\nusing namespace std;\n\nclass student{\nprivate:\n   char *name;\n   int age;\n   float score;\n   static int num;  \t//学生人数\n   static float total;  //总分\npublic:\n   student(char *, int, float);\n   void say();\n   static float getaverage();  //静态成员函数，用来获得平均成绩\n};\n\nint student::num = 0;\nfloat student::total = 0;\n\nstudent::student(char *name, int age, float score)\n{\n   this->name = name;\n   this->age = age;\n   this->score = score;\n   num++;\n   total += score;\n}\n\nvoid student::say()\n{\n   cout<<name<<"的年龄是 "<<age<<"，成绩是 "<<score<<"（当前共"<<num<<"名学生）"<<endl;\n}\n\nfloat student::getaverage()\n{\n   return total / num;\n}\n\nint main()\n{\n   (new student("小明", 15, 90))->say();\n   (new student("李磊", 16, 80))->say();\n   (new student("张华", 16, 99))->say();\n   (new student("王康", 14, 60))->say();\n   cout<<"平均成绩为 "<<student::getaverage()<<endl;\n   return 0;\n}\n\n运行结果：\n小明的年龄是 15，成绩是 90（当前共1名学生）\n李磊的年龄是 16，成绩是 80（当前共2名学生）\n张华的年龄是 16，成绩是 99（当前共3名学生）\n王康的年龄是 14，成绩是 60（当前共4名学生）\n平均成绩为 82.25\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n静态成员函数的特点：\n\n 1. 出现在类外的函数定义不能指定关键字static；\n 2. 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而静态成员函数（仅）可以访问static成员变量、static成员函数。\n 3. 因为static成员函数没有this指针，所以静态成员函数不可以访问非静态成员。\n 4. 静态数据成员与类的大小无关，因为静态成员只是作用在类的范围而已。\n 5. 非静态成员函数可以任意地访问静态成员函数和静态数据成员；\n 6. 由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；\n 7. 调用静态成员函数，两种方式：\n\n * 通过成员访问操作符(.)和(->)，也即通过类对象或指向类对象的指针调用静态成员函数。\n * 直接通过类来调用静态成员函数。＜类名＞::＜静态成员函数名＞（＜参数表＞）。也即，静态成员不需要通过对象就能访问。\n\n成员函数特点：\n\n 1. 函数体内作用范围为该函数体，该变量内存只被分配一次，具有记忆能力（内存分配在静态区，在第一次调用的时候分配内存，函数调用结束内存并不释放）\n 2. 在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；（模块，{}括起来的语句块都是，不同的文件也是不同的模块）\n 3. 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；\n 4. 在类中的static成员变量属于整个类所拥有，对类的所有实例只有一份拷贝；\n\n\n# 拷贝构造函数的问题\n\n在使用包含静态成员的类时，有时候会调用拷贝构造函数生成临时的隐藏的类对象，而这个临时对象在消亡时会调用析构函数有可能会对静态变量做操作（例如total_num--），可是这些对象在生成时却没有执行构造函数中的total_num++的操作。解决方案是为这个类写一个拷贝构造函数，在该拷贝构造函数中完成total_num++的操作。\n\n#include <iostream>\nusing namespace std;\nclass test2\n{\n    public:\n        test2(int num) : y(num){}\n        ~test2(){}\n\n        static void teststaticfun()\n        {\n            cout << "y = " << y << endl;     // error:静态成员函数不能访问非静态成员， static成员函数没有this指针\n        }\n\n        void testfun()\n        {\n            cout << "x = " << x << endl; \n        }\n    private:\n        static int x;   // 静态成员变量的引用性说明\n        int y;\n};\n\nint test2::x = 10;      // 静态成员变量的定义性说明\nint main(void)\n{\n    test2 t(100);\n    t.testfun();\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n静态整型常量和静态非整形常量在类定义内部初始化时，在vc6.0中都不能编译通过，而在gcc中都可以编译通过，在不同编译器下有不同的结果，但前三个是确定的。当然，如果不习惯类内初始化，可以将静态常量和静态变量的初始化统一起来，将静态常量和静态变量的初始化全部都移动类定义之外初始化（推荐使用这种方式）。另外，如果编译器不支持类内初始化，而此时类在编译期又恰恰需要定义的成员常量的值，身出如此左右为难的境地，我们应该考虑使用enum！因为enum 本质也是一个整型常量。',charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"volatile",frontmatter:{title:"volatile",date:"2021-08-06T00:00:00.000Z",categories:["coding"],tags:["C++"],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/598385/"},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/08.volatile.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/08.volatile.md",key:"v-adaed63a",path:"/pages/598385/",headers:[{level:2,title:"volatile应用",slug:"volatile应用",normalizedTitle:"volatile应用",charIndex:70},{level:2,title:"3.volatile常见问题",slug:"_3-volatile常见问题",normalizedTitle:"3.volatile常见问题",charIndex:1715},{level:2,title:"4.volatile使用",slug:"_4-volatile使用",normalizedTitle:"4.volatile使用",charIndex:2338}],headersStr:"volatile应用 3.volatile常见问题 4.volatile使用",content:"被 volatile 修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。而这些可观测的副作用，是由程序之外的因素决定的。\n\n\n# volatile应用\n\n（1）并行设备的硬件寄存器（如状态寄存器）。 假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。\n\nint  *output = (unsigned  int *)0xff800000; //定义一个IO端口；  \nint   init(void)  \n{  \n    int i;  \n    for(i=0;i< 10;i++)\n    {  \n       *output = i;  \n    } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为 9，所以编译器最后给你编译编译的代码结果相当于：\n\nint  init(void)  \n{  \n    *output = 9;  \n}\n\n\n1\n2\n3\n4\n\n\n如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。\n\n（2）一个中断服务子程序中访问到的变量；\n\nstatic int i=0;\n\nint main()\n{\n    while(1)\n    {\n    \tif(i) do_something();\n    }\n}\n\n/* Interrupt service routine */\nvoid IRS()\n{\n\ti=1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面示例程序的本意是产生中断时，由中断服务子程序IRS响应中断，变更程序变量i，使在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远不会被调用。如果将变量i加上volatile修饰，则编译器保证对变量i的读写操作都不会被优化，从而保证了变量i被外部程序更改后能及时在原程序中得到感知。\n\n（3）多线程应用中被多个任务共享的变量。 当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。作用是防止编译器优化把变量从内存装入CPU寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。volatile的意思是**让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。**示例如下：\n\nvolatile  bool bStop=false;  //bStop 为共享全局变量  \n//第一个线程\nvoid threadFunc1()\n{\n    ...\n    while(!bStop){...}\n}\n//第二个线程终止上面的线程循环\nvoid threadFunc2()\n{\n    ...\n    bStop = true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n要想通过第二个线程终止第一个线程循环，如果bStop不使用volatile定义，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。\n\n是否了解volatile的应用场景是区分C/C++程序员和嵌入式开发程序员的有效办法，搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，这些都要求用到volatile变量，不懂得volatile将会带来程序设计的灾难。\n\n\n# 3.volatile常见问题\n\n下面的问题可以看一下面试者是不是直正了解volatile。\n\n（1）一个参数既可以是const还可以是volatile吗？为什么？ 可以。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。\n\n（2）一个指针可以是volatile吗？为什么？ 可以。尽管这并不常见。一个例子是当一个中断服务子程序修该一个指向一个buffer的指针时。\n\n（3）下面的函数有什么错误？\n\nint square(volatile int *ptr) \n{ \n\treturn *ptr * *ptr; \n} \n\n\n1\n2\n3\n4\n\n\n这段代码有点变态，其目的是用来返回指针ptr指向值的平方，但是，由于ptr指向一个volatile型参数，编译器将产生类似下面的代码：\n\nint square(volatile int *ptr) \n{ \nint a,b; \na = *ptr; \nb = *ptr; \nreturn a * b; \n} \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于*ptr的值可能被意想不到地改变，因此a和b可能是不同的。结果，这段代码可能返回的不是你所期望的平方值！正确的代码如下：\n\nlong square(volatile int *ptr) \n{ \nint a=*ptr; \nreturn a * a; \n} \n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.volatile使用\n\n * volatile 关键字是一种类型修饰，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。\n * volatile 关键字声明的变量，每次访问时都必须从memory中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU register中取值）\n * const 可以是 volatile （如只读的状态寄存器）\n * 指针也可以是 volatile",normalizedContent:"被 volatile 修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。而这些可观测的副作用，是由程序之外的因素决定的。\n\n\n# volatile应用\n\n（1）并行设备的硬件寄存器（如状态寄存器）。 假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。\n\nint  *output = (unsigned  int *)0xff800000; //定义一个io端口；  \nint   init(void)  \n{  \n    int i;  \n    for(i=0;i< 10;i++)\n    {  \n       *output = i;  \n    } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为 9，所以编译器最后给你编译编译的代码结果相当于：\n\nint  init(void)  \n{  \n    *output = 9;  \n}\n\n\n1\n2\n3\n4\n\n\n如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。\n\n（2）一个中断服务子程序中访问到的变量；\n\nstatic int i=0;\n\nint main()\n{\n    while(1)\n    {\n    \tif(i) do_something();\n    }\n}\n\n/* interrupt service routine */\nvoid irs()\n{\n\ti=1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面示例程序的本意是产生中断时，由中断服务子程序irs响应中断，变更程序变量i，使在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远不会被调用。如果将变量i加上volatile修饰，则编译器保证对变量i的读写操作都不会被优化，从而保证了变量i被外部程序更改后能及时在原程序中得到感知。\n\n（3）多线程应用中被多个任务共享的变量。 当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。作用是防止编译器优化把变量从内存装入cpu寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。volatile的意思是**让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。**示例如下：\n\nvolatile  bool bstop=false;  //bstop 为共享全局变量  \n//第一个线程\nvoid threadfunc1()\n{\n    ...\n    while(!bstop){...}\n}\n//第二个线程终止上面的线程循环\nvoid threadfunc2()\n{\n    ...\n    bstop = true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n要想通过第二个线程终止第一个线程循环，如果bstop不使用volatile定义，那么这个循环将是一个死循环，因为bstop已经读取到了寄存器中，寄存器中bstop的值永远不会变成false，加上volatile，程序在执行时，每次均从内存中读出bstop的值，就不会死循环了。\n\n是否了解volatile的应用场景是区分c/c++程序员和嵌入式开发程序员的有效办法，搞嵌入式的家伙们经常同硬件、中断、rtos等等打交道，这些都要求用到volatile变量，不懂得volatile将会带来程序设计的灾难。\n\n\n# 3.volatile常见问题\n\n下面的问题可以看一下面试者是不是直正了解volatile。\n\n（1）一个参数既可以是const还可以是volatile吗？为什么？ 可以。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。\n\n（2）一个指针可以是volatile吗？为什么？ 可以。尽管这并不常见。一个例子是当一个中断服务子程序修该一个指向一个buffer的指针时。\n\n（3）下面的函数有什么错误？\n\nint square(volatile int *ptr) \n{ \n\treturn *ptr * *ptr; \n} \n\n\n1\n2\n3\n4\n\n\n这段代码有点变态，其目的是用来返回指针ptr指向值的平方，但是，由于ptr指向一个volatile型参数，编译器将产生类似下面的代码：\n\nint square(volatile int *ptr) \n{ \nint a,b; \na = *ptr; \nb = *ptr; \nreturn a * b; \n} \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于*ptr的值可能被意想不到地改变，因此a和b可能是不同的。结果，这段代码可能返回的不是你所期望的平方值！正确的代码如下：\n\nlong square(volatile int *ptr) \n{ \nint a=*ptr; \nreturn a * a; \n} \n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.volatile使用\n\n * volatile 关键字是一种类型修饰，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。\n * volatile 关键字声明的变量，每次访问时都必须从memory中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 cpu register中取值）\n * const 可以是 volatile （如只读的状态寄存器）\n * 指针也可以是 volatile",charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"assert",frontmatter:{title:"assert",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/efbaf4/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/10.assert.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/10.assert.md",key:"v-38c4d983",path:"/pages/efbaf4/",headers:[{level:2,title:"2.assert与正常错误处理",slug:"_2-assert与正常错误处理",normalizedTitle:"2.assert与正常错误处理",charIndex:609}],headersStr:"2.assert与正常错误处理",content:"断言，是宏，而非函数。\n\nassert 宏的原型定义在 <assert.h>（C）（C++）中。其作用是如果它的条件返回错误，则终止程序执行。\n\nvoid assert(int expression);\n\n\n1\n\n\n可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include <assert.h> 之前。\n\n#include <stdio.h> \n#include <assert.h> \n\nint main() \n{ \n    int x = 7; \n\n    /*  Some big code in between and let's say x  \n    is accidentally changed to 9  */\n    x = 9; \n\n    // Programmer assumes x to be 7 in rest of the code \n    assert(x==7); \n\n    /* Rest of the code */\n\n    return 0; \n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n输出：\n\nassert: assert.c:13: main: Assertion 'x==7' failed.\n\n\n1\n\n\n可以看到输出会把源码文件，行号错误位置，提示出来！\n\n\n# 2.assert与正常错误处理\n\n * assert主要用于检查逻辑上不可能的情况。\n\n> 例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。与正常的错误处理不同，断言通常在运行时被禁用。\n\n * 忽略断言，在代码开头加上：\n\n#define NDEBUG          // 加上这行，则 assert 不可用\n\n\n1\n",normalizedContent:"断言，是宏，而非函数。\n\nassert 宏的原型定义在 <assert.h>（c）（c++）中。其作用是如果它的条件返回错误，则终止程序执行。\n\nvoid assert(int expression);\n\n\n1\n\n\n可以通过定义 ndebug 来关闭 assert，但是需要在源代码的开头，include <assert.h> 之前。\n\n#include <stdio.h> \n#include <assert.h> \n\nint main() \n{ \n    int x = 7; \n\n    /*  some big code in between and let's say x  \n    is accidentally changed to 9  */\n    x = 9; \n\n    // programmer assumes x to be 7 in rest of the code \n    assert(x==7); \n\n    /* rest of the code */\n\n    return 0; \n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n输出：\n\nassert: assert.c:13: main: assertion 'x==7' failed.\n\n\n1\n\n\n可以看到输出会把源码文件，行号错误位置，提示出来！\n\n\n# 2.assert与正常错误处理\n\n * assert主要用于检查逻辑上不可能的情况。\n\n> 例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。与正常的错误处理不同，断言通常在运行时被禁用。\n\n * 忽略断言，在代码开头加上：\n\n#define ndebug          // 加上这行，则 assert 不可用\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"void",frontmatter:{title:"void",date:"2021-08-06T00:00:00.000Z",categories:["coding"],tags:["C++"],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/b4d0b6/"},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/11.void.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/11.void.md",key:"v-808e1b3a",path:"/pages/b4d0b6/",headers:[{level:2,title:"Functions that do not return a value  : void add ( int a, int b )",slug:"functions-that-do-not-return-a-value-void-add-int-a-int-b",normalizedTitle:"functions that do not return a value  : void add ( int a, int b )",charIndex:null},{level:2,title:"Functions that do not take parameters : void add ( void )",slug:"functions-that-do-not-take-parameters-void-add-void",normalizedTitle:"functions that do not take parameters : void add ( void )",charIndex:636},{level:2,title:"void pointer (generic pointer)： void *",slug:"void-pointer-generic-pointer-void",normalizedTitle:"void pointer (generic pointer)： void *",charIndex:938},{level:2,title:"void不是一个真实的变量",slug:"void不是一个真实的变量",normalizedTitle:"void不是一个真实的变量",charIndex:2910},{level:2,title:"Extra：",slug:"extra",normalizedTitle:"extra：",charIndex:3426}],excerpt:"<p>void关键字的三个use case， 和一个注意的tips</p>\n",headersStr:"Functions that do not return a value  : void add ( int a, int b ) Functions that do not take parameters : void add ( void ) void pointer (generic pointer)： void * void不是一个真实的变量 Extra：",content:"void关键字的三个use case， 和一个注意的tips\n\n\n# **Functions that do not return a value ** : void add ( int a, int b )\n\n在C语言中，不加返回值类型限定的函数，就会被编译器作为返回整型值处理。但是很多人却误以为其为void类型。例如：\n\nadd ( int a, int b )\n{\n    return a + b;\n}\n\nint main(int argc, char* argv[])\n{\n    printf ( \"2 + 3 = %d\", add ( 2, 3) );\n}\n\nvoid noReturn(int x) // void here means no return value\n{\n    return 5; // error\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n程序运行的结果为输出：2 + 3 = 5， 这说明在C语言中不加返回值说明的函数的确为int函数。\n\nC++ 会有严格的类型检查， 对于任何函数都要指定其类型。如果函数没有返回值，一定要声明为void类型。另外，加上void类型声明后，也可以发挥代码的“自注释”作用。代码的“自注释”即代码能自己注释自己。\n\nvoid add ( int a, int b )\n{\n    int c;\n    c = a + b;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# Functions that do not take parameters : void add ( void )\n\n如果函数不接受任何参数， 可以在函数声明时候的参数列表里面写上void\n\nvoid add ( void )\n{\n    // some system configuration  ...\n}\n\n// or : \nint getValue(void) // void here means no parameters\n{\n    int x{};\n    std::cin >> x;\n    return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# void pointer (generic pointer)： void *\n\n如果函数的参数可以是任意类型指针，那么应声明其参数为void *， 注意两点：\n\n 1. void＊是一种特殊的指针类型，可存放任意对象的地址，但我们对该地址中到底是什么类型的对象并不了解。\n 2. 不能直接操作void＊指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。\n\n// void* 可以存放任意对象的地址， \nint nValue;\nfloat fValue;\n\nstruct Something\n{\n    int n;\n    float f;\n};\n\nSomething sValue;\n\nvoid* ptr;\nptr = &nValue; // valid\nptr = &fValue; // valid\nptr = &sValue; // valid\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n// 但是void*必须进行强制转换之后才能够对齐进行操作\nint value{ 5 };\nvoid* voidPtr{ &value };\n\n// std::cout << *voidPtr << '\\n'; // illegal: dereference of void pointer\n\nint* intPtr{ static_cast<int*>(voidPtr) }; // however, if we cast our void pointer to an int pointer...\n\nstd::cout << *intPtr << '\\n'; // then we can dereference the result\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如内存操作函数memcpy和memset的函数原型分别为：\n\nvoid * memcpy(void *dest, const void *src, size_t len);\n\nvoid * memset ( void * buffer, int c, size_t num );\n\n\n1\n2\n3\n\n\n这样，任何类型的指针都可以传入memcpy和memset中，也体现了内存操作函数的意义，因为它操作的对象是一片内存，而不在乎这片内存是什么类型\n\n下面的代码执行正确：\n\n//示例：memset接受任意类型指针\nint intarray[100];\nmemset(intarray, 0, 100*sizeof(int)); //将intarray清0\n\n//示例：memcpy接受任意类型指针\nint intarray1[100], intarray2[100];\nmemcpy(intarray1, intarray2, 100*sizeof(int)); //将intarray2拷贝给intarray1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n并且memcpy和memset函数返回的也是void *类型， 代表一个任意类型的指针\n\n----------------------------------------\n\n按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即下列操作都是不合法的：\n\nvoid* pvoid;\npvoid++; //ANSI：错误\npvoid += 1; //ANSI：错误\n//ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。\n\n//例如：\nint *pint;\npint++; //ANSI：正确     pint++的结果是使其增大sizeof(int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n但是GNU(GNU's Not Unix的缩写)则指定void *的算法操作与char *一致。因此下列语句在GNU编译器中也是正确的：\n\npvoid++;    //GNU：正确\npvoid += 1; //GNU：正确void++的执行结果是其增大了1\n\n// 在实际的程序设计中，为迎合ANSI标准，并提高程序的可移植性，我们可以这样实现：\nvoid * pvoid;\n(char *)pvoid++;    //ANSI：正确；GNU：正确\n(char *)pvoid += 1; //ANSI：错误；GNU：正确\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nGNU和ANSI还有一些区别，总体而言，GNU较ANSI更“开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地匹配ANSI标准。\n\n\n# void不是一个真实的变量\n\n下面代码都企图让void代表一个真实的变量，因此都是错误的代码：\n\nvoid a; //错误\nfunction(void a); //错误\n\n\n1\n2\n\n\n如果指针p1和p2的类型相同，那么我们可以直接在p1和p2间互相赋值；如果p1和p2指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。 例如：\n\nfloat *p1;\nint *p2;\np1 = p2; // error! cannot convert from 'int *' to 'float *'”\n\n\n1\n2\n3\n\n\n必须改为：\n\np1 = (float *)p2;\n\n\n1\n\n\n但是任何类型的指针都可以直接赋值给void *，无需进行类型转换（反之不成立）：\n\nvoid *p1;\nint *p2;\np1 = p2;\n\n\n1\n2\n3\n\n\nvoid *则必须进行类型转换， 然后再赋给其它类型的指针。下面这样则会出错：\n\nvoid *p1;\nint *p2;\np2 = p1; // cannot convert from 'void *' to 'int *'\n\n\n1\n2\n3\n\n\n\n# Extra：\n\n对于好的编程习惯来说，declare一个指针，则初始化为NULL，如果是类成员 则在构造函数中initialize，当对指针使用delete时候，则置它为NULL.",normalizedContent:"void关键字的三个use case， 和一个注意的tips\n\n\n# **functions that do not return a value ** : void add ( int a, int b )\n\n在c语言中，不加返回值类型限定的函数，就会被编译器作为返回整型值处理。但是很多人却误以为其为void类型。例如：\n\nadd ( int a, int b )\n{\n    return a + b;\n}\n\nint main(int argc, char* argv[])\n{\n    printf ( \"2 + 3 = %d\", add ( 2, 3) );\n}\n\nvoid noreturn(int x) // void here means no return value\n{\n    return 5; // error\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n程序运行的结果为输出：2 + 3 = 5， 这说明在c语言中不加返回值说明的函数的确为int函数。\n\nc++ 会有严格的类型检查， 对于任何函数都要指定其类型。如果函数没有返回值，一定要声明为void类型。另外，加上void类型声明后，也可以发挥代码的“自注释”作用。代码的“自注释”即代码能自己注释自己。\n\nvoid add ( int a, int b )\n{\n    int c;\n    c = a + b;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# functions that do not take parameters : void add ( void )\n\n如果函数不接受任何参数， 可以在函数声明时候的参数列表里面写上void\n\nvoid add ( void )\n{\n    // some system configuration  ...\n}\n\n// or : \nint getvalue(void) // void here means no parameters\n{\n    int x{};\n    std::cin >> x;\n    return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# void pointer (generic pointer)： void *\n\n如果函数的参数可以是任意类型指针，那么应声明其参数为void *， 注意两点：\n\n 1. void＊是一种特殊的指针类型，可存放任意对象的地址，但我们对该地址中到底是什么类型的对象并不了解。\n 2. 不能直接操作void＊指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。\n\n// void* 可以存放任意对象的地址， \nint nvalue;\nfloat fvalue;\n\nstruct something\n{\n    int n;\n    float f;\n};\n\nsomething svalue;\n\nvoid* ptr;\nptr = &nvalue; // valid\nptr = &fvalue; // valid\nptr = &svalue; // valid\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n// 但是void*必须进行强制转换之后才能够对齐进行操作\nint value{ 5 };\nvoid* voidptr{ &value };\n\n// std::cout << *voidptr << '\\n'; // illegal: dereference of void pointer\n\nint* intptr{ static_cast<int*>(voidptr) }; // however, if we cast our void pointer to an int pointer...\n\nstd::cout << *intptr << '\\n'; // then we can dereference the result\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如内存操作函数memcpy和memset的函数原型分别为：\n\nvoid * memcpy(void *dest, const void *src, size_t len);\n\nvoid * memset ( void * buffer, int c, size_t num );\n\n\n1\n2\n3\n\n\n这样，任何类型的指针都可以传入memcpy和memset中，也体现了内存操作函数的意义，因为它操作的对象是一片内存，而不在乎这片内存是什么类型\n\n下面的代码执行正确：\n\n//示例：memset接受任意类型指针\nint intarray[100];\nmemset(intarray, 0, 100*sizeof(int)); //将intarray清0\n\n//示例：memcpy接受任意类型指针\nint intarray1[100], intarray2[100];\nmemcpy(intarray1, intarray2, 100*sizeof(int)); //将intarray2拷贝给intarray1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n并且memcpy和memset函数返回的也是void *类型， 代表一个任意类型的指针\n\n----------------------------------------\n\n按照ansi(american national standards institute)标准，不能对void指针进行算法操作，即下列操作都是不合法的：\n\nvoid* pvoid;\npvoid++; //ansi：错误\npvoid += 1; //ansi：错误\n//ansi标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。\n\n//例如：\nint *pint;\npint++; //ansi：正确     pint++的结果是使其增大sizeof(int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n但是gnu(gnu's not unix的缩写)则指定void *的算法操作与char *一致。因此下列语句在gnu编译器中也是正确的：\n\npvoid++;    //gnu：正确\npvoid += 1; //gnu：正确void++的执行结果是其增大了1\n\n// 在实际的程序设计中，为迎合ansi标准，并提高程序的可移植性，我们可以这样实现：\nvoid * pvoid;\n(char *)pvoid++;    //ansi：正确；gnu：正确\n(char *)pvoid += 1; //ansi：错误；gnu：正确\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ngnu和ansi还有一些区别，总体而言，gnu较ansi更“开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地匹配ansi标准。\n\n\n# void不是一个真实的变量\n\n下面代码都企图让void代表一个真实的变量，因此都是错误的代码：\n\nvoid a; //错误\nfunction(void a); //错误\n\n\n1\n2\n\n\n如果指针p1和p2的类型相同，那么我们可以直接在p1和p2间互相赋值；如果p1和p2指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。 例如：\n\nfloat *p1;\nint *p2;\np1 = p2; // error! cannot convert from 'int *' to 'float *'”\n\n\n1\n2\n3\n\n\n必须改为：\n\np1 = (float *)p2;\n\n\n1\n\n\n但是任何类型的指针都可以直接赋值给void *，无需进行类型转换（反之不成立）：\n\nvoid *p1;\nint *p2;\np1 = p2;\n\n\n1\n2\n3\n\n\nvoid *则必须进行类型转换， 然后再赋给其它类型的指针。下面这样则会出错：\n\nvoid *p1;\nint *p2;\np2 = p1; // cannot convert from 'void *' to 'int *'\n\n\n1\n2\n3\n\n\n\n# extra：\n\n对于好的编程习惯来说，declare一个指针，则初始化为null，如果是类成员 则在构造函数中initialize，当对指针使用delete时候，则置它为null.",charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"inline",frontmatter:{title:"inline",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/91242f/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/09.inline.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/09.inline.md",key:"v-0eba4323",path:"/pages/91242f/",headers:[{level:2,title:"Why?",slug:"why",normalizedTitle:"why?",charIndex:41},{level:2,title:"What?",slug:"what",normalizedTitle:"what?",charIndex:623},{level:2,title:"How?",slug:"how",normalizedTitle:"how?",charIndex:678},{level:3,title:"类中内联",slug:"类中内联",normalizedTitle:"类中内联",charIndex:687},{level:3,title:"函数内联",slug:"函数内联",normalizedTitle:"函数内联",charIndex:1065},{level:3,title:"虚函数内联",slug:"虚函数内联",normalizedTitle:"虚函数内联",charIndex:1677},{level:2,title:"Tips:",slug:"tips",normalizedTitle:"tips:",charIndex:2716}],headersStr:"Why? What? How? 类中内联 函数内联 虚函数内联 Tips:",content:'inline关键字的含义， 用法以及compiler对inline的处理\n\n\n# Why?\n\n在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。\n\n栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。\n\n在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。\n\n#include <stdio.h>\n \ninline const char *num_check(int v)\n{\n    return (v % 2 > 0) ? "奇" : "偶";\n}\n \nint main(void)\n{\n    int i;\n    for (i = 0; i < 100; i++)\n        printf("%02d   %s\\n", i, num_check(i));\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面的例子就是标准的内联函数的用法，使用 inline 修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个 for 循环的内部任何调用 *dbtest(i)* 的地方都换成了 *(i%2>0)?"奇":"偶"*，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。\n\n\n# What?\n\n使用场景： 函数非常短小而且在很多地方都被调用的时候， 但是会使得可执行体的体积增大。\n\n\n# How?\n\n\n# 类中内联\n\n写在类中的函数自动内联\n\nclass A\n{\n    public:\n    \tvoid f1(int x); \n\n        /**\n       * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。\n       *\n       * @param x\n       * @param y\n       */\n        void Foo(int x,int y) ///< 定义即隐式内联函数！\n        {\n\n        };\n        void f1(int x); ///< 声明后，要想成为内联函数，必须在定义处加inline关键字。 \n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 函数内联\n\n类外的函数需要加inline关键字\n\n#include <iostream>\n#include "inline.h"\nusing namespace std;\n/**\n * @brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字”\n */\nint Foo(int x,int y); // 函数声明\ninline int Foo(int x,int y) // 函数定义\n{\n  return x+y;\n}\n \n// 定义处加inline关键字，推荐这种写法！\ninline void A::f1(int x) { }\n \nint main()\n{\n\tcout<<Foo(1,2)<<endl;\n}\n/**\n * 编译器对 inline 函数的处理步骤\n * 将 inline 函数体复制到 inline 函数调用点处；\n * 为所用 inline 函数中的局部变量分配内存空间；\n * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；\n * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 虚函数内联\n\n虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。\n\n内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。\n\ninline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。\n\n#include <iostream> \nusing namespace std;\nclass Base\n{\n    public:\n        inline virtual void who()\n        {\n            cout << "I am Base\\n";\n        }\n        virtual ~Base() {}\n};\nclass Derived : public Base\n{\n    public:\n        inline void who() // 不写inline时隐式内联\n        {\n            cout << "I am Derived\\n";\n        }\n};\n\nint main()\n{\n    // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 \n    Base b;\n    b.who();\n\n    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。 \n    Base *ptr = new Derived();\n    ptr->who();\n\n    // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。\n    delete ptr;\n    ptr = nullptr;\n\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# Tips:\n\n 1. inline 的使用是有所限制的，inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。\n\n 2. inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。\n\n 3. 因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。所以，这要求每个调用了内联函数的文件都出现了该内联函数的定义。因此，将内联函数的定义放在头文件里实现是合适的，省却你为每个文件实现一次的麻烦。\n\n 4. 声明跟定义要一致：如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为。如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。\n\n 5. 定义在类中的成员函数默认都是内联的，如果在类定义~时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline，否则就认为不是内联的。\n\n 6. inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前不起任何作用， 声明的时候不加inline， 定义的时候才加\n\ninline void Foo(int x, int y); // inline 仅与函数声明放在一起\nvoid Foo(int x, int y){}\nvoid Foo(int x, int y);\ninline void Foo(int x, int y) {} // inline 与函数定义体放在一起\n\n\n1\n2\n3\n4\n\n 7. 内联是以**代码膨胀（复制）**为代价，省去了函数调用的开销，从而提高函数的执行效率。 但如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，会消耗更多的内存空间。',normalizedContent:'inline关键字的含义， 用法以及compiler对inline的处理\n\n\n# why?\n\n在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。\n\n栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。\n\n在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。\n\n#include <stdio.h>\n \ninline const char *num_check(int v)\n{\n    return (v % 2 > 0) ? "奇" : "偶";\n}\n \nint main(void)\n{\n    int i;\n    for (i = 0; i < 100; i++)\n        printf("%02d   %s\\n", i, num_check(i));\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面的例子就是标准的内联函数的用法，使用 inline 修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个 for 循环的内部任何调用 *dbtest(i)* 的地方都换成了 *(i%2>0)?"奇":"偶"*，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。\n\n\n# what?\n\n使用场景： 函数非常短小而且在很多地方都被调用的时候， 但是会使得可执行体的体积增大。\n\n\n# how?\n\n\n# 类中内联\n\n写在类中的函数自动内联\n\nclass a\n{\n    public:\n    \tvoid f1(int x); \n\n        /**\n       * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。\n       *\n       * @param x\n       * @param y\n       */\n        void foo(int x,int y) ///< 定义即隐式内联函数！\n        {\n\n        };\n        void f1(int x); ///< 声明后，要想成为内联函数，必须在定义处加inline关键字。 \n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 函数内联\n\n类外的函数需要加inline关键字\n\n#include <iostream>\n#include "inline.h"\nusing namespace std;\n/**\n * @brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字”\n */\nint foo(int x,int y); // 函数声明\ninline int foo(int x,int y) // 函数定义\n{\n  return x+y;\n}\n \n// 定义处加inline关键字，推荐这种写法！\ninline void a::f1(int x) { }\n \nint main()\n{\n\tcout<<foo(1,2)<<endl;\n}\n/**\n * 编译器对 inline 函数的处理步骤\n * 将 inline 函数体复制到 inline 函数调用点处；\n * 为所用 inline 函数中的局部变量分配内存空间；\n * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；\n * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 goto）。\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 虚函数内联\n\n虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。\n\n内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。\n\ninline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。\n\n#include <iostream> \nusing namespace std;\nclass base\n{\n    public:\n        inline virtual void who()\n        {\n            cout << "i am base\\n";\n        }\n        virtual ~base() {}\n};\nclass derived : public base\n{\n    public:\n        inline void who() // 不写inline时隐式内联\n        {\n            cout << "i am derived\\n";\n        }\n};\n\nint main()\n{\n    // 此处的虚函数 who()，是通过类（base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 \n    base b;\n    b.who();\n\n    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。 \n    base *ptr = new derived();\n    ptr->who();\n\n    // 因为base有虚析构函数（virtual ~base() {}），所以 delete 时，会先调用派生类（derived）析构函数，再调用基类（base）析构函数，防止内存泄漏。\n    delete ptr;\n    ptr = nullptr;\n\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# tips:\n\n 1. inline 的使用是有所限制的，inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。\n\n 2. inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。\n\n 3. 因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。所以，这要求每个调用了内联函数的文件都出现了该内联函数的定义。因此，将内联函数的定义放在头文件里实现是合适的，省却你为每个文件实现一次的麻烦。\n\n 4. 声明跟定义要一致：如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为。如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。\n\n 5. 定义在类中的成员函数默认都是内联的，如果在类定义~时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline，否则就认为不是内联的。\n\n 6. inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前不起任何作用， 声明的时候不加inline， 定义的时候才加\n\ninline void foo(int x, int y); // inline 仅与函数声明放在一起\nvoid foo(int x, int y){}\nvoid foo(int x, int y);\ninline void foo(int x, int y) {} // inline 与函数定义体放在一起\n\n\n1\n2\n3\n4\n\n 7. 内联是以**代码膨胀（复制）**为代价，省去了函数调用的开销，从而提高函数的执行效率。 但如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，会消耗更多的内存空间。',charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"_global_",frontmatter:{title:"__global__",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/fc5419/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/12.__global__.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/12.__global__.md",key:"v-19e58c3a",path:"/pages/fc5419/",excerpt:"<p>_<em>global_</em> 关键字的含义， 用法以及在编译的时候是如何进行链接的</p>\n",headersStr:null,content:"_global_ 关键字的含义， 用法以及在编译的时候是如何进行链接的\n\n\n\n\n1\n",normalizedContent:"_global_ 关键字的含义， 用法以及在编译的时候是如何进行链接的\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"Comming soon",frontmatter:{pageClass:"diary",title:"Comming soon",date:"2022-06-27T07:53:54.000Z",categories:["Wiki","Performance"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/wiki/Performance_Engineering/"},regularPath:"/01.Wiki/02.Performance%20Engineering/01.Perf.html",relativePath:"01.Wiki/02.Performance Engineering/01.Perf.md",key:"v-448f6e72",path:"/wiki/Performance_Engineering/",headers:[{level:3,title:"Ongoing",slug:"ongoing",normalizedTitle:"ongoing",charIndex:2}],headersStr:"Ongoing",content:"# Ongoing",normalizedContent:"# ongoing",charsets:{},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"Chrome 非常规操作",frontmatter:{pageClass:"diary",title:"Chrome 非常规操作",date:"2022-06-27T07:53:54.000Z",permalink:"/pages/41a6c9/",categories:["Wiki","misc"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/10.Misc/01.Chrome.html",relativePath:"01.Wiki/10.Misc/01.Chrome.md",key:"v-acc65afa",path:"/pages/41a6c9/",headers:[{level:3,title:"长页面截图",slug:"长页面截图",normalizedTitle:"长页面截图",charIndex:2},{level:3,title:"常用插件",slug:"常用插件",normalizedTitle:"常用插件",charIndex:91},{level:3,title:"调试动画",slug:"调试动画",normalizedTitle:"调试动画",charIndex:277},{level:3,title:"编辑页面上的任意文本",slug:"编辑页面上的任意文本",normalizedTitle:"编辑页面上的任意文本",charIndex:364}],headersStr:"长页面截图 常用插件 调试动画 编辑页面上的任意文本",content:"# 长页面截图\n\n1.打开F12\n2.按Ctrl + Shift + P\n3.输入full size screenshot\n4.回车\n5.保存截图\n\n\n1\n2\n3\n4\n5\n\n\n\n# 常用插件\n\nVue.js devtools\nWEB前端助手(FeHelper)\nReact Developer Tools\nAdblock Plus\nColorPick Eyedropper\nPage Ruler\nImagus(页面放大图片查看)\nproject-naptha(图片提取文字)\nOctotree(在线资源管理器的方式阅读GitHub仓库的代码)\n\n\n\n# 调试动画\n\n1.打开F12\n2.找Animations选项卡\n3.若没有，则点击右上角三点 -> More Tools -> Animations\n\n\n1\n2\n3\n\n\n\n# 编辑页面上的任意文本\n\n1.打开F12\n2.在控制台输入 document.body.contentEditable=\"true\" 或 document.designMode = 'on'\n3.实现对网页的编辑\n\n\n1\n2\n3\n",normalizedContent:"# 长页面截图\n\n1.打开f12\n2.按ctrl + shift + p\n3.输入full size screenshot\n4.回车\n5.保存截图\n\n\n1\n2\n3\n4\n5\n\n\n\n# 常用插件\n\nvue.js devtools\nweb前端助手(fehelper)\nreact developer tools\nadblock plus\ncolorpick eyedropper\npage ruler\nimagus(页面放大图片查看)\nproject-naptha(图片提取文字)\noctotree(在线资源管理器的方式阅读github仓库的代码)\n\n\n\n# 调试动画\n\n1.打开f12\n2.找animations选项卡\n3.若没有，则点击右上角三点 -> more tools -> animations\n\n\n1\n2\n3\n\n\n\n# 编辑页面上的任意文本\n\n1.打开f12\n2.在控制台输入 document.body.contenteditable=\"true\" 或 document.designmode = 'on'\n3.实现对网页的编辑\n\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"VsCode 常用插件",frontmatter:{pageClass:"diary",title:"VsCode 常用插件",date:"2022-06-27T07:53:54.000Z",permalink:"/pages/6f0fa2/",categories:["Wiki","misc"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/10.Misc/02.VsCode.html",relativePath:"01.Wiki/10.Misc/02.VsCode.md",key:"v-3cdd7c23",path:"/pages/6f0fa2/",headers:[{level:3,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:3,title:"前端",slug:"前端",normalizedTitle:"前端",charIndex:192},{level:3,title:"Git",slug:"git",normalizedTitle:"git",charIndex:345}],headersStr:" 前端 Git",content:"#\n\nChinese (Simplified) Language Pack for Visual Studio Code - 中文（简体）语言包\nImport Cost - 导入文件大小\nvscode-fileheader - 自动记录文件修改时间 - CTRL+ALT+I\nvscode-icons - vscode风格文件icon\nBeautify - 自动格式化代码\n\n\n\n# 前端\n\nVetur\njavascript console utils - 快速console - CTRL+SHIFT+L\nLive Server - 静态网页开启服务\nopen in browser - 快速开启浏览器浏览网页 - ALT+B\nBetter Comments - 不同风格注释\n\n\n\n# Git\n\nGit History\n",normalizedContent:"#\n\nchinese (simplified) language pack for visual studio code - 中文（简体）语言包\nimport cost - 导入文件大小\nvscode-fileheader - 自动记录文件修改时间 - ctrl+alt+i\nvscode-icons - vscode风格文件icon\nbeautify - 自动格式化代码\n\n\n\n# 前端\n\nvetur\njavascript console utils - 快速console - ctrl+shift+l\nlive server - 静态网页开启服务\nopen in browser - 快速开启浏览器浏览网页 - alt+b\nbetter comments - 不同风格注释\n\n\n\n# git\n\ngit history\n",charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"《Effective C++》",frontmatter:{title:"《Effective C++》",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/fb2fc1/"},regularPath:"/01.Wiki/19.Reading%20Notes/01.Effective_C++.html",relativePath:"01.Wiki/19.Reading Notes/01.Effective_C++.md",key:"v-1595c540",path:"/pages/fb2fc1/",headers:[{level:2,title:"习惯C++",slug:"习惯c",normalizedTitle:"习惯c++",charIndex:20},{level:2,title:"构造，析构， 和重载赋值运算符",slug:"构造-析构-和重载赋值运算符",normalizedTitle:"构造，析构， 和重载赋值运算符",charIndex:1248},{level:2,title:"Resource Management， 资源管理",slug:"resource-management-资源管理",normalizedTitle:"resource management， 资源管理",charIndex:3576},{level:2,title:"Design and Declarations, 设计与声明",slug:"design-and-declarations-设计与声明",normalizedTitle:"design and declarations, 设计与声明",charIndex:5374},{level:2,title:"Implementations, 实现",slug:"implementations-实现",normalizedTitle:"implementations, 实现",charIndex:6379},{level:2,title:"继承与面向对象的设计",slug:"继承与面向对象的设计",normalizedTitle:"继承与面向对象的设计",charIndex:7264},{level:2,title:"模板，GP",slug:"模板-gp",normalizedTitle:"模板，gp",charIndex:9013},{level:2,title:"定制new和delete",slug:"定制new和delete",normalizedTitle:"定制new和delete",charIndex:9226},{level:2,title:"一些杂项",slug:"一些杂项",normalizedTitle:"一些杂项",charIndex:9415}],headersStr:"习惯C++ 构造，析构， 和重载赋值运算符 Resource Management， 资源管理 Design and Declarations, 设计与声明 Implementations, 实现 继承与面向对象的设计 模板，GP 定制new和delete 一些杂项",content:'# Effective C++\n\n\n# 习惯C++\n\n 1. C++是一个语言联邦， 有多种编程范式: procedural （面向过程）, OOP（面向对象）， GP（泛型编程）, Functional Programming（函数式编程），metaprograming(元编程），但差不多有四个主要的部分：\n    \n    1. C：数组， 指针， 预处理， 程序员的自我修养\n    2. Object oriented C++： classs, encapsulation, ingeritance, polymorphism, virtual function的动态绑定；（模板， 异常， 重载）\n    3. Template C++ (template metaprogramming, 模板元编程)\n    4. STL： container, iterator, algorithms, function objects\n\n 2. 用const， enum， inline来代替 #define\n\n 3. 该用const的地方，尽可能使用const\n    \n    函数的参数， 传引用的时候， 使用const修饰， 会明示参数是否被改变（引用不改变， 要加const表示出来）\n    \n    成员函数后是否要加const， 确定成员函数是否会修改类内的值，\n    \n    以及返回值是否要成为const（为什么？）， 返回值类型上不允许变动（避免成为左值被修改）\n    \n    a.get_data()=3;\n    \n    \n    1\n    \n\n 4. 对象在使用之前要初始化\n    \n    * 读取没有初始化的值， 导致不明确的行为， 变量里面包含的内容都是半随机状态\n    \n    * 在初始化列表里面， 列出所有的成员变量， 免得遗漏， 除非记得住哪些不用初始值；\n    \n    * 成员变量是const或者reference， 就一定要初始化， 因为后面不能再被赋值了；\n    \n    * 实在太多的话， 用一个private函数包一下能够赋值处理的， 也可以；\n    \n    * 初始化的顺序总是按照声明顺序来， 不是按照初始化列表的顺序\n    \n    * 如果有一个外部的static对象， 没有办法保证是否使用的时候已经初始化， 那就在本地搞一个static函数把这个对象包起来，返回一个指向这个对象的reference， 这样， 外部的static对象就变成了本地的static对象， 这也是singleton模式的一个常见实现手法（这种手法叫做reference returning）\n    \n    * 和more effective c++里面， 限制对象数目的方式， 好像是一样的\n    \n    * 任何一种non const static 对象，在多线程环境下， 都会有线程安全的问题；\n\n\n# 构造，析构， 和重载赋值运算符\n\n 5.  C++ 自动生成的构造，析构， 拷贝赋值函数（op=重载），(big three, 除此之外还有移动构造， 移动赋值， 不过这需要自己的写）\n     \n     1. 默认的构造， 析构函数， 只能是浅复制， 值的复制， 如果有指针， 只能指向同一个地址， 而不能有两份内存出来；\n     \n     2. 对const成员变量， reference变量， 自动生成的copy assignment是不能对这些东西进行赋值和拷贝操作的\n        \n        class Timekeeper{\n        public:\n        \tTimekeeper();\n        \tvirtual ~TimeKeeper();\n        }\n        \n        \n        1\n        2\n        3\n        4\n        5\n        \n     \n     3. 经验： class里面如果有一个virtual的函数， 就为这个类弄一个virtual的析构函数；\n     \n     4. 纯虚函数？纯虚函数会带来一个抽象基类， 抽象基类不能实例化；但是抽象基类也可以有一个纯虚的析构函数，需要单独提供一份定义；\n        \n        class AWOV(){\n        public:\n        \tvirtual ~AWOV() = 0;\n        }\n        \n        AMOV::~AMOV() { } // 单独提供一份定义\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        \n\n 6.  如何拒绝使用这些自动生成的函数，\n     \n     1. 使用=delete来禁止使用拷贝构造， 拷贝赋值，\n     2. 以前在没有=delete关键字的时候， 可以把这些函数放在private里面\n\n 7.  多态基类的析构函数最好弄成virtual的；\n     \n     1. 如果析构函数不是virtual的， 那么delete基类指针来进行析构的话。derived部分偶尔会被遗漏掉；\n     2. 为什么不是构造函数？因为我们构造的时候， 基本上都是用derived类来进行构造的；\n\n 8.  析构函数不要吐出异常（别让异常逃离析构函数）, 为什么?\n     \n     1. 如果不处理异常， 会带来一些不明确的行为\n     2. 如果吐出异常，可能会导致程序半路断掉；\n     3. 所以要好好善后；\n\n 9.  析构和构造函数中， 不要调用virtual函数， 为什么?\n     \n     1. 构造的时候， derived对象还没有生成， 所以这个时候还用不到自身特化的virtual function， 只能用base class里面的版本；\n     2. 析构的时候， 只要一开始析构， 对象内的derived class成员变量就是未定义值， 所以这个时候virtual function还是会跑到父类里面去；\n\n 10. operator= 最好是返回一个 reference to *this,\n     \n     1. 因为这样可以拥有连续赋值的特性， 例如： x = y = z = 15\n\n 11. operator=里面， 要判断是否是自我赋值；\n     \n     Widget& Widget::operator=(const Widget& rhs){\n     \tif(this == &rhs)\n             return *this;\n     \tdelete pb;\n     \tpb = new Bitmap(*rhs.pb);\n     \treturn *rhs;\t\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n\n 12. 自定义拷贝构造函数的时候， 要复制所有local的变量， 可以使用基类的一些拷贝构造函数对一些成员拷贝；\n     \n     因为有一些基类对象的拷贝， 必须要通过基类的拷贝构造函数来进行深度拷贝；\n     \n     PriorityCustomer::operator=(const PriorityCustomer &rhs){\n         logCall("......");\n         Customer::operator=(rhs); // 这里直接调用了base class的拷贝构造函数来进行；\n         priority = rhs.priority;\n         return *this;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n     \n     不要使用copy assignment 来调用copy constructor; 反过来也不建议， 因为都是针对没有构造好的对象进行操作；\n     \n     最终还是要将他么共同的一些实际操作放到函数里面， 因为只要使用上面两种函数， 都会要实现构造一个临时的对象， 但对象在这些函数运行过程中都是没有构造好的；\n\n\n# Resource Management， 资源管理\n\n 13. 用对象的形式管理资源 (RAII， Resource Acquisition Is Initialization)，所以要特别注意构造和析构函数，在使用对象的时候可以使用shared_ptr之类的智能指针来管理每个对象的实例；\n     \n     1. 返回没有加工的指针， 容易造成资源泄露， 忘记delete\n     2. 手动释放资源， 可能会跑不到释放的那个地方， 也有可能造成double release；\n     3. 不要多个auto_ptr()指向同一个对象， 不然对象可能会被多次删除， 程序就会有未定义行为；\n     4. copy assignment要让原来的指针变成null\n     5. 使用reference counting smart pointer, 使用shared_ptr()\n\n 14. 虽然都是RAII原则， 但是要特别注意拷贝构造的行为，书里面用linux中的mutex的lock和unlock函数来举了例子\n     \n     1. 要清楚自己做的是深拷贝还是浅拷贝，要确保自己是在做深拷贝， 不仅拷贝指针， 也拷贝指针所指的内存块；\n     2. 有时候拷贝其实是一种转移， 要确保系统中给目前只有者一个对象， 从一个地方转移到另外一个地方--\x3e auto_ptr\n     3. 自动生成的拷贝函数不一定能够满足需求；\n\n 15. 资源管理类中， 提供对原始资源的访问接口， 例如x.get， get_instance这种接口\n     \n     1. 返回数字，\n     \n     2. 返回一个instance\n     \n     3. singleton的设计模式是怎么做的?\n     \n     4. factory模式是怎么做的？\n     \n     5. 操作符重载\n        \n        class Font{\n        public:\n            operator FontHandle() const { //也可以重载类型转换函数；\n            \treturn f;\n            }\n        }\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        \n\n 16. new和delete使用的时候要成对使用， 并且注意区别数组和对象的delete\n     \n     * operator new, new operator的区别？\n     * placement new / new placement区别？\n     \n     std::string* stringPtr1 = new std::string;\n     std::string* stringPtr2 = new std::string[100];\n     \n     delete stringPtr1; // 删除一个对象， 一个指针；\n     delete [] stringPtr2; // 删除一个数组， 一块内存\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n 17. 以单独的一条语句把new出来的对象放到智能指针里面去， why?\n     \n     1. 要保证new这个语句是单独执行的， 先于智能指针的赋值操作；\n        \n        processWidget(std::tr1::shared_ptr<Widget>(new Widget), priority()); // 万一priority()这个函数执行异常会怎样？\n        \n        std::tr1::shared_ptr<Widget> pw(new Widget);\n        processWidget(pw, priority());\n        \n        \n        1\n        2\n        3\n        4\n        \n\n\n# Design and Declarations, 设计与声明\n\n 18. 接口设计简明， 不要让用户对其有歧义\n     \n     1. 建立新类型，限制类型上的操作， 束缚对象值，消除客户的资源管理责任\n     2. 好好设计程序的类型系统， 使用class， template， typedef， struct， enum等等\n\n 19. 设计class的时候， 就好比设计type（一系列要注意的事项）\n     \n     * 如何创建和销毁， operator new, operator new[]. operator delete, operator delete[],\n     * 对象初始化和对象的赋值有什么区别？ 拷贝构造， 和copy assignment之间有什么区别？ 。\n\n对一个新对象来说， pass by value意味着什么？因为要重载操作符， 函数， 和重载内存的分配和归还，\n\ntype cast的我呢提要怎么处理， 类型转换函数， operator T\n\n 20. 函数的参数使用pass by reference to const替换pass by value，（内置类型， 其实pass by value也比较合适）\n     \n     1. 效率会比较高\n\n 21. 如果必须返回一个对象， 不要返回他的reference，\n     \n     1. 因为可能会返回一个local的对象，local对象的renference是没有用的；\n\n 22. 成员变量声明为private\n     \n     1. 使用函数来对成员变量进行访问控制， 这样能够给类更好的封装性\n\n 23. 使用non member, non friend来替换member函数\n     \n     1. 为的是增加封装性， 增加扩充的弹性，\n     2. 可以把全局函数放在一个命名空间里面， 稍微约束一下它的作用域\n\n 24. 如果某个函数所有的参数都需要类型转换， 这个函数必须弄成non merber函数\n     \n     1. 【不是很懂， 需要接触一下模板相关的知识？】\n\n 25. 给自己的类写的swap函数，不要抛出异常， 这是为了和STL库一样支持swap的异常安全；\n     \n     1. friend可以方位private变量和函数；\n\n\n# Implementations, 实现\n\n 26. 延迟变量定义的出现时间， 尽量用到的时候再定义；\n\n 27. 少做cast转型动作， 即使要用也尽量使用C++自己的那四个转型\n     \n     * static_cast\n     \n     * const_cast\n     \n     * dynamic_cast\n     \n     * reinterpret_cast\n\n 28. 避免返回一个handler， 这个handler却有指向对象的内部成分，\n     \n     1. 避免返回的是一个空悬的指针；\n     2. 避免可以使用调用的操作来对函数内部的元素进行修改， 可以指定返回值是一个const， 这样用户就不能修改了；\n\n 29. 注意异常安全， （exceptional C++里面有很多异常安全的相关介绍）\n\n 30. 对inline的里里外外需要透彻了解；\n\n * 尽量inline， 也许compiler就能够执行context相关的inline优化；\n\n * 定义在类里面的函数， 自动inline\n\n * inline会让代码文件变大， 会导致更多的换页行为（paging），降低 i cache的命中率, 如果函数比较小， inline对 icache miss的影响会稍微比较小， 但是inline的函数比较大， 就有可能会得不偿失；\n\n * 虚函数的inline， 大多都不会生效\n\n * inline不仅会导致代码变大， 而且一旦inline的函数发生改变， 所有用到inline function的地方都要重新编译\n\n * template要尽量避免成为一个inline函数， 它的代价是很大的；\n\n 31. 尽量减少文件之间的编译依赖关系；不然修改之后编译， 会导致很多部件都一起编译了\n\n * 头文件应该仅有声明不要有定义；\n * 一般使用pointer to implementation 和纯虚函数的工厂方法来解决， 前者叫handle class, 后者叫interface class;\n\n\n# 继承与面向对象的设计\n\n 32. public继承的时候， 确认两个对象是 is a的关系；\n 33. 继承的时候，注意类内部的变量名称是否会被覆盖，\n\n * 即使是重载的函数，不管函数接口形式是否一样， 也会被子类的同名函数覆盖\n * 使用using Base::mf3() 可以指定在子类作用域范围里面使用base类的mf3函数，\n * 如果只想使用某一个mf3(), 只能是子类的函数里面， 再调用Base::mf3(); 美其名曰，forward functions;\n\n 34. 什么是接口继承和实现继承？\n     \n     1. pure virtual函数的目的就是接口继承， 但是也可以有一份基类实现，调用的时候只能通过子类指定父类名称的方式来调用（纯虚函数必须重写）；\n     2. 非纯虚函数是为了让子类继承接口 + 缺省实现， 这些都是自动继承的， 如果子类不override 虚函数的话（一般虚函数可以重写， 也可以不重写）；\n     3. 非虚函数的目的是强制让子类继承一个缺省的实现；（非虚函数，没有多态性，直接继承）\n     4. 接口和实现继承分开， 也就是把接口用一个纯虚函数来声明， 实现使用一个private或者protected的缺省实现来代替， 这样子类必须要重写纯虚函数，但是可以选择使用缺省的实现；\n     5. 也可以使用一个虚函数的非虚实现， 然后再在子类里面overide的时候调用这个函数；\n\n 35. 除了virtual函数之外，也可以考虑一下其他的选择\n     \n     1. 通过一个public函数， 调用自己的virtual函数， non-virtual interface（NVI）方法；（模板方法设计模式）\n     2. 借助funciion pointer实现strategy pattern\n     3. 使用各个库里面的function component， 例如std::function， 而且这个东西支持任何callable entities，包括运算符重载的struct和class\n     4. 标准设计模式， 古典的strategy模式， 就是使用pImple的方式来实现strategy， 来代替第一条里面的实现方式\n\n 36. 不要重新定义继承来的non virtual函数， 这其实是一种overloading， 并不能实现多态特性的overide， nonvirtual 函数其实是静态绑定的；virtual函数是动态绑定的\n\n 37. 不要重新定义继承来的缺省参数值， 因为可能会在调用子类的时候， 用到父类里面这个函数的默认值，（对于通过对象指针， 引用的方式都会有这个问题， 因为默认参数的绑定，是一种静态绑定），子类就声明参数就可以了， 不需要有默认值\n\n 38. 通过composition实现has a, 或者根据某物实现的关系\n\n 39. 谨慎使用private继承，\n     \n     1. 编译器不会把一个private继承的子类，自动转换成一个基类\n     2. private继承下来的所有成员， 在子类中都会变成private属性\n     3. protect继承\n        1. 默认的基本上都是public继承；\n        2. 尽可能使用compiosition， 必要的时候再使用private继承\n\n 40. 谨慎使用多重继承（子类从多个父类继承而来）\n     \n     1. 可能对导致对基类函数调用的歧义，到底调用的是哪一个基类的成员函数？\n     2. 钻石形继承， 二级基类可以是虚基类， 这样三级再继承的时候， 就不会重复出现两个爷爷类里面的成员函数了；\n     3. virtual继承会带来更多大小，速度，初始化的成本。如果非要有一个virtual base class， 最好不要在虚基类里面放置数据；\n     4. 有一种情况， 比较适合多重继承，public继承某个interface class， private继承某个协助实现的class；帮助子类实现某些功能。但是还是谨记第一条吧；\n\n\n# 模板，GP\n\n 41. 隐式接口和编译期多态\n 42. typename和class关键字， typename关键字的双重定义\n 43. 如何处理模板化基类的里面的名称\n 44. 参数无关的代码， 抽离template\n 45. 使用成员函数模板来接受所有兼容的类型\n 46. 需要类型转换的时候， 为模板定义一个非成员函数\n 47. 使用traits来表现模板里面的类型信息\n 48. 什么是template元编程\n\n\n# 定制new和delete\n\n 49. new handler的行为（处理new失败时候throw的异常）， 底层是怎样构成的？\n 50. operator new和operator delete的合理替换时机；\n 51. operator new和operator delete需要遵循的一些规则\n 52. placement new和placement delete\n\n\n# 一些杂项\n\n 53. 编译器的warnning有时候也很重要\n 54. 熟悉TR1标准库\n 55. 熟悉boost保准库',normalizedContent:'# effective c++\n\n\n# 习惯c++\n\n 1. c++是一个语言联邦， 有多种编程范式: procedural （面向过程）, oop（面向对象）， gp（泛型编程）, functional programming（函数式编程），metaprograming(元编程），但差不多有四个主要的部分：\n    \n    1. c：数组， 指针， 预处理， 程序员的自我修养\n    2. object oriented c++： classs, encapsulation, ingeritance, polymorphism, virtual function的动态绑定；（模板， 异常， 重载）\n    3. template c++ (template metaprogramming, 模板元编程)\n    4. stl： container, iterator, algorithms, function objects\n\n 2. 用const， enum， inline来代替 #define\n\n 3. 该用const的地方，尽可能使用const\n    \n    函数的参数， 传引用的时候， 使用const修饰， 会明示参数是否被改变（引用不改变， 要加const表示出来）\n    \n    成员函数后是否要加const， 确定成员函数是否会修改类内的值，\n    \n    以及返回值是否要成为const（为什么？）， 返回值类型上不允许变动（避免成为左值被修改）\n    \n    a.get_data()=3;\n    \n    \n    1\n    \n\n 4. 对象在使用之前要初始化\n    \n    * 读取没有初始化的值， 导致不明确的行为， 变量里面包含的内容都是半随机状态\n    \n    * 在初始化列表里面， 列出所有的成员变量， 免得遗漏， 除非记得住哪些不用初始值；\n    \n    * 成员变量是const或者reference， 就一定要初始化， 因为后面不能再被赋值了；\n    \n    * 实在太多的话， 用一个private函数包一下能够赋值处理的， 也可以；\n    \n    * 初始化的顺序总是按照声明顺序来， 不是按照初始化列表的顺序\n    \n    * 如果有一个外部的static对象， 没有办法保证是否使用的时候已经初始化， 那就在本地搞一个static函数把这个对象包起来，返回一个指向这个对象的reference， 这样， 外部的static对象就变成了本地的static对象， 这也是singleton模式的一个常见实现手法（这种手法叫做reference returning）\n    \n    * 和more effective c++里面， 限制对象数目的方式， 好像是一样的\n    \n    * 任何一种non const static 对象，在多线程环境下， 都会有线程安全的问题；\n\n\n# 构造，析构， 和重载赋值运算符\n\n 5.  c++ 自动生成的构造，析构， 拷贝赋值函数（op=重载），(big three, 除此之外还有移动构造， 移动赋值， 不过这需要自己的写）\n     \n     1. 默认的构造， 析构函数， 只能是浅复制， 值的复制， 如果有指针， 只能指向同一个地址， 而不能有两份内存出来；\n     \n     2. 对const成员变量， reference变量， 自动生成的copy assignment是不能对这些东西进行赋值和拷贝操作的\n        \n        class timekeeper{\n        public:\n        \ttimekeeper();\n        \tvirtual ~timekeeper();\n        }\n        \n        \n        1\n        2\n        3\n        4\n        5\n        \n     \n     3. 经验： class里面如果有一个virtual的函数， 就为这个类弄一个virtual的析构函数；\n     \n     4. 纯虚函数？纯虚函数会带来一个抽象基类， 抽象基类不能实例化；但是抽象基类也可以有一个纯虚的析构函数，需要单独提供一份定义；\n        \n        class awov(){\n        public:\n        \tvirtual ~awov() = 0;\n        }\n        \n        amov::~amov() { } // 单独提供一份定义\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        \n\n 6.  如何拒绝使用这些自动生成的函数，\n     \n     1. 使用=delete来禁止使用拷贝构造， 拷贝赋值，\n     2. 以前在没有=delete关键字的时候， 可以把这些函数放在private里面\n\n 7.  多态基类的析构函数最好弄成virtual的；\n     \n     1. 如果析构函数不是virtual的， 那么delete基类指针来进行析构的话。derived部分偶尔会被遗漏掉；\n     2. 为什么不是构造函数？因为我们构造的时候， 基本上都是用derived类来进行构造的；\n\n 8.  析构函数不要吐出异常（别让异常逃离析构函数）, 为什么?\n     \n     1. 如果不处理异常， 会带来一些不明确的行为\n     2. 如果吐出异常，可能会导致程序半路断掉；\n     3. 所以要好好善后；\n\n 9.  析构和构造函数中， 不要调用virtual函数， 为什么?\n     \n     1. 构造的时候， derived对象还没有生成， 所以这个时候还用不到自身特化的virtual function， 只能用base class里面的版本；\n     2. 析构的时候， 只要一开始析构， 对象内的derived class成员变量就是未定义值， 所以这个时候virtual function还是会跑到父类里面去；\n\n 10. operator= 最好是返回一个 reference to *this,\n     \n     1. 因为这样可以拥有连续赋值的特性， 例如： x = y = z = 15\n\n 11. operator=里面， 要判断是否是自我赋值；\n     \n     widget& widget::operator=(const widget& rhs){\n     \tif(this == &rhs)\n             return *this;\n     \tdelete pb;\n     \tpb = new bitmap(*rhs.pb);\n     \treturn *rhs;\t\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n\n 12. 自定义拷贝构造函数的时候， 要复制所有local的变量， 可以使用基类的一些拷贝构造函数对一些成员拷贝；\n     \n     因为有一些基类对象的拷贝， 必须要通过基类的拷贝构造函数来进行深度拷贝；\n     \n     prioritycustomer::operator=(const prioritycustomer &rhs){\n         logcall("......");\n         customer::operator=(rhs); // 这里直接调用了base class的拷贝构造函数来进行；\n         priority = rhs.priority;\n         return *this;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n     \n     不要使用copy assignment 来调用copy constructor; 反过来也不建议， 因为都是针对没有构造好的对象进行操作；\n     \n     最终还是要将他么共同的一些实际操作放到函数里面， 因为只要使用上面两种函数， 都会要实现构造一个临时的对象， 但对象在这些函数运行过程中都是没有构造好的；\n\n\n# resource management， 资源管理\n\n 13. 用对象的形式管理资源 (raii， resource acquisition is initialization)，所以要特别注意构造和析构函数，在使用对象的时候可以使用shared_ptr之类的智能指针来管理每个对象的实例；\n     \n     1. 返回没有加工的指针， 容易造成资源泄露， 忘记delete\n     2. 手动释放资源， 可能会跑不到释放的那个地方， 也有可能造成double release；\n     3. 不要多个auto_ptr()指向同一个对象， 不然对象可能会被多次删除， 程序就会有未定义行为；\n     4. copy assignment要让原来的指针变成null\n     5. 使用reference counting smart pointer, 使用shared_ptr()\n\n 14. 虽然都是raii原则， 但是要特别注意拷贝构造的行为，书里面用linux中的mutex的lock和unlock函数来举了例子\n     \n     1. 要清楚自己做的是深拷贝还是浅拷贝，要确保自己是在做深拷贝， 不仅拷贝指针， 也拷贝指针所指的内存块；\n     2. 有时候拷贝其实是一种转移， 要确保系统中给目前只有者一个对象， 从一个地方转移到另外一个地方--\x3e auto_ptr\n     3. 自动生成的拷贝函数不一定能够满足需求；\n\n 15. 资源管理类中， 提供对原始资源的访问接口， 例如x.get， get_instance这种接口\n     \n     1. 返回数字，\n     \n     2. 返回一个instance\n     \n     3. singleton的设计模式是怎么做的?\n     \n     4. factory模式是怎么做的？\n     \n     5. 操作符重载\n        \n        class font{\n        public:\n            operator fonthandle() const { //也可以重载类型转换函数；\n            \treturn f;\n            }\n        }\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        \n\n 16. new和delete使用的时候要成对使用， 并且注意区别数组和对象的delete\n     \n     * operator new, new operator的区别？\n     * placement new / new placement区别？\n     \n     std::string* stringptr1 = new std::string;\n     std::string* stringptr2 = new std::string[100];\n     \n     delete stringptr1; // 删除一个对象， 一个指针；\n     delete [] stringptr2; // 删除一个数组， 一块内存\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n 17. 以单独的一条语句把new出来的对象放到智能指针里面去， why?\n     \n     1. 要保证new这个语句是单独执行的， 先于智能指针的赋值操作；\n        \n        processwidget(std::tr1::shared_ptr<widget>(new widget), priority()); // 万一priority()这个函数执行异常会怎样？\n        \n        std::tr1::shared_ptr<widget> pw(new widget);\n        processwidget(pw, priority());\n        \n        \n        1\n        2\n        3\n        4\n        \n\n\n# design and declarations, 设计与声明\n\n 18. 接口设计简明， 不要让用户对其有歧义\n     \n     1. 建立新类型，限制类型上的操作， 束缚对象值，消除客户的资源管理责任\n     2. 好好设计程序的类型系统， 使用class， template， typedef， struct， enum等等\n\n 19. 设计class的时候， 就好比设计type（一系列要注意的事项）\n     \n     * 如何创建和销毁， operator new, operator new[]. operator delete, operator delete[],\n     * 对象初始化和对象的赋值有什么区别？ 拷贝构造， 和copy assignment之间有什么区别？ 。\n\n对一个新对象来说， pass by value意味着什么？因为要重载操作符， 函数， 和重载内存的分配和归还，\n\ntype cast的我呢提要怎么处理， 类型转换函数， operator t\n\n 20. 函数的参数使用pass by reference to const替换pass by value，（内置类型， 其实pass by value也比较合适）\n     \n     1. 效率会比较高\n\n 21. 如果必须返回一个对象， 不要返回他的reference，\n     \n     1. 因为可能会返回一个local的对象，local对象的renference是没有用的；\n\n 22. 成员变量声明为private\n     \n     1. 使用函数来对成员变量进行访问控制， 这样能够给类更好的封装性\n\n 23. 使用non member, non friend来替换member函数\n     \n     1. 为的是增加封装性， 增加扩充的弹性，\n     2. 可以把全局函数放在一个命名空间里面， 稍微约束一下它的作用域\n\n 24. 如果某个函数所有的参数都需要类型转换， 这个函数必须弄成non merber函数\n     \n     1. 【不是很懂， 需要接触一下模板相关的知识？】\n\n 25. 给自己的类写的swap函数，不要抛出异常， 这是为了和stl库一样支持swap的异常安全；\n     \n     1. friend可以方位private变量和函数；\n\n\n# implementations, 实现\n\n 26. 延迟变量定义的出现时间， 尽量用到的时候再定义；\n\n 27. 少做cast转型动作， 即使要用也尽量使用c++自己的那四个转型\n     \n     * static_cast\n     \n     * const_cast\n     \n     * dynamic_cast\n     \n     * reinterpret_cast\n\n 28. 避免返回一个handler， 这个handler却有指向对象的内部成分，\n     \n     1. 避免返回的是一个空悬的指针；\n     2. 避免可以使用调用的操作来对函数内部的元素进行修改， 可以指定返回值是一个const， 这样用户就不能修改了；\n\n 29. 注意异常安全， （exceptional c++里面有很多异常安全的相关介绍）\n\n 30. 对inline的里里外外需要透彻了解；\n\n * 尽量inline， 也许compiler就能够执行context相关的inline优化；\n\n * 定义在类里面的函数， 自动inline\n\n * inline会让代码文件变大， 会导致更多的换页行为（paging），降低 i cache的命中率, 如果函数比较小， inline对 icache miss的影响会稍微比较小， 但是inline的函数比较大， 就有可能会得不偿失；\n\n * 虚函数的inline， 大多都不会生效\n\n * inline不仅会导致代码变大， 而且一旦inline的函数发生改变， 所有用到inline function的地方都要重新编译\n\n * template要尽量避免成为一个inline函数， 它的代价是很大的；\n\n 31. 尽量减少文件之间的编译依赖关系；不然修改之后编译， 会导致很多部件都一起编译了\n\n * 头文件应该仅有声明不要有定义；\n * 一般使用pointer to implementation 和纯虚函数的工厂方法来解决， 前者叫handle class, 后者叫interface class;\n\n\n# 继承与面向对象的设计\n\n 32. public继承的时候， 确认两个对象是 is a的关系；\n 33. 继承的时候，注意类内部的变量名称是否会被覆盖，\n\n * 即使是重载的函数，不管函数接口形式是否一样， 也会被子类的同名函数覆盖\n * 使用using base::mf3() 可以指定在子类作用域范围里面使用base类的mf3函数，\n * 如果只想使用某一个mf3(), 只能是子类的函数里面， 再调用base::mf3(); 美其名曰，forward functions;\n\n 34. 什么是接口继承和实现继承？\n     \n     1. pure virtual函数的目的就是接口继承， 但是也可以有一份基类实现，调用的时候只能通过子类指定父类名称的方式来调用（纯虚函数必须重写）；\n     2. 非纯虚函数是为了让子类继承接口 + 缺省实现， 这些都是自动继承的， 如果子类不override 虚函数的话（一般虚函数可以重写， 也可以不重写）；\n     3. 非虚函数的目的是强制让子类继承一个缺省的实现；（非虚函数，没有多态性，直接继承）\n     4. 接口和实现继承分开， 也就是把接口用一个纯虚函数来声明， 实现使用一个private或者protected的缺省实现来代替， 这样子类必须要重写纯虚函数，但是可以选择使用缺省的实现；\n     5. 也可以使用一个虚函数的非虚实现， 然后再在子类里面overide的时候调用这个函数；\n\n 35. 除了virtual函数之外，也可以考虑一下其他的选择\n     \n     1. 通过一个public函数， 调用自己的virtual函数， non-virtual interface（nvi）方法；（模板方法设计模式）\n     2. 借助funciion pointer实现strategy pattern\n     3. 使用各个库里面的function component， 例如std::function， 而且这个东西支持任何callable entities，包括运算符重载的struct和class\n     4. 标准设计模式， 古典的strategy模式， 就是使用pimple的方式来实现strategy， 来代替第一条里面的实现方式\n\n 36. 不要重新定义继承来的non virtual函数， 这其实是一种overloading， 并不能实现多态特性的overide， nonvirtual 函数其实是静态绑定的；virtual函数是动态绑定的\n\n 37. 不要重新定义继承来的缺省参数值， 因为可能会在调用子类的时候， 用到父类里面这个函数的默认值，（对于通过对象指针， 引用的方式都会有这个问题， 因为默认参数的绑定，是一种静态绑定），子类就声明参数就可以了， 不需要有默认值\n\n 38. 通过composition实现has a, 或者根据某物实现的关系\n\n 39. 谨慎使用private继承，\n     \n     1. 编译器不会把一个private继承的子类，自动转换成一个基类\n     2. private继承下来的所有成员， 在子类中都会变成private属性\n     3. protect继承\n        1. 默认的基本上都是public继承；\n        2. 尽可能使用compiosition， 必要的时候再使用private继承\n\n 40. 谨慎使用多重继承（子类从多个父类继承而来）\n     \n     1. 可能对导致对基类函数调用的歧义，到底调用的是哪一个基类的成员函数？\n     2. 钻石形继承， 二级基类可以是虚基类， 这样三级再继承的时候， 就不会重复出现两个爷爷类里面的成员函数了；\n     3. virtual继承会带来更多大小，速度，初始化的成本。如果非要有一个virtual base class， 最好不要在虚基类里面放置数据；\n     4. 有一种情况， 比较适合多重继承，public继承某个interface class， private继承某个协助实现的class；帮助子类实现某些功能。但是还是谨记第一条吧；\n\n\n# 模板，gp\n\n 41. 隐式接口和编译期多态\n 42. typename和class关键字， typename关键字的双重定义\n 43. 如何处理模板化基类的里面的名称\n 44. 参数无关的代码， 抽离template\n 45. 使用成员函数模板来接受所有兼容的类型\n 46. 需要类型转换的时候， 为模板定义一个非成员函数\n 47. 使用traits来表现模板里面的类型信息\n 48. 什么是template元编程\n\n\n# 定制new和delete\n\n 49. new handler的行为（处理new失败时候throw的异常）， 底层是怎样构成的？\n 50. operator new和operator delete的合理替换时机；\n 51. operator new和operator delete需要遵循的一些规则\n 52. placement new和placement delete\n\n\n# 一些杂项\n\n 53. 编译器的warnning有时候也很重要\n 54. 熟悉tr1标准库\n 55. 熟悉boost保准库',charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"《More Effective C++》",frontmatter:{title:"《More Effective C++》",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/e1ff7c/"},regularPath:"/01.Wiki/19.Reading%20Notes/02.More_Effective_C++.html",relativePath:"01.Wiki/19.Reading Notes/02.More_Effective_C++.md",key:"v-b802e238",path:"/pages/e1ff7c/",headers:[{level:2,title:"基础议题",slug:"基础议题",normalizedTitle:"基础议题",charIndex:25},{level:2,title:"操作符（operators）",slug:"操作符-operators",normalizedTitle:"操作符（operators）",charIndex:1497},{level:2,title:"异常（exceptions）",slug:"异常-exceptions",normalizedTitle:"异常（exceptions）",charIndex:3375},{level:2,title:"效率（efficiency）, 这部分可以参考高性能C++相关的书籍",slug:"效率-efficiency-这部分可以参考高性能c-相关的书籍",normalizedTitle:"效率（efficiency）, 这部分可以参考高性能c++相关的书籍",charIndex:4612},{level:2,title:"技术（techniques, idioms, patterns）",slug:"技术-techniques-idioms-patterns",normalizedTitle:"技术（techniques, idioms, patterns）",charIndex:5370},{level:2,title:"杂项讨论，Misc",slug:"杂项讨论-misc",normalizedTitle:"杂项讨论，misc",charIndex:9984}],headersStr:"基础议题 操作符（operators） 异常（exceptions） 效率（efficiency）, 这部分可以参考高性能C++相关的书籍 技术（techniques, idioms, patterns） 杂项讨论，Misc",content:'# More Effective C++\n\n\n# 基础议题\n\n 1. 仔细区分pointer和reference\n    \n    * reference 一定得代表某个对象，C++因此要求 references 必须有初值\n    * 用 references 可能会比使用pointers 更富效率。这是因为使用 reference 之前不需要测试其有效性, 如果是指针, 需要判断if(pc), 是否是nullptr\n    * Pointers 和 references 之间的另一个重要差异就是，pointers 可以被重新赋值\n\n 2. 最好是使用C++的cast操作(static_cast(), const_cast(), reinterprete_cast(), dynamic_cast())；\n    \n    * static_cast 基本上拥有与 C 旧式转型相同的威力与意义，以及相同的限制。\n    * const_cast 用来改变表达式中的常量性（constness）或变易性（volatileness）\n    * dynamic_cast，用来执行继承体系中“安全的向下转型或跨系转型动作”。也就是说你可以利用 dynamic_cast，将“指向 base class objects的 pointers或 references”转型为“指向 derived（或 sibling base）class objects的 pointers 或 references”，并得知转型是否成功1。\n    * reinterpret_cast转换结果几乎总是与编译平台息息相关。所以 reinterpret_casts 不具移植性。reinterpret_cast 的最常用用途是转换“函数指针”类型。\n\n 3. 不要以多态的方式处理数组， 因为多态的时候, 导致数组里面元素的大小不一样， 在数组里面slicing会导致便偏移错误；\n    \n    Example:\n    \n    \t\n    \n    \n    1\n    \n\n 4. 非必要不使用默认的default constructor， 在一个完美的世界中，凡可以“合理地从无到有生成对象”的 classes，都应该内含 default constructors，而“必须有某些外来信息才能生成对象”的 classes，则不必拥有 default constructors。但我们的世界毕竟不是完美的世界，所以我们必须纳入其他考虑。\n    \n    如果 class 缺乏一个 default constructor，当你使用这个class 时便会有某些限制。\n    \n    无意义 default constructors，会影响 classes 效率。member functions 必须检测这个字段是否被初始化， 要花更多的时间和空间（这个类也变大了）；\n    \n    到底要不要有 default constructor，最后还是要看 virtual base classes （见条款 E43）有关。虚基类必须要有默认的构造函数。因为 virtual base class constructors 的自变量必须由欲产生的对象的派生层次最深（所谓 most derived）的 class 提供。一个缺乏 default constructor的 virtual base class，要求其所有的 derived classes都必须知道、了解其意义，这太难了\n\n\n# 操作符（operators）\n\n 5. 自己定制的类型转换函数， 需要保持警惕, 也就是拷贝构造, 拷贝赋值; 允许编译器执行隐式类型转换, 坏处大于好处;\n    \n    * 并且主要是一些内建default对类对象的类型转换\n    * 因为有一些转换函数， 在一些自己想不到的时候， 会被偶然间调用；\n    * 自定义的类型转换,要避免发生隐式类型转换, 它最好只能够非常清晰地从type A到typeB\n    * 关键词 explicit。这个特性之所以被导入，就是为了解决隐式类型转换带来的问题。其用法十分直接易懂，只要将 constructors声明为 explicit，编译器便不能因隐式类型转换的需要而调用它们。单一参数的构造函数， 加上explicit\n    * 类似 ArraySize 这样的 classes，往往被称为proxy classes，因为它的每一个对象都是为了其他对象而存在的，\n    * \n\n 6. 区别C++， 和++C这两个操作符重载时候的区别, ++C没有临时变量, C++是有的\n    \n    * 重载的时候, 前置是operator++(), 后置是operator++(int)， 所以后置的时候， 会用到前置的重构在函数\n      \n      const UPInt UPInt::opreator++(){\n      \t*this += 1;\n      \treturn *this;\t\n      } // ++a\n      \n      const UPInt UPInt::opreator++(int){\n      \tUPInt oldValue = *this;\n      \t++(*this);\n      \treturn oldValue;\t\n      } // a++\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      \n\n 7. 不要重载&&，||和，操作符；因为重载这些操作符的参数, 再调用这些重载函数的时候, 都需要已经被计算出来, 但是通常我们在使用这些操作符的时候会把一些没有计算出来的表达式放在里面去做||, &&操作; C++并未明确定义函数调用动作中各参数的计算顺序，所以没办法知道 那个变量中的哪个会先被计算出来。\n\n 8. 对不同含义的new和delete， 需要充分搞清楚区别和含义；[拓展： 侯捷, 内存管理课程]\n    \n    // 指针数组\n    int* bestPractice = new *int[10];\n    // 数组指针\n    \n    \n    // new operator:\n    string *ps = new string("Memory management");\n    delete ps; //只有new operator出来的内存才能delete， malloc出来的要经过cast成为对象的指针才能够使用delete；\n    delete [] ps; // 如果ps是一个数组的话；\n    \n    // operator new:\n    void* operator new(size_t, size);\n    //可以直接这样使用，像使用malloc一样， 把内存转换成对象是new operator做的事情；\n    void* rawMemory = operator new(sizeof(string));\n    operater delete(rawMemory); // operator delete\n    \n    //placement new\n    Widget* constructWidgetInBuffer(void *buffer, int widgetSize){\n        return new (buffer) Widget(widgetSize);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n\n# 异常（exceptions）\n\n 9.  利用destructor来避免资源的泄露（什么是资源泄露？没有delete的指针）， 最好还是使用智能指针的类来处理会比较好；\n     \n     要么catch到exception之后， 要及时释放资源， 避免资源泄露；\n     \n     要么就在destructor里面， 增加资源的释放， 即使遇到异常， 退出的时候也会调用析构函数里面的delete；\n     \n     使用智能指针， auto_ptr(), shared_ptr(), weak_ptr()\n\n 10. 利用constructor来避免资源泄露（最好还是使用智能指针的类比较好）\n     \n     * 在构造新对象的过程中， 如果构造失败， 就可能会造成资源泄露\n     * 所以要直接在构造函数里面对构造失败的异常进行捕获， 并且处理好这些异常， 对野指针进行delete。\n     * 把这些指针的删除， 囊括在一个clean up()的函数里面；\n     * 指向const的指针， 只能在初始化列表里面进行初始化， 这些对象的初始化过程中的异常， 可以放在一个private函数里面去进行，\n     * 不过最好还是使用auto_ptr之类的东西， 直接去管理类的成员数据， 比较方便一些\n     * 由于 C++不自动清理那些“构造期间抛出 exceptions”的对象，所以你必须设计你的 constructors，使它们在那种情况下亦能自我清理。\n\n 11. 别让异常流出destructor;\n     \n     1. 第一，它可以避免 terminate函数在exception传播过程的栈展开（stack-unwinding）机制中被调用；\n     \n     2. 第二，它可以协助确保 destructors 完成其应该完成的所有事情。\n\n 12. 弄清楚， 抛出一个异常， 和 传递一个参数之间的区别\n\n 13. 以 by reference的方式捕获一个exception; 既没有by value的复制问题 也没有by pointer 的局部对象问题；\n     \n     by pointer 可能会遇到下面的问题：当ex不是一个global或者是static对象， 而是一个局部对象的时候， 就会出错\n\n 14. 明智地运用exception specification\n\n 15. 清楚异常处理带来的成本； 粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%～10%，执行速度亦大约下降这个数。这是在假设没有任何 exceptions 被抛出的情况下。此处我们所讨论的只是“代码中出现 try 语句块”的成本而已。\n     \n     主要是时间和空间上面的成本；\n\n需要讨论， C++ runtime时候， 编译， 连接的时候，对这些exceptions是怎么处理的？\n\n\n# 效率（efficiency）, 这部分可以参考高性能C++相关的书籍\n\n与运行时， 虚函数， 以及对象的内存模型相关的知识；\n\n 16. 要清楚80-20法则， 有时候还是根方效率， 也就是100个人里面， 只有10个人完成了一半的工作， 10000个人里面只有100个人完成了一半的工作；\n\n * 只有20%代码占用了程序的80%的时间\n\n 17. 考虑使用缓式评估（lazy evaluation）\n\n * 用到的时候, 再把需要的中间变量计算出来, 不然过早计算, 可能后面会用不到,\n * 避免不必要的重复冗余计算;\n * 用到的变量, 也是这样, 过早声明定义, 有可能会浪费\n\n 18. 分期摊还预期的计算成本\n\n 19. 软件层面上做Cache和prefetch\n\n 20. 了解临时对象是从哪里来的；\n\n 21. 协助程序完成返回值优化（RVO） 在return by value的时候， 在最后return的语句里面，直接返回实例的表达式， 可以省去在函数体内部多出来的一个临时对象；\n\n 22. 利用overloading来避免隐式类型转换\n\n 23. 考虑使用操作符复合形式（op=）取代其独立的形式（op）\n     \n     += 比 + 拥有更少的临时对象， 在进行操作符重载的时候， 独立形式的操作符也会使用复合形式的操作符重载来完成， 和++a a++一样， 都会有多余的overhead；\n\n 24. 积极使用其他的库\n     \n     比如OneDNN / MKL、 libevent， 以及一些网络的库\n\n 25. 虚函数， 多重继承，虚基类， RTTI的成本代价是什么\n     \n     主要是对象的内存模型相关的内容， 对象模型那本书里面有更详细的讲解；\n\n\n# 技术（techniques, idioms, patterns）\n\n这部分内容更像是设计模式要解决的相关的问题；\n\n 25. 将copy constructor和non member functions 虚化\n     \n     virtual copy constructor 感觉和设计模式里面的工厂模式是差不多的概念\n     \n     non-member function的虚化：写一个虚函数做实际工作，再写一个什么都不做的非虚函数，只负责调用虚函数。当然啦，为了避免此巧妙安排蒙受函数调用所带来的成本，你可以将非虚函数 inline 化（\n     \n     #include <iostream>\n     \n     class A\n     {\n         public:\n             virtual std::ostream &print(std::ostream &s) const = 0;\n     };\n     \n     class B: public A\n     {\n         public:\n             virtual std::ostream &print(std::ostream &s) const { s << "i am b"; return s; };\n     };\n     \n     class C : public A\n     {\n         public:\n             virtual std::ostream &print(std::ostream &s) const { s << "i am c"; return s; };\n     };\n     \n     std::ostream &operator <<(std::ostream &s, const A &a)\n     {\n         return a.print(s);\n     }\n     \n     int main(void)\n     {\n         B b;\n         C c;\n         std::cout << b << "\\n" << c << std::endl;\n     \n         return 0;\n     }\t\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     \n\n 26. 限制某个class所能产生的对象数量(如果只是一个， 那么用static对象， 记得看singleton设计模式)\n     \n     引用计数\n     \n     使用全局函数， 并且用private来封锁ctor和dtor，全局函数里面包裹一个static的对象， 只能产生一个：\n     \n     class Printer{\n     public:\n     \tvoid submitJob(const PrintJob& Job);\n         void reset();\n        \tvoid performSelfTest();\n         friend Printer& thePrinter();\n         ...\n     private:\n         Printer();\n         Printer(const Printer& rhs);\n         ...\n     }\n     \n     Printer& thePrinter(){\n         static Printer p;\n         return p;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     \n     \n     但是全局函数是不安全的， 最好不要动不动就用全局的东西\n     \n     使用namespace来包裹一下这个全局函数；\n     \n     `“class拥有一个 static对象”的意思是：即使从未被用到，它也会被构造（及析构）。相反地“函数拥有一个 static 对象”的意思是：此对象在函数第一次被调用时才产生。如果该函数从未被调用，这个对象也就绝不会诞生（然而你必须付出代价，在函数每次被调用时检查对象是否需要诞生）\n\n 27. 人工限制或者禁止对象产生与heap之中\n     \n     限制只能在heap里面产生对象， 就要把常规的构造和析构函数， 设置成为private：（private不能继承， 但是可以弄成protected的，但是protected就不知道是在heap上还是stack上面了）\n     \n     class A\n     {\n     public:\n         /* 做一个伪析构 */\n         void destory() { this->~A(); }\n     \n     private:\n         /* 析构函数设为私有，防止在栈上构建对象 */\n         ~A() { };\n     };\n     \n     class M\n     {\n         // A a_; /* 错误，不可在堆上创建 */\n         A *pa_; /* 在内含类中，需要改为指针使用 */\n     };\n     \n     int main(void)\n     {\n         // A a; /* 错误 */\n         A *pa = new A(); /* 正确 */\n         // delete pa; /* 错误 */\n         pa->destory(); /* 正确 */\n     \n         return 0;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     \n     \n     禁止在heap上产生对象， 要把operator new()， operator new以及相应的delete函数放在private里面；\n     \n     #include <iostream>\n     \n     class A\n     {\n     public:\n         /* 用c++11的方式 */\n         /*\n             static void *operator new(size_t) = delete;\n             static void operator delete(void *) = delete;\n             static void *operator new [](size_t) = delete;\n             static void operator delete [](void *) =delete;\n         */\n     private:\n         static void *operator new(size_t);\n         static void operator delete(void *);\n         static void *operator new [](size_t);\n         static void operator delete [](void *);\n     };\n     \n     int main(void)\n     {\n         A a;\n         // A *pa = new A();   /* 错误 */\n         // A *pa = new A[10]; /* 错误 */\n         A *p = &a;\n         // delete p; /* 错误，delete已经被私有化，编译器就可以报错，delete []同原理 */\n     \n         return 0;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     \n\n 28. smart pointer智能指针\n     \n     现代C++里面， 主要是auto_ptr(), shared_ptr()相关的类型， 可以使用；\n\n 29. reference counter引用技术 、 copy on write相关的技术\n\n 30. proxy class\n     \n     代理类实际上有三种好处，\n     \n     * 实现多维数组： 真实数组为一个一维数组，内嵌代理为一个一维数组，组合起来就是一个二维数组\n     * 区分读写\n     * 压制隐式转换 因为返回的类型为代理类类型，所以很多操作需要隐式类型转换，如果代理类没实现，就不能进行隐式类型转换，这样可以有效的压制隐式类型转换\n\n 31. 让函数根据一个以上的对象类型来决定如何虚化这个函数；\n     \n     虚函数的调用其实也可以理解为一个message dispatch, 如果一个虚函数要根据两个参数的类型来进行虚化， 则称为 double dispatch,\n     \n     使用RTTI， typeid();\n\n\n# 杂项讨论，Misc\n\n 32. 在未来时态下发展程序， 为以后程序的变动留下足够的弹性设计空间；（设计模式和设计经验， 架构的经验）\n     \n     ● 提供完整的 classes（见条款 E18）——即使某些部分目前用不到。当新的需求进来，你不太需要回头去修改那些 classes。\n     \n     ● 设计你的接口，使有利于共同的操作行为，阻止共同的错误（见条款 E46）。让这些 classes 轻易地被正确运用，难以被错误运用。例如，面对那些“copying和 assignment 并不合理”的classes，请禁止那些动作的发生（见条款 E27）。请防止部分赋值（partial assignments，见条款 33）的发生。\n     \n     ● 尽量使你的代码一般化（泛化），除非有不良的巨大后果。举个例子，如果你正在写一个算法，用于树状结构（tree）的来回遍历，请考虑将它一般化，以便能够处理任何种类的 directed acyclic（非环状的）graph\n\n 33. 将non leaf class 设计为一个抽象类\n\n 34. 如何在同一个程序中结合C和C++\n     \n     #ifdef _cplusplus\n     extern "C" {\n     #endif\n     \n     #ifdef _cplusplus\n     }\n     #endif\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n     \n     static class 对象、全局对象、namespace 内的对象以及文件范围（file scope）内的对象，其 constructors 总是在 main 之前就获得执行。这个过程称为 static initialization（见条款 E47\n\n 35. 让自己习惯于标准的C++的一些新特性，\n     \n     * 支持数值应用。复数（complex numbers）长久以来是许多 C++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。●\n     * 支持广泛用途的 containers（容器）和 algorithms（算法）。C++标准程序库内含一组 class templates 和 function templates，统称为 Standard Template Library（STL）。STL 是 C++标准程序库中最具革命性的部分。稍后我会摘要说明其特征。\n     * 支持数值应用。复数（complex numbers）长久以来是许多 C++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。\n     * 支持广泛用途的 containers（容器）和 algorithms（算法）。C++标准程序库内含一组 class templates 和 function templates，统称为 Standard Template Library（STL）。STL 是 C++标准程序库中最具革命性的部分。稍后我会摘要说明其特征。\n     * STL\n       * 支持 C标准函数库。别担心，C++还记得它的根源。某些微小的变化，使“C++版本的 C函数库”与“C++的强烈类型检验性质”得以一致。但是，你对 C函数库所知道的一切，以及对它的爱恨情仇，在 C++中都依然存在。\n       * 支持 strings。就像 C++标准程序库小组主席 Mike Vilot所说：“如果没有提供一个标准的 string 类型，恐怕会出现街头流血事件！”（有些人就是这么感情用事。）冷静点，放下那些砖头棍棒——C++标准程序库提供了 string。\n       * 支持国别（地域别、本土化，localization）。不同的文化使用不同的字符集，并在显示日期、时间、排序事物、货币值的时候有着不同的习俗。标准程序库对于国别的支持，使程序开发得以轻松容纳多种文化差异。\n       * 支持 I/O。iostream 程序库仍旧是标准 C++的一部分，但是委员会对它做了一些修补。虽然某些 classes 被剔除了（特别值得注意的是 iostream 和fstream），某些 classes 被取代了（例如 string-based stringstreams 取代了 char＊-based strstreams，后者不再被标准委员会认可），不过 iostream 内的各个标准 classes仍可忠实反映那些早已存在多年的基本功能。\n       * 支持数值应用。复数（complex numbers）长久以来是许多 C++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。\n       * 支持数值应用。复数（complex numbers）长久以来是许多 C++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。\n       * 支持广泛用途的 containers（容器）和 algorithms（算法）。C++标准程序库内含一组 class templates 和 function templates，统称为 Standard Template Library（STL）。STL 是 C++标准程序库中最具革命性的部分。稍后我会摘要说明其特征。\n\n推荐的阅读清单： 后面可以一起总结\n\n一个造轮子的repo： https://github.com/codecrafters-io/build-your-own-x\n\nshared_ptr()代码\n\nauto_ptr()',normalizedContent:'# more effective c++\n\n\n# 基础议题\n\n 1. 仔细区分pointer和reference\n    \n    * reference 一定得代表某个对象，c++因此要求 references 必须有初值\n    * 用 references 可能会比使用pointers 更富效率。这是因为使用 reference 之前不需要测试其有效性, 如果是指针, 需要判断if(pc), 是否是nullptr\n    * pointers 和 references 之间的另一个重要差异就是，pointers 可以被重新赋值\n\n 2. 最好是使用c++的cast操作(static_cast(), const_cast(), reinterprete_cast(), dynamic_cast())；\n    \n    * static_cast 基本上拥有与 c 旧式转型相同的威力与意义，以及相同的限制。\n    * const_cast 用来改变表达式中的常量性（constness）或变易性（volatileness）\n    * dynamic_cast，用来执行继承体系中“安全的向下转型或跨系转型动作”。也就是说你可以利用 dynamic_cast，将“指向 base class objects的 pointers或 references”转型为“指向 derived（或 sibling base）class objects的 pointers 或 references”，并得知转型是否成功1。\n    * reinterpret_cast转换结果几乎总是与编译平台息息相关。所以 reinterpret_casts 不具移植性。reinterpret_cast 的最常用用途是转换“函数指针”类型。\n\n 3. 不要以多态的方式处理数组， 因为多态的时候, 导致数组里面元素的大小不一样， 在数组里面slicing会导致便偏移错误；\n    \n    example:\n    \n    \t\n    \n    \n    1\n    \n\n 4. 非必要不使用默认的default constructor， 在一个完美的世界中，凡可以“合理地从无到有生成对象”的 classes，都应该内含 default constructors，而“必须有某些外来信息才能生成对象”的 classes，则不必拥有 default constructors。但我们的世界毕竟不是完美的世界，所以我们必须纳入其他考虑。\n    \n    如果 class 缺乏一个 default constructor，当你使用这个class 时便会有某些限制。\n    \n    无意义 default constructors，会影响 classes 效率。member functions 必须检测这个字段是否被初始化， 要花更多的时间和空间（这个类也变大了）；\n    \n    到底要不要有 default constructor，最后还是要看 virtual base classes （见条款 e43）有关。虚基类必须要有默认的构造函数。因为 virtual base class constructors 的自变量必须由欲产生的对象的派生层次最深（所谓 most derived）的 class 提供。一个缺乏 default constructor的 virtual base class，要求其所有的 derived classes都必须知道、了解其意义，这太难了\n\n\n# 操作符（operators）\n\n 5. 自己定制的类型转换函数， 需要保持警惕, 也就是拷贝构造, 拷贝赋值; 允许编译器执行隐式类型转换, 坏处大于好处;\n    \n    * 并且主要是一些内建default对类对象的类型转换\n    * 因为有一些转换函数， 在一些自己想不到的时候， 会被偶然间调用；\n    * 自定义的类型转换,要避免发生隐式类型转换, 它最好只能够非常清晰地从type a到typeb\n    * 关键词 explicit。这个特性之所以被导入，就是为了解决隐式类型转换带来的问题。其用法十分直接易懂，只要将 constructors声明为 explicit，编译器便不能因隐式类型转换的需要而调用它们。单一参数的构造函数， 加上explicit\n    * 类似 arraysize 这样的 classes，往往被称为proxy classes，因为它的每一个对象都是为了其他对象而存在的，\n    * \n\n 6. 区别c++， 和++c这两个操作符重载时候的区别, ++c没有临时变量, c++是有的\n    \n    * 重载的时候, 前置是operator++(), 后置是operator++(int)， 所以后置的时候， 会用到前置的重构在函数\n      \n      const upint upint::opreator++(){\n      \t*this += 1;\n      \treturn *this;\t\n      } // ++a\n      \n      const upint upint::opreator++(int){\n      \tupint oldvalue = *this;\n      \t++(*this);\n      \treturn oldvalue;\t\n      } // a++\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      \n\n 7. 不要重载&&，||和，操作符；因为重载这些操作符的参数, 再调用这些重载函数的时候, 都需要已经被计算出来, 但是通常我们在使用这些操作符的时候会把一些没有计算出来的表达式放在里面去做||, &&操作; c++并未明确定义函数调用动作中各参数的计算顺序，所以没办法知道 那个变量中的哪个会先被计算出来。\n\n 8. 对不同含义的new和delete， 需要充分搞清楚区别和含义；[拓展： 侯捷, 内存管理课程]\n    \n    // 指针数组\n    int* bestpractice = new *int[10];\n    // 数组指针\n    \n    \n    // new operator:\n    string *ps = new string("memory management");\n    delete ps; //只有new operator出来的内存才能delete， malloc出来的要经过cast成为对象的指针才能够使用delete；\n    delete [] ps; // 如果ps是一个数组的话；\n    \n    // operator new:\n    void* operator new(size_t, size);\n    //可以直接这样使用，像使用malloc一样， 把内存转换成对象是new operator做的事情；\n    void* rawmemory = operator new(sizeof(string));\n    operater delete(rawmemory); // operator delete\n    \n    //placement new\n    widget* constructwidgetinbuffer(void *buffer, int widgetsize){\n        return new (buffer) widget(widgetsize);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n\n# 异常（exceptions）\n\n 9.  利用destructor来避免资源的泄露（什么是资源泄露？没有delete的指针）， 最好还是使用智能指针的类来处理会比较好；\n     \n     要么catch到exception之后， 要及时释放资源， 避免资源泄露；\n     \n     要么就在destructor里面， 增加资源的释放， 即使遇到异常， 退出的时候也会调用析构函数里面的delete；\n     \n     使用智能指针， auto_ptr(), shared_ptr(), weak_ptr()\n\n 10. 利用constructor来避免资源泄露（最好还是使用智能指针的类比较好）\n     \n     * 在构造新对象的过程中， 如果构造失败， 就可能会造成资源泄露\n     * 所以要直接在构造函数里面对构造失败的异常进行捕获， 并且处理好这些异常， 对野指针进行delete。\n     * 把这些指针的删除， 囊括在一个clean up()的函数里面；\n     * 指向const的指针， 只能在初始化列表里面进行初始化， 这些对象的初始化过程中的异常， 可以放在一个private函数里面去进行，\n     * 不过最好还是使用auto_ptr之类的东西， 直接去管理类的成员数据， 比较方便一些\n     * 由于 c++不自动清理那些“构造期间抛出 exceptions”的对象，所以你必须设计你的 constructors，使它们在那种情况下亦能自我清理。\n\n 11. 别让异常流出destructor;\n     \n     1. 第一，它可以避免 terminate函数在exception传播过程的栈展开（stack-unwinding）机制中被调用；\n     \n     2. 第二，它可以协助确保 destructors 完成其应该完成的所有事情。\n\n 12. 弄清楚， 抛出一个异常， 和 传递一个参数之间的区别\n\n 13. 以 by reference的方式捕获一个exception; 既没有by value的复制问题 也没有by pointer 的局部对象问题；\n     \n     by pointer 可能会遇到下面的问题：当ex不是一个global或者是static对象， 而是一个局部对象的时候， 就会出错\n\n 14. 明智地运用exception specification\n\n 15. 清楚异常处理带来的成本； 粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%～10%，执行速度亦大约下降这个数。这是在假设没有任何 exceptions 被抛出的情况下。此处我们所讨论的只是“代码中出现 try 语句块”的成本而已。\n     \n     主要是时间和空间上面的成本；\n\n需要讨论， c++ runtime时候， 编译， 连接的时候，对这些exceptions是怎么处理的？\n\n\n# 效率（efficiency）, 这部分可以参考高性能c++相关的书籍\n\n与运行时， 虚函数， 以及对象的内存模型相关的知识；\n\n 16. 要清楚80-20法则， 有时候还是根方效率， 也就是100个人里面， 只有10个人完成了一半的工作， 10000个人里面只有100个人完成了一半的工作；\n\n * 只有20%代码占用了程序的80%的时间\n\n 17. 考虑使用缓式评估（lazy evaluation）\n\n * 用到的时候, 再把需要的中间变量计算出来, 不然过早计算, 可能后面会用不到,\n * 避免不必要的重复冗余计算;\n * 用到的变量, 也是这样, 过早声明定义, 有可能会浪费\n\n 18. 分期摊还预期的计算成本\n\n 19. 软件层面上做cache和prefetch\n\n 20. 了解临时对象是从哪里来的；\n\n 21. 协助程序完成返回值优化（rvo） 在return by value的时候， 在最后return的语句里面，直接返回实例的表达式， 可以省去在函数体内部多出来的一个临时对象；\n\n 22. 利用overloading来避免隐式类型转换\n\n 23. 考虑使用操作符复合形式（op=）取代其独立的形式（op）\n     \n     += 比 + 拥有更少的临时对象， 在进行操作符重载的时候， 独立形式的操作符也会使用复合形式的操作符重载来完成， 和++a a++一样， 都会有多余的overhead；\n\n 24. 积极使用其他的库\n     \n     比如onednn / mkl、 libevent， 以及一些网络的库\n\n 25. 虚函数， 多重继承，虚基类， rtti的成本代价是什么\n     \n     主要是对象的内存模型相关的内容， 对象模型那本书里面有更详细的讲解；\n\n\n# 技术（techniques, idioms, patterns）\n\n这部分内容更像是设计模式要解决的相关的问题；\n\n 25. 将copy constructor和non member functions 虚化\n     \n     virtual copy constructor 感觉和设计模式里面的工厂模式是差不多的概念\n     \n     non-member function的虚化：写一个虚函数做实际工作，再写一个什么都不做的非虚函数，只负责调用虚函数。当然啦，为了避免此巧妙安排蒙受函数调用所带来的成本，你可以将非虚函数 inline 化（\n     \n     #include <iostream>\n     \n     class a\n     {\n         public:\n             virtual std::ostream &print(std::ostream &s) const = 0;\n     };\n     \n     class b: public a\n     {\n         public:\n             virtual std::ostream &print(std::ostream &s) const { s << "i am b"; return s; };\n     };\n     \n     class c : public a\n     {\n         public:\n             virtual std::ostream &print(std::ostream &s) const { s << "i am c"; return s; };\n     };\n     \n     std::ostream &operator <<(std::ostream &s, const a &a)\n     {\n         return a.print(s);\n     }\n     \n     int main(void)\n     {\n         b b;\n         c c;\n         std::cout << b << "\\n" << c << std::endl;\n     \n         return 0;\n     }\t\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     \n\n 26. 限制某个class所能产生的对象数量(如果只是一个， 那么用static对象， 记得看singleton设计模式)\n     \n     引用计数\n     \n     使用全局函数， 并且用private来封锁ctor和dtor，全局函数里面包裹一个static的对象， 只能产生一个：\n     \n     class printer{\n     public:\n     \tvoid submitjob(const printjob& job);\n         void reset();\n        \tvoid performselftest();\n         friend printer& theprinter();\n         ...\n     private:\n         printer();\n         printer(const printer& rhs);\n         ...\n     }\n     \n     printer& theprinter(){\n         static printer p;\n         return p;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     \n     \n     但是全局函数是不安全的， 最好不要动不动就用全局的东西\n     \n     使用namespace来包裹一下这个全局函数；\n     \n     `“class拥有一个 static对象”的意思是：即使从未被用到，它也会被构造（及析构）。相反地“函数拥有一个 static 对象”的意思是：此对象在函数第一次被调用时才产生。如果该函数从未被调用，这个对象也就绝不会诞生（然而你必须付出代价，在函数每次被调用时检查对象是否需要诞生）\n\n 27. 人工限制或者禁止对象产生与heap之中\n     \n     限制只能在heap里面产生对象， 就要把常规的构造和析构函数， 设置成为private：（private不能继承， 但是可以弄成protected的，但是protected就不知道是在heap上还是stack上面了）\n     \n     class a\n     {\n     public:\n         /* 做一个伪析构 */\n         void destory() { this->~a(); }\n     \n     private:\n         /* 析构函数设为私有，防止在栈上构建对象 */\n         ~a() { };\n     };\n     \n     class m\n     {\n         // a a_; /* 错误，不可在堆上创建 */\n         a *pa_; /* 在内含类中，需要改为指针使用 */\n     };\n     \n     int main(void)\n     {\n         // a a; /* 错误 */\n         a *pa = new a(); /* 正确 */\n         // delete pa; /* 错误 */\n         pa->destory(); /* 正确 */\n     \n         return 0;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     \n     \n     禁止在heap上产生对象， 要把operator new()， operator new以及相应的delete函数放在private里面；\n     \n     #include <iostream>\n     \n     class a\n     {\n     public:\n         /* 用c++11的方式 */\n         /*\n             static void *operator new(size_t) = delete;\n             static void operator delete(void *) = delete;\n             static void *operator new [](size_t) = delete;\n             static void operator delete [](void *) =delete;\n         */\n     private:\n         static void *operator new(size_t);\n         static void operator delete(void *);\n         static void *operator new [](size_t);\n         static void operator delete [](void *);\n     };\n     \n     int main(void)\n     {\n         a a;\n         // a *pa = new a();   /* 错误 */\n         // a *pa = new a[10]; /* 错误 */\n         a *p = &a;\n         // delete p; /* 错误，delete已经被私有化，编译器就可以报错，delete []同原理 */\n     \n         return 0;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     \n\n 28. smart pointer智能指针\n     \n     现代c++里面， 主要是auto_ptr(), shared_ptr()相关的类型， 可以使用；\n\n 29. reference counter引用技术 、 copy on write相关的技术\n\n 30. proxy class\n     \n     代理类实际上有三种好处，\n     \n     * 实现多维数组： 真实数组为一个一维数组，内嵌代理为一个一维数组，组合起来就是一个二维数组\n     * 区分读写\n     * 压制隐式转换 因为返回的类型为代理类类型，所以很多操作需要隐式类型转换，如果代理类没实现，就不能进行隐式类型转换，这样可以有效的压制隐式类型转换\n\n 31. 让函数根据一个以上的对象类型来决定如何虚化这个函数；\n     \n     虚函数的调用其实也可以理解为一个message dispatch, 如果一个虚函数要根据两个参数的类型来进行虚化， 则称为 double dispatch,\n     \n     使用rtti， typeid();\n\n\n# 杂项讨论，misc\n\n 32. 在未来时态下发展程序， 为以后程序的变动留下足够的弹性设计空间；（设计模式和设计经验， 架构的经验）\n     \n     ● 提供完整的 classes（见条款 e18）——即使某些部分目前用不到。当新的需求进来，你不太需要回头去修改那些 classes。\n     \n     ● 设计你的接口，使有利于共同的操作行为，阻止共同的错误（见条款 e46）。让这些 classes 轻易地被正确运用，难以被错误运用。例如，面对那些“copying和 assignment 并不合理”的classes，请禁止那些动作的发生（见条款 e27）。请防止部分赋值（partial assignments，见条款 33）的发生。\n     \n     ● 尽量使你的代码一般化（泛化），除非有不良的巨大后果。举个例子，如果你正在写一个算法，用于树状结构（tree）的来回遍历，请考虑将它一般化，以便能够处理任何种类的 directed acyclic（非环状的）graph\n\n 33. 将non leaf class 设计为一个抽象类\n\n 34. 如何在同一个程序中结合c和c++\n     \n     #ifdef _cplusplus\n     extern "c" {\n     #endif\n     \n     #ifdef _cplusplus\n     }\n     #endif\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n     \n     static class 对象、全局对象、namespace 内的对象以及文件范围（file scope）内的对象，其 constructors 总是在 main 之前就获得执行。这个过程称为 static initialization（见条款 e47\n\n 35. 让自己习惯于标准的c++的一些新特性，\n     \n     * 支持数值应用。复数（complex numbers）长久以来是许多 c++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。●\n     * 支持广泛用途的 containers（容器）和 algorithms（算法）。c++标准程序库内含一组 class templates 和 function templates，统称为 standard template library（stl）。stl 是 c++标准程序库中最具革命性的部分。稍后我会摘要说明其特征。\n     * 支持数值应用。复数（complex numbers）长久以来是许多 c++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。\n     * 支持广泛用途的 containers（容器）和 algorithms（算法）。c++标准程序库内含一组 class templates 和 function templates，统称为 standard template library（stl）。stl 是 c++标准程序库中最具革命性的部分。稍后我会摘要说明其特征。\n     * stl\n       * 支持 c标准函数库。别担心，c++还记得它的根源。某些微小的变化，使“c++版本的 c函数库”与“c++的强烈类型检验性质”得以一致。但是，你对 c函数库所知道的一切，以及对它的爱恨情仇，在 c++中都依然存在。\n       * 支持 strings。就像 c++标准程序库小组主席 mike vilot所说：“如果没有提供一个标准的 string 类型，恐怕会出现街头流血事件！”（有些人就是这么感情用事。）冷静点，放下那些砖头棍棒——c++标准程序库提供了 string。\n       * 支持国别（地域别、本土化，localization）。不同的文化使用不同的字符集，并在显示日期、时间、排序事物、货币值的时候有着不同的习俗。标准程序库对于国别的支持，使程序开发得以轻松容纳多种文化差异。\n       * 支持 i/o。iostream 程序库仍旧是标准 c++的一部分，但是委员会对它做了一些修补。虽然某些 classes 被剔除了（特别值得注意的是 iostream 和fstream），某些 classes 被取代了（例如 string-based stringstreams 取代了 char＊-based strstreams，后者不再被标准委员会认可），不过 iostream 内的各个标准 classes仍可忠实反映那些早已存在多年的基本功能。\n       * 支持数值应用。复数（complex numbers）长久以来是许多 c++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。\n       * 支持数值应用。复数（complex numbers）长久以来是许多 c++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。\n       * 支持广泛用途的 containers（容器）和 algorithms（算法）。c++标准程序库内含一组 class templates 和 function templates，统称为 standard template library（stl）。stl 是 c++标准程序库中最具革命性的部分。稍后我会摘要说明其特征。\n\n推荐的阅读清单： 后面可以一起总结\n\n一个造轮子的repo： https://github.com/codecrafters-io/build-your-own-x\n\nshared_ptr()代码\n\nauto_ptr()',charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"《C++ 性能优化指南》",frontmatter:{pageClass:"diary",title:"《C++ 性能优化指南》",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/wiki/Reading_Notes/"},regularPath:"/01.Wiki/19.Reading%20Notes/03.C++%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97.html",relativePath:"01.Wiki/19.Reading Notes/03.C++性能优化指南.md",key:"v-76d7a407",path:"/wiki/Reading_Notes/",headers:[{level:2,title:"Optimized C++: proven techniques for heightened performance",slug:"optimized-c-proven-techniques-for-heightened-performance",normalizedTitle:"optimized c++: proven techniques for heightened performance",charIndex:2},{level:2,title:"CH1 基础策略",slug:"ch1-基础策略",normalizedTitle:"ch1 基础策略",charIndex:80},{level:2,title:"Ch2 影响计算机性能的行为",slug:"ch2-影响计算机性能的行为",normalizedTitle:"ch2 影响计算机性能的行为",charIndex:197},{level:2,title:"Ch3 性能测量",slug:"ch3-性能测量",normalizedTitle:"ch3 性能测量",charIndex:442},{level:2,title:"Ch4 字符串优化",slug:"ch4-字符串优化",normalizedTitle:"ch4 字符串优化",charIndex:774},{level:2,title:"Ch5 算法优化",slug:"ch5-算法优化",normalizedTitle:"ch5 算法优化",charIndex:788},{level:2,title:"ch6 动态分配内存的变量优化",slug:"ch6-动态分配内存的变量优化",normalizedTitle:"ch6 动态分配内存的变量优化",charIndex:801},{level:2,title:"ch7 热点语句的优化",slug:"ch7-热点语句的优化",normalizedTitle:"ch7 热点语句的优化",charIndex:821},{level:2,title:"ch8 使用更好的库",slug:"ch8-使用更好的库",normalizedTitle:"ch8 使用更好的库",charIndex:837},{level:2,title:"ch9 优化查找和排序",slug:"ch9-优化查找和排序",normalizedTitle:"ch9 优化查找和排序",charIndex:852},{level:2,title:"ch10 优化数据结构",slug:"ch10-优化数据结构",normalizedTitle:"ch10 优化数据结构",charIndex:868},{level:2,title:"ch11 优化IO",slug:"ch11-优化io",normalizedTitle:"ch11 优化io",charIndex:884},{level:2,title:"ch12 优化并发",slug:"ch12-优化并发",normalizedTitle:"ch12 优化并发",charIndex:898},{level:2,title:"ch13 优化内存管理",slug:"ch13-优化内存管理",normalizedTitle:"ch13 优化内存管理",charIndex:912}],headersStr:"Optimized C++: proven techniques for heightened performance CH1 基础策略 Ch2 影响计算机性能的行为 Ch3 性能测量 Ch4 字符串优化 Ch5 算法优化 ch6 动态分配内存的变量优化 ch7 热点语句的优化 ch8 使用更好的库 ch9 优化查找和排序 ch10 优化数据结构 ch11 优化IO ch12 优化并发 ch13 优化内存管理",content:"# Optimized C++: proven techniques for heightened performance\n\n《C++ 性能优化指南》\n\n\n# CH1 基础策略\n\n 1. 更好的编译器\n 2. 更好的算法\n 3. 更好的库\n 4. 减少内存分配和赋值\n 5. 减少计算密集部分\n 6. 更好的数据结构\n 7. 并发和并行处理;\n 8. 优化内存管理(更好的内存管理库)\n\n\n# Ch2 影响计算机性能的行为\n\n 1. 内存访问的代价是非常大的\n 2. cache miss\n 3. pipeline stall导致cycle被浪费\n 4. 线程切换, 同步的锁的开销,是非常大的;\n 5. 系统调用是昂贵的\n 6. 非对其的字节访问, 开销会很大, 会带来page threading 的效果;\n 7. 计算比分支判断的速度要快;\n 8. 所有的语句并非都是顺序执行.\\\n 9. 也不是所有指令的开销都是一样的, 每个指令所需要的cycle数量应该是不同的;\n\n\n# Ch3 性能测量\n\n 1.  时间测量(timer)是非常必要的\n 2.  CPU硬件profile测量也是有必要的\n 3.  使用profiler工具 找出热点代码\n 4.  90-10, 80-20方法\n 5.  性能优化其实是一种实验\n 6.  算法更优不代表其执行速度就会更快, 因为要考虑到实现时候的效率\n 7.  要有baseline, 要有实验记录, 要有随手记实验数据的习惯;\n 8.  测量延时, 测量吞吐, 测量batch\n 9.  linux上面, 如何进行profile, 原理是什么, 如何进行时间测量, 怎么样测量才会比较精确\n 10. 设置一些matrices, 根据这些指标来指导性能优化;\n 11. profile很重要\n\n\n# Ch4 字符串优化\n\n\n# Ch5 算法优化\n\n\n# ch6 动态分配内存的变量优化\n\n\n# ch7 热点语句的优化\n\n\n# ch8 使用更好的库\n\n\n# ch9 优化查找和排序\n\n\n# ch10 优化数据结构\n\n\n# ch11 优化IO\n\n\n# ch12 优化并发\n\n\n# ch13 优化内存管理",normalizedContent:"# optimized c++: proven techniques for heightened performance\n\n《c++ 性能优化指南》\n\n\n# ch1 基础策略\n\n 1. 更好的编译器\n 2. 更好的算法\n 3. 更好的库\n 4. 减少内存分配和赋值\n 5. 减少计算密集部分\n 6. 更好的数据结构\n 7. 并发和并行处理;\n 8. 优化内存管理(更好的内存管理库)\n\n\n# ch2 影响计算机性能的行为\n\n 1. 内存访问的代价是非常大的\n 2. cache miss\n 3. pipeline stall导致cycle被浪费\n 4. 线程切换, 同步的锁的开销,是非常大的;\n 5. 系统调用是昂贵的\n 6. 非对其的字节访问, 开销会很大, 会带来page threading 的效果;\n 7. 计算比分支判断的速度要快;\n 8. 所有的语句并非都是顺序执行.\\\n 9. 也不是所有指令的开销都是一样的, 每个指令所需要的cycle数量应该是不同的;\n\n\n# ch3 性能测量\n\n 1.  时间测量(timer)是非常必要的\n 2.  cpu硬件profile测量也是有必要的\n 3.  使用profiler工具 找出热点代码\n 4.  90-10, 80-20方法\n 5.  性能优化其实是一种实验\n 6.  算法更优不代表其执行速度就会更快, 因为要考虑到实现时候的效率\n 7.  要有baseline, 要有实验记录, 要有随手记实验数据的习惯;\n 8.  测量延时, 测量吞吐, 测量batch\n 9.  linux上面, 如何进行profile, 原理是什么, 如何进行时间测量, 怎么样测量才会比较精确\n 10. 设置一些matrices, 根据这些指标来指导性能优化;\n 11. profile很重要\n\n\n# ch4 字符串优化\n\n\n# ch5 算法优化\n\n\n# ch6 动态分配内存的变量优化\n\n\n# ch7 热点语句的优化\n\n\n# ch8 使用更好的库\n\n\n# ch9 优化查找和排序\n\n\n# ch10 优化数据结构\n\n\n# ch11 优化io\n\n\n# ch12 优化并发\n\n\n# ch13 优化内存管理",charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"Archives",frontmatter:{archivesPage:!0,title:"Archives",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-04def3fa",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/30, 23:47:28",lastUpdatedTimestamp:1656604048e3},{title:"Category",frontmatter:{categoriesPage:!0,title:"Category",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-faf1db3a",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/07, 21:13:28",lastUpdatedTimestamp:1657199608e3},{title:"编程议题",frontmatter:{pageClass:"notes",title:"编程议题",date:"2022-05-18T01:43:24.000Z",permalink:"/pages/9b7dad/",categories:["Programming"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},sidebar:"auto"},regularPath:"/_posts/Notes/%E7%BC%96%E7%A8%8B%E8%AE%AE%E9%A2%98.html",relativePath:"_posts/Notes/编程议题.md",key:"v-cda71308",path:"/pages/9b7dad/",headersStr:null,content:" 1. 异步？同步？ 阻塞？ 非阻塞？ ==> benchmark\n 2. 进程？线程？协程？ 纤程？ ==> benchmark\n 3. OS系统调度， 性能工程相关的内容",normalizedContent:" 1. 异步？同步？ 阻塞？ 非阻塞？ ==> benchmark\n 2. 进程？线程？协程？ 纤程？ ==> benchmark\n 3. os系统调度， 性能工程相关的内容",charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"时间的力量--惯性以及大尺度的延迟",frontmatter:{title:"时间的力量--惯性以及大尺度的延迟",date:"2021-08-05T00:00:00.000Z",sidebar:!1,categories:["writing"],tags:["sayhi"],permalink:"/pages/dcdff1/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/_posts/Writing/thePowerOfTime.html",relativePath:"_posts/Writing/thePowerOfTime.md",key:"v-f6245f3a",path:"/pages/dcdff1/",headers:[{level:4,title:"一件坏的事情发生，往往都是一点一点慢慢变坏的",slug:"一件坏的事情发生-往往都是一点一点慢慢变坏的",normalizedTitle:"一件坏的事情发生，往往都是一点一点慢慢变坏的",charIndex:2},{level:3,title:"你知道的越多， 不知道的也就越多",slug:"你知道的越多-不知道的也就越多",normalizedTitle:"你知道的越多， 不知道的也就越多",charIndex:311},{level:3,title:"拥抱生活， 拥抱快乐",slug:"拥抱生活-拥抱快乐",normalizedTitle:"拥抱生活， 拥抱快乐",charIndex:664}],excerpt:'<h4 id="一件坏的事情发生-往往都是一点一点慢慢变坏的"><a class="header-anchor" href="#一件坏的事情发生-往往都是一点一点慢慢变坏的">#</a> <strong>一件坏的事情发生，往往都是一点一点慢慢变坏的</strong></h4>\n',headersStr:"一件坏的事情发生，往往都是一点一点慢慢变坏的 你知道的越多， 不知道的也就越多 拥抱生活， 拥抱快乐",content:"# 一件坏的事情发生，往往都是一点一点慢慢变坏的\n\n可能是随着年龄变大，也有可能是自己solo的时间过长，其实你是能够感觉到时间的力量的，比如说一件坏的事情发生，往往都是一点一点慢慢变坏的，这中间有对自己的纵容，有对自己时间的纵容，有对自己情绪的纵容，但终归这种纵容，会带来坏的结果\n\n但是你又急不得改正，因为即使去改正，也不会立马有什么效果，现实中，当你想纠正错误的时候，不会立即蹦出来一个机会让你验证，你已经改正了，\n\n而且，当过了许久机会来了的时候，往往自己又已经忘了上次的教训\n\n当你知道生命没有意义的时候， 生命要如何继续下去？生命的意义是一团熊熊燃烧的欲望。真的是形而上的吗？真的全部都是理性主义吗？\n\n\n# 你知道的越多， 不知道的也就越多\n\n不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n\n# 拥抱生活， 拥抱快乐\n\n> 当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n> \n> 不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n> \n> 所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n> \n> 如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n> \n> 所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n> \n> 摘录自:B站视频《罗翔说刑法》，链接https://b23.tv/K8ulrE",normalizedContent:"# 一件坏的事情发生，往往都是一点一点慢慢变坏的\n\n可能是随着年龄变大，也有可能是自己solo的时间过长，其实你是能够感觉到时间的力量的，比如说一件坏的事情发生，往往都是一点一点慢慢变坏的，这中间有对自己的纵容，有对自己时间的纵容，有对自己情绪的纵容，但终归这种纵容，会带来坏的结果\n\n但是你又急不得改正，因为即使去改正，也不会立马有什么效果，现实中，当你想纠正错误的时候，不会立即蹦出来一个机会让你验证，你已经改正了，\n\n而且，当过了许久机会来了的时候，往往自己又已经忘了上次的教训\n\n当你知道生命没有意义的时候， 生命要如何继续下去？生命的意义是一团熊熊燃烧的欲望。真的是形而上的吗？真的全部都是理性主义吗？\n\n\n# 你知道的越多， 不知道的也就越多\n\n不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n\n# 拥抱生活， 拥抱快乐\n\n> 当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n> \n> 不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n> \n> 所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n> \n> 如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n> \n> 所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n> \n> 摘录自:b站视频《罗翔说刑法》，链接https://b23.tv/k8ulre",charsets:{cjk:!0},lastUpdated:"2023/03/11, 02:29:02",lastUpdatedTimestamp:1678472942e3},{title:"Tags",frontmatter:{tagsPage:!0,title:"Tags",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-b1c16cfa",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/30, 23:47:28",lastUpdatedTimestamp:1656604048e3},{title:"Why you have to write",frontmatter:{title:"Why you have to write",date:"2020-05-15T00:00:00.000Z",sidebar:!1,sticky:1,categories:["writing"],tags:["sayhi"],permalink:"/pages/cc9a5c/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/_posts/Writing/WhyYouHave2Write.html",relativePath:"_posts/Writing/WhyYouHave2Write.md",key:"v-1bf730e3",path:"/pages/cc9a5c/",excerpt:"<p>为什么你应该把脑子里面的东西写下来? 脑子里面会有一闪而过的一些很棒的想法?<br>\n为什么你想了那么多，却不能把自己的想法绑定成一个有意义的事物?<br>\n有些事情你真的想透了吗？为什么有些事情你总是想不透？</p>\n",headersStr:null,content:'为什么你应该把脑子里面的东西写下来? 脑子里面会有一闪而过的一些很棒的想法?\n为什么你想了那么多，却不能把自己的想法绑定成一个有意义的事物?\n有些事情你真的想透了吗？为什么有些事情你总是想不透？\n\n> If you learn to write and to edit, you will also be able to tell the difference between good ideas, intelligently presented, and bad ideas put forth by murky and unskilled thinkers. That means that you will be able to separate the wheat from the chaff (look it up). Then you can be properly influenced by profound and solid ideas instead of falling prey to foolish fads and whims and ideologies, which can range in their danger from trivial to mortal.\n> \n> Those who can think and communicate are simply more powerful than those who cannot, and powerful in the good way, the way that means “able to do a wide range of things competently and efficiently.” Furthermore, the further up the ladder of competence you climb, with your well-formulated thoughts, the more important thinking and communicating become. At the very top of the most complex hierarchies (law, medicine, academia, business, theology, politics) nothing is more necessary and valuable. If you can think and communicate, you can also defend yourself, and your friends and family, when that becomes necessary, and it will become necessary at various points in your life.\n> \n> Finally, it is useful to note that your mind is organized verbally, at the highest and most abstract levels. Thus, if you learn to think, through writing, then you will develop a well organized, efficient mind – and one that is well-founded and certain. This also means that you will be healthier, mentally and physically, as lack of clarity and ignorance means unnecessary stress. Unnecessary stress makes your body react more to what could otherwise be treated as trivial affairs. This makes for excess energy expenditure, and more rapid aging (along with all the negative health-related consequences of aging)\n> \n> -- Essay Writing Guide by Jordan B. Peterson\n\n\n\n自己关于写作的记忆, 最早的一件事情应该是小学三年级的时候, 那时候我的语文老师姓余, 也是我们的班主任, 三年级有一个期末考试, 期末考试的语文作文, 我拿了一个满分, 小学三年级语文期末考试, 也是第一次有作文出现的期末考试,在这之前的语文,就只有句子和字词的题目, 人生第一场语文期末考试, 作文拿了满分,与老师表扬了我, 我想我妈妈应该也是知道的, 当时并不觉得这有什么特别的含义, 只是觉得, 这是一个好的开始, 以及小孩子拿了第一名的那种喜悦.\n\n(我记得那个时候, 不记得是二年级还是三年级了, 但还是在小学老教学楼时候, 有一年好像语文数学的期末考试考得很好, 但是没有到双百,没有达成和爸妈的约定,所以也让爸妈给买一个什么东西, 具体约定的内容, 已经不记得是什么了)\n\n我们家以前是住在小县城的一个比较拐角的地方, 高一那年我们家从县城的南面靠山的地方, 搬到了县城比较靠中间的地方, 也就是说, 小学六年级和初中的绝大部分时间, 我们家都住在以前爷爷留下来的老房子里面, 房子是以前爷爷单位的员工宿舍， 后来由于单位破产, 改为私人拥有, 所以职工的宿舍也就便宜卖给了各家各户.\n\n我们初中那个时候, 其实郭敬明和韩寒的小说, 应该是最火的时候, 那时候有最小说, 最小说旗下是有不少新生代的作者, 有落落, 安东尼等等, 说到这里,大家可能会觉得我会说和他们之间产生了某种联系,\n\n其实不是, 很自然的时候,那个时候大家都是情窦初开, 多愁善感的年纪里面, 总是会莫名奇妙地产生很多很多情愫, 我真的不记得是六年级, 还是初中的时候, 想开始自己写点东西, 因为六年级和初中, 都是在旧房子里面度过的, 所以这一块的时间节点, 有点模糊了, 但是我猜想应该是初一或者是初二, 虽然那时候自己想写的还是类似于郑渊洁作品那样的现代童话, 但是有一些场景, 比如县城的大桥, 东方红广场之类的, 应该是初中时候比较常去的地方了.\n\n那时候就想自己写点东西, 希望能有自己的一些作品出来, 我想这里面很大一部分原因是那个时候其实初中生或者六年级学生, 并没有多少的课外消遣活动, 那个时候电脑其实也还不怎么普及,整个班上, 家里有电脑的同学其实也还是不多的, 即使有电脑, 但是网络上面的娱乐内容, 也没有现在这样泛滥. 那个时候, 像我这样, 家境一般, 父母又管的严的孩子, 其实唯一"合法", 又有资源的, 就是阅读了, 所以大家对与读物中的作者, 其实是有很多很多类似于现在追星的那种情感, 之所以我想写点东西, 更多可能是因为希望同龄人能够读到自己的东西, 想在同龄人里面脱颖而出. (大学之后, 基本上大家就开始崇拜学习好,成绩优秀,以及平时活动表现突出的这种典型了,好像阅读的人越来越少, 另外,追星的潮流也比之前更加涌动了).\n\n当时想写点东西, 还得是用笔去写, 电脑都不普及,更不用说是笔记本电脑了,我记得, 那个时候还缠着母亲在县城的超市,专门买了一本比较厚的本子, 母亲说很薄的本子就可以了, 当时不乐意, 最终还是缠着母亲买了很厚的一个本子, 回来准备写一个一众朋友结伴去探险的故事, 我想那个时候应该是读了很多淘气包马小跳， 皮皮鲁之类的故事， 所以特别想自己写一个， 把自己和要好的朋友带入进去， 一定是很酷的一件事情，\n\n很有意思的是， 在写作之前， 花了很多时间在纠结要选择身边哪些朋友和自己一起开始“我们的旅途”这件事情上面，带哪些朋友一起上路在这件事情上面成为了一个问题。\n\n小孩子身上， 我想最可贵的一些品质是持之以恒， 尤其是在心性的磨练上面，对于自己越做越痛苦， 或者不太愿意取做，但是知道是对的事情，训练自己的心性如何坚持下去， 是非常重要的， 而就在这件事情上面，我就表现得特别不能持之以恒， 写这个故事前后应该也没有坚持一个星期，最后也就不了了之了， 但是那个本子， 似乎很久之后都还有看到，现在不知道还在不在了， 希望有一天能够回去找到这个东西，拿出来翻一翻看一看， 这应该是自己关于写作最后一次回忆起来较为舒适的会议了。\n\n上了高中之后， 语文成绩极度不理想， 好像整个高中语文成绩及格的次数，应该是一双手能够数的出来的， 其实高一的时候身边很多同学都会觉得高中语文比初中语文难很多， 所以高一的时候大家语文成绩都会有一个明显的塌陷， 有的人适应得快， 有的人适应得很慢， 而我好像一直适应到了高三。\n\n高中语文对我很难， 一方面自己并没有什么意识，一方面也没有什么努力，一直到高考前夕，才进行有针对性地学习， 我记得高三已经到比较紧张的时候， 我们的语文老师在一次卷子点评上面，在批评同样班里语文最差劲的几位同学的时候，说就连我的作文都开始看得懂了， 不像以前那样一塌糊涂了，有进步了， 为什么他们几个还是不见起色呢。那个时刻， 我是以反面角色出现地比较多。\n\n再之后， 就没有之后了， 之后就是大学上的是理工科， 写的报告几乎都是固定的格式，流程， 所以大学时候很多的实验报告，有的是抄的，有的是组队参赛其他组员写的， 再之后就是本科毕业论文， 研究生发表论文， 研究生毕业论文。\n\n研究生需要发表论文才能够毕业， 那段时间开始用英文写作， 才发现自己其实根本没有逻辑， 其实我们中的大多数人， 写东西说话， 都十分缺乏逻辑。\n\n如果不相信， 你可以试一试， 找人以对方的标准改一改， 我想你会相信的。你不仅会相信自己没有逻辑，而且你会相信不同人之间的逻辑，差别大得惊人。\n\n研究生的时候， 我的导师有一个习惯，就是每次找他问问题， 都需要准备一个ppt，即使是两个人一对一地交谈， 也需要一个ppt， 我一开始其实是十分不理解，也十分厌烦的， 这中间没有少吐槽我的导师， 但是积累时间长了之后， 大概过了一年到两年之后， 我意识到了这么做的一个重大的好处是， 自己的内容输出的质量会越来越高，这其实和写程序在某些方面其实很像，都有一个迭代的过程， 一个程序如果上来就想得十分完美，其实是非常困难的，但是如果不考虑太完美， 从基本得功能做起， 每天改进一点， 假以时日，这个东西就会看上去比较不错了。 后来写论文的时候，很多的文字性的材料， 文献， 甚至包括大脑里面的之前总结的一些观点， 都是可以拿过来直接用的， 如果真的要让我那么短的时间里面， 总结凝练出什么特别好的观点， 其实也是不现实的。\n\n写作， 相当与把思考阶段性备份下来， 如果不备份， 那么容量有限， 再有更多好的想法就丢失了\n\n工作到现在已经一年四个月了，实际上手头的工作压力还是比较大的， 但是自己心里面关于写作, 总结, 凝练这些事情， 都还是记着的， 但是由于工作压力还是比较大的， 很多时间都花在周边的学习上面了， 懒惰的我迟迟没有动笔。\n\n我觉得现在有下面一些东西需要持续进行更新和总结的：\n\n * 高性能计算编程\n * 分布式系统\n * 网络编程\n * 编译器\n * 操作系统\n * Web系统搭建\n   * 前端\n   * 后端\n   * 数据库\n\n暂时有一些内容， 是希望能够长期更新， 并弄成一个系列文章或者手册教程， 或者项目实践的\n\n * 高性能计算， 理论与实践\n * 编译器中后端， 理论与实践\n * linux操作系统内核， 理论与实践\n * web系统（商城与宣传页）， 理论与实践，可视化分析\n * Quant与时间序列分析\n\n一些前沿一些的survey工作， 希望聚焦在：\n\n * AI sys / Distributed system / HPC\n * CV / NLP / Timeseries Analysis & Computing\n * Computational Social Science\n * 以及上面各个方向研究组的世界分布\n\n其余的内容， 希望关注认知科学， 心理学， 社会，政治， 经济和金融上面， 这些软科学其实更深层次地揭露了世界的运行规律， 所以更加需要了解， 这些可能就会作为笔记内容， 出现在博客生面了， 因为确实自己是一个小白， 需要从最基本的一些概念和知识入手。\n\n程序员和博客\n\n我觉得， 通过博客写作这件事情， 对程序员或者是其他相关的技术人员来说也是是很重要的， 但是为什么很多程序员没有开始自己的写作路途呢？ 我想这是很多方面的原因， 从大的方面到小的方面，都有很多原因，但是我想，对于程序员来说， 有一个很重要的原因是， 由于职业的属性他们在博客系统上面， 折腾了太多了， 相反你看看大牛的博客， 真正写起来的经营还不错并且有一定影响力的博客， 设计上面感觉都是上古画风。\n\n程序员自己可以从头到尾搭建一个web系统， 来打造自己的博客系统，但是实际上， 给别人用的技术， 和给自己用的平台，需要区分开， 不能够因为自己掌握了手机制造的所有技术， 就选择自己从头造一个iphone出来， 这是不划算的， 博客的核心思想， 应该是写作，归纳，展示， 要专注在内容上面， 反而如果博客系统弄得非常华丽， 内容又没有什么干货的话， 其实是非常典型的让人诟病的的一点。\n\n我想这一点，可能阻挡了将近1/3的人， 其他关于为什么想做而迟迟没做的理由， 可能需要另外开辟一个主题来讨论了。',normalizedContent:'为什么你应该把脑子里面的东西写下来? 脑子里面会有一闪而过的一些很棒的想法?\n为什么你想了那么多，却不能把自己的想法绑定成一个有意义的事物?\n有些事情你真的想透了吗？为什么有些事情你总是想不透？\n\n> if you learn to write and to edit, you will also be able to tell the difference between good ideas, intelligently presented, and bad ideas put forth by murky and unskilled thinkers. that means that you will be able to separate the wheat from the chaff (look it up). then you can be properly influenced by profound and solid ideas instead of falling prey to foolish fads and whims and ideologies, which can range in their danger from trivial to mortal.\n> \n> those who can think and communicate are simply more powerful than those who cannot, and powerful in the good way, the way that means “able to do a wide range of things competently and efficiently.” furthermore, the further up the ladder of competence you climb, with your well-formulated thoughts, the more important thinking and communicating become. at the very top of the most complex hierarchies (law, medicine, academia, business, theology, politics) nothing is more necessary and valuable. if you can think and communicate, you can also defend yourself, and your friends and family, when that becomes necessary, and it will become necessary at various points in your life.\n> \n> finally, it is useful to note that your mind is organized verbally, at the highest and most abstract levels. thus, if you learn to think, through writing, then you will develop a well organized, efficient mind – and one that is well-founded and certain. this also means that you will be healthier, mentally and physically, as lack of clarity and ignorance means unnecessary stress. unnecessary stress makes your body react more to what could otherwise be treated as trivial affairs. this makes for excess energy expenditure, and more rapid aging (along with all the negative health-related consequences of aging)\n> \n> -- essay writing guide by jordan b. peterson\n\n\n\n自己关于写作的记忆, 最早的一件事情应该是小学三年级的时候, 那时候我的语文老师姓余, 也是我们的班主任, 三年级有一个期末考试, 期末考试的语文作文, 我拿了一个满分, 小学三年级语文期末考试, 也是第一次有作文出现的期末考试,在这之前的语文,就只有句子和字词的题目, 人生第一场语文期末考试, 作文拿了满分,与老师表扬了我, 我想我妈妈应该也是知道的, 当时并不觉得这有什么特别的含义, 只是觉得, 这是一个好的开始, 以及小孩子拿了第一名的那种喜悦.\n\n(我记得那个时候, 不记得是二年级还是三年级了, 但还是在小学老教学楼时候, 有一年好像语文数学的期末考试考得很好, 但是没有到双百,没有达成和爸妈的约定,所以也让爸妈给买一个什么东西, 具体约定的内容, 已经不记得是什么了)\n\n我们家以前是住在小县城的一个比较拐角的地方, 高一那年我们家从县城的南面靠山的地方, 搬到了县城比较靠中间的地方, 也就是说, 小学六年级和初中的绝大部分时间, 我们家都住在以前爷爷留下来的老房子里面, 房子是以前爷爷单位的员工宿舍， 后来由于单位破产, 改为私人拥有, 所以职工的宿舍也就便宜卖给了各家各户.\n\n我们初中那个时候, 其实郭敬明和韩寒的小说, 应该是最火的时候, 那时候有最小说, 最小说旗下是有不少新生代的作者, 有落落, 安东尼等等, 说到这里,大家可能会觉得我会说和他们之间产生了某种联系,\n\n其实不是, 很自然的时候,那个时候大家都是情窦初开, 多愁善感的年纪里面, 总是会莫名奇妙地产生很多很多情愫, 我真的不记得是六年级, 还是初中的时候, 想开始自己写点东西, 因为六年级和初中, 都是在旧房子里面度过的, 所以这一块的时间节点, 有点模糊了, 但是我猜想应该是初一或者是初二, 虽然那时候自己想写的还是类似于郑渊洁作品那样的现代童话, 但是有一些场景, 比如县城的大桥, 东方红广场之类的, 应该是初中时候比较常去的地方了.\n\n那时候就想自己写点东西, 希望能有自己的一些作品出来, 我想这里面很大一部分原因是那个时候其实初中生或者六年级学生, 并没有多少的课外消遣活动, 那个时候电脑其实也还不怎么普及,整个班上, 家里有电脑的同学其实也还是不多的, 即使有电脑, 但是网络上面的娱乐内容, 也没有现在这样泛滥. 那个时候, 像我这样, 家境一般, 父母又管的严的孩子, 其实唯一"合法", 又有资源的, 就是阅读了, 所以大家对与读物中的作者, 其实是有很多很多类似于现在追星的那种情感, 之所以我想写点东西, 更多可能是因为希望同龄人能够读到自己的东西, 想在同龄人里面脱颖而出. (大学之后, 基本上大家就开始崇拜学习好,成绩优秀,以及平时活动表现突出的这种典型了,好像阅读的人越来越少, 另外,追星的潮流也比之前更加涌动了).\n\n当时想写点东西, 还得是用笔去写, 电脑都不普及,更不用说是笔记本电脑了,我记得, 那个时候还缠着母亲在县城的超市,专门买了一本比较厚的本子, 母亲说很薄的本子就可以了, 当时不乐意, 最终还是缠着母亲买了很厚的一个本子, 回来准备写一个一众朋友结伴去探险的故事, 我想那个时候应该是读了很多淘气包马小跳， 皮皮鲁之类的故事， 所以特别想自己写一个， 把自己和要好的朋友带入进去， 一定是很酷的一件事情，\n\n很有意思的是， 在写作之前， 花了很多时间在纠结要选择身边哪些朋友和自己一起开始“我们的旅途”这件事情上面，带哪些朋友一起上路在这件事情上面成为了一个问题。\n\n小孩子身上， 我想最可贵的一些品质是持之以恒， 尤其是在心性的磨练上面，对于自己越做越痛苦， 或者不太愿意取做，但是知道是对的事情，训练自己的心性如何坚持下去， 是非常重要的， 而就在这件事情上面，我就表现得特别不能持之以恒， 写这个故事前后应该也没有坚持一个星期，最后也就不了了之了， 但是那个本子， 似乎很久之后都还有看到，现在不知道还在不在了， 希望有一天能够回去找到这个东西，拿出来翻一翻看一看， 这应该是自己关于写作最后一次回忆起来较为舒适的会议了。\n\n上了高中之后， 语文成绩极度不理想， 好像整个高中语文成绩及格的次数，应该是一双手能够数的出来的， 其实高一的时候身边很多同学都会觉得高中语文比初中语文难很多， 所以高一的时候大家语文成绩都会有一个明显的塌陷， 有的人适应得快， 有的人适应得很慢， 而我好像一直适应到了高三。\n\n高中语文对我很难， 一方面自己并没有什么意识，一方面也没有什么努力，一直到高考前夕，才进行有针对性地学习， 我记得高三已经到比较紧张的时候， 我们的语文老师在一次卷子点评上面，在批评同样班里语文最差劲的几位同学的时候，说就连我的作文都开始看得懂了， 不像以前那样一塌糊涂了，有进步了， 为什么他们几个还是不见起色呢。那个时刻， 我是以反面角色出现地比较多。\n\n再之后， 就没有之后了， 之后就是大学上的是理工科， 写的报告几乎都是固定的格式，流程， 所以大学时候很多的实验报告，有的是抄的，有的是组队参赛其他组员写的， 再之后就是本科毕业论文， 研究生发表论文， 研究生毕业论文。\n\n研究生需要发表论文才能够毕业， 那段时间开始用英文写作， 才发现自己其实根本没有逻辑， 其实我们中的大多数人， 写东西说话， 都十分缺乏逻辑。\n\n如果不相信， 你可以试一试， 找人以对方的标准改一改， 我想你会相信的。你不仅会相信自己没有逻辑，而且你会相信不同人之间的逻辑，差别大得惊人。\n\n研究生的时候， 我的导师有一个习惯，就是每次找他问问题， 都需要准备一个ppt，即使是两个人一对一地交谈， 也需要一个ppt， 我一开始其实是十分不理解，也十分厌烦的， 这中间没有少吐槽我的导师， 但是积累时间长了之后， 大概过了一年到两年之后， 我意识到了这么做的一个重大的好处是， 自己的内容输出的质量会越来越高，这其实和写程序在某些方面其实很像，都有一个迭代的过程， 一个程序如果上来就想得十分完美，其实是非常困难的，但是如果不考虑太完美， 从基本得功能做起， 每天改进一点， 假以时日，这个东西就会看上去比较不错了。 后来写论文的时候，很多的文字性的材料， 文献， 甚至包括大脑里面的之前总结的一些观点， 都是可以拿过来直接用的， 如果真的要让我那么短的时间里面， 总结凝练出什么特别好的观点， 其实也是不现实的。\n\n写作， 相当与把思考阶段性备份下来， 如果不备份， 那么容量有限， 再有更多好的想法就丢失了\n\n工作到现在已经一年四个月了，实际上手头的工作压力还是比较大的， 但是自己心里面关于写作, 总结, 凝练这些事情， 都还是记着的， 但是由于工作压力还是比较大的， 很多时间都花在周边的学习上面了， 懒惰的我迟迟没有动笔。\n\n我觉得现在有下面一些东西需要持续进行更新和总结的：\n\n * 高性能计算编程\n * 分布式系统\n * 网络编程\n * 编译器\n * 操作系统\n * web系统搭建\n   * 前端\n   * 后端\n   * 数据库\n\n暂时有一些内容， 是希望能够长期更新， 并弄成一个系列文章或者手册教程， 或者项目实践的\n\n * 高性能计算， 理论与实践\n * 编译器中后端， 理论与实践\n * linux操作系统内核， 理论与实践\n * web系统（商城与宣传页）， 理论与实践，可视化分析\n * quant与时间序列分析\n\n一些前沿一些的survey工作， 希望聚焦在：\n\n * ai sys / distributed system / hpc\n * cv / nlp / timeseries analysis & computing\n * computational social science\n * 以及上面各个方向研究组的世界分布\n\n其余的内容， 希望关注认知科学， 心理学， 社会，政治， 经济和金融上面， 这些软科学其实更深层次地揭露了世界的运行规律， 所以更加需要了解， 这些可能就会作为笔记内容， 出现在博客生面了， 因为确实自己是一个小白， 需要从最基本的一些概念和知识入手。\n\n程序员和博客\n\n我觉得， 通过博客写作这件事情， 对程序员或者是其他相关的技术人员来说也是是很重要的， 但是为什么很多程序员没有开始自己的写作路途呢？ 我想这是很多方面的原因， 从大的方面到小的方面，都有很多原因，但是我想，对于程序员来说， 有一个很重要的原因是， 由于职业的属性他们在博客系统上面， 折腾了太多了， 相反你看看大牛的博客， 真正写起来的经营还不错并且有一定影响力的博客， 设计上面感觉都是上古画风。\n\n程序员自己可以从头到尾搭建一个web系统， 来打造自己的博客系统，但是实际上， 给别人用的技术， 和给自己用的平台，需要区分开， 不能够因为自己掌握了手机制造的所有技术， 就选择自己从头造一个iphone出来， 这是不划算的， 博客的核心思想， 应该是写作，归纳，展示， 要专注在内容上面， 反而如果博客系统弄得非常华丽， 内容又没有什么干货的话， 其实是非常典型的让人诟病的的一点。\n\n我想这一点，可能阻挡了将近1/3的人， 其他关于为什么想做而迟迟没做的理由， 可能需要另外开辟一个主题来讨论了。',charsets:{cjk:!0},lastUpdated:"2022/07/18, 01:15:26",lastUpdatedTimestamp:1658078126e3},{title:"Home",frontmatter:{home:!0},regularPath:"/",relativePath:"index.md",key:"v-e5b4aac8",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/11, 02:20:56",lastUpdatedTimestamp:1678472456e3}],themeConfig:{nav:[{text:"Home",link:"/"},{text:"Wiki",link:"/wiki/",items:[{text:"Program",items:[{text:"Lean in C++",link:"/wiki/lean_in_c++/"}]},{text:"Perfromance Engineering",items:[{text:"[>>>>>]",link:"/wiki/Performance_Engineering/"}]},{text:"Reading Note",items:[{text:"[>>>>>]",link:"/wiki/Reading_Notes/"}]},{text:"ComputeArch",items:[{text:"[_]"}]},{text:"Compiler",items:[{text:"[_]"}]},{text:"System",items:[{text:"[_]"}]}]},{text:"Authoring",link:"/authoring/"},{text:"Archives",link:"/archives/",items:[{text:"Categories",link:"/categories/"},{text:"Tags",link:"/tags/"}]}],sidebar:{"/00.NavBar/":[["01.Wiki.md","Wiki","/wiki/"],["02.Authoring.md","Authoring","/authoring/"]],catalogue:{Wiki:"/wiki/",Authoring:"/authoring/"},"/01.Wiki/":[{title:"Lean in c++",collapsable:!0,children:[["01.Lean in c++/00.ReadMe.md","Lean in C++","/wiki/lean_in_c++/"],{title:"Phase_0:Glimpse",collapsable:!0,children:[["01.Lean in c++/01.Phase_0:Glimpse/00.C++ Glimpse.md","C++ Glimpse","/pages/8744f7/"],["01.Lean in c++/01.Phase_0:Glimpse/01.type cast.md","type cast","/pages/409de3/"],["01.Lean in c++/01.Phase_0:Glimpse/02.typedef.md","typedef","/pages/ab4daf/"],["01.Lean in c++/01.Phase_0:Glimpse/03.typename vs class.md","class vs. typename","/pages/2b0a8f/"],["01.Lean in c++/01.Phase_0:Glimpse/04.const.md","const","/pages/b9de04/"],["01.Lean in c++/01.Phase_0:Glimpse/05.extern.md","extern","/pages/5bac8e/"],["01.Lean in c++/01.Phase_0:Glimpse/06.pointer.md","pointer","/pages/c08a6e/"],["01.Lean in c++/01.Phase_0:Glimpse/07.static.md","static","/pages/9b131d/"],["01.Lean in c++/01.Phase_0:Glimpse/08.volatile.md","volatile","/pages/598385/"],["01.Lean in c++/01.Phase_0:Glimpse/09.inline.md","inline","/pages/91242f/"],["01.Lean in c++/01.Phase_0:Glimpse/10.assert.md","assert","/pages/efbaf4/"],["01.Lean in c++/01.Phase_0:Glimpse/11.void.md","void","/pages/b4d0b6/"],["01.Lean in c++/01.Phase_0:Glimpse/12.__global__.md","__global__","/pages/fc5419/"]]}]},{title:"Performance Engineering",collapsable:!0,children:[["02.Performance Engineering/01.Perf.md","Comming soon","/wiki/Performance_Engineering/"]]},{title:"Misc",collapsable:!0,children:[["10.Misc/01.Chrome.md","Chrome 非常规操作","/pages/41a6c9/"],["10.Misc/02.VsCode.md","VsCode 常用插件","/pages/6f0fa2/"]]},{title:"Reading Notes",collapsable:!0,children:[["19.Reading Notes/01.Effective_C++.md","《Effective C++》","/pages/fb2fc1/"],["19.Reading Notes/02.More_Effective_C++.md","《More Effective C++》","/pages/e1ff7c/"],["19.Reading Notes/03.C++性能优化指南.md","《C++ 性能优化指南》","/wiki/Reading_Notes/"]]}]},sidebarDepth:2,repo:"Quincy-J",searchMaxSuggestions:10,lastUpdated:"Last updated",docsDir:"docs",editLinks:!1,editLinkText:"Edit",pageStyle:"line",defaultMode:"read",bodyBgImg:["https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200507175846.jpeg"],bodyBgImgOpacity:.6,updateBar:{showToArticle:!1,moreArticle:"/archives"},author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},blogger:{avatar:"/img/github_profile_2_1.jpg",name:"Quincy Jet",slogan:"We are."},social:{icons:[{iconClass:"icon-youjian",title:"E-Mail",link:"mailto:quincy_jet@outlook.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/Quincy-J"}]},footer:{createYear:2017,copyrightInfo:'Quincy Jet | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a>'},extendFrontmatter:{author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}}},locales:{"/":{lang:"en-US",title:"1ms Faster",description:"Software performace profile/analysis/optimization",path:"/"}}};var Zs=e(92),nc=e(93),tc=e(11);var ec={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:t,article:e,home:r}}=n;return!(t||!1===e||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,t)=>{const e=n.frontmatter.sticky,r=t.frontmatter.sticky;return e&&r?e==r?Object(tc.a)(n,t):e-r:e&&!r?-1:!e&&r?1:Object(tc.a)(n,t)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,t)=>Object(tc.a)(n,t)),n;var n},$groupPosts(){return function(n){const t={},e={};for(let r=0,i=n.length;r<i;r++){const{frontmatter:{categories:i,tags:a}}=n[r];"array"===Object(tc.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))}),"array"===Object(tc.n)(a)&&a.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))})}return{categories:t,tags:e}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const t=[],e=[];for(let e in n.categories)t.push({key:e,length:n.categories[e].length});for(let t in n.tags)e.push({key:t,length:n.tags[t].length});return{categories:t,tags:e}}(this.$groupPosts)}}};zi.component(Zs.default),zi.component(nc.default);function rc(n){return n.toString().padStart(2,"0")}e(235);zi.component("Badge",()=>Promise.all([e.e(0),e.e(4)]).then(e.bind(null,354))),zi.component("CodeBlock",()=>Promise.resolve().then(e.bind(null,92))),zi.component("CodeGroup",()=>Promise.resolve().then(e.bind(null,93)));e(236);var ic=[({Vue:n,options:t,router:e,siteData:r})=>{},({Vue:n,options:t,router:e,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:t,author:e}}=n;"string"==typeof t&&"Z"===t.charAt(t.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${rc(n.getUTCMonth()+1)}-${rc(n.getUTCDate())} ${rc(n.getUTCHours())}:${rc(n.getUTCMinutes())}:${rc(n.getUTCSeconds())}`}(t)),e?n.author=e:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(ec)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),t=window.location.protocol.split(":")[0];n.src="https"===t?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}()},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],ac=[];class oc extends class{constructor(){this.store=new zi({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,t){zi.set(this.store.state,n,t)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(oc.prototype,{getPageAsyncComponent:Do,getLayoutAsyncComponent:No,getAsyncComponent:Bo,getVueComponent:Uo});var sc={install(n){const t=new oc;n.$vuepress=t,n.prototype.$vuepress=t}};function cc(n,t){const e=t.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===e)}var lc={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const t=this.pageKey||this.$parent.$page.key;return Fo("pageKey",t),zi.component(t)||zi.component(t,Do(t)),zi.component(t)?n(t):n("")}},uc={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:t,slots:e})=>n("div",{class:["content__"+t.slotKey]},e()[t.slotKey])},pc={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},dc=(e(237),e(238),Object(Js.a)(pc,(function(){var n=this.$createElement,t=this._self._c||n;return t("span",[t("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[t("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),t("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),t("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),fc={functional:!0,render(n,{parent:t,children:e}){if(t._isMounted)return e;t.$once("hook:mounted",()=>{t.$forceUpdate()})}};zi.config.productionTip=!1,zi.use(Co),zi.use(sc),zi.mixin(function(n,t,e=zi){!function(n){n.locales&&Object.keys(n.locales).forEach(t=>{n.locales[t].path=t});Object.freeze(n)}(t),e.$vuepress.$set("siteData",t);const r=new(n(e.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),a={};return Object.keys(i).reduce((n,t)=>(t.startsWith("$")&&(n[t]=i[t].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let t,e;for(const r in n)"/"===r?e=n[r]:0===this.$page.path.indexOf(r)&&(t=n[r]);return t||e||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:t}=this.$page.frontmatter;if("string"==typeof t)return t;const e=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return e?r?r+" | "+e:e:r||"VuePress"}get $description(){const n=function(n){if(n){const t=n.filter(n=>"description"===n.name)[0];if(t)return t.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(r.path.toLowerCase()===t.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},Xs)),zi.component("Content",lc),zi.component("ContentSlotsDistributor",uc),zi.component("OutboundLink",dc),zi.component("ClientOnly",fc),zi.component("Layout",No("Layout")),zi.component("NotFound",No("NotFound")),zi.prototype.$withBase=function(n){const t=this.$site.base;return"/"===n.charAt(0)?t+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"f0aa619"},async function(n){const t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Xs.routerBase||Xs.base,e=new Co({base:t,mode:"history",fallback:!1,routes:Ks,scrollBehavior:(n,t,e)=>e||(n.hash?!zi.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((t,e,r)=>{if(cc(n,t.path))r();else if(/(\/|\.html)$/.test(t.path))if(/\/$/.test(t.path)){const e=t.path.replace(/\/$/,"")+".html";cc(n,e)?r(e):r()}else r();else{const e=t.path+"/",i=t.path+".html";cc(n,i)?r(i):cc(n,e)?r(e):r()}})}(e);const r={};try{await Promise.all(ic.filter(n=>"function"==typeof n).map(t=>t({Vue:zi,options:r,router:e,siteData:Xs,isServer:n})))}catch(n){console.error(n)}return{app:new zi(Object.assign(r,{router:e,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},ac.map(t=>n(t)))])})),router:e}}(!1).then(({app:n,router:t})=>{t.onReady(()=>{n.$mount("#app")})})}]);