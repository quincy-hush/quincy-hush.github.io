(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var i,o,s=e[0],c=e[1],l=e[2],p=0,d=[];p<s.length;p++)o=s[p],Object.prototype.hasOwnProperty.call(r,o)&&r[o]&&d.push(r[o][0]),r[o]=0;for(i in c)Object.prototype.hasOwnProperty.call(c,i)&&(n[i]=c[i]);for(u&&u(e);d.length;)d.shift()();return a.push.apply(a,l||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],i=!0,s=1;s<t.length;s++){var c=t[s];0!==r[c]&&(i=!1)}i&&(a.splice(e--,1),n=o(o.s=t[0]))}return n}var i={},r={1:0},a=[];function o(e){if(i[e])return i[e].exports;var t=i[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var i=new Promise((function(e,i){t=r[n]=[e,i]}));e.push(t[2]=i);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"0eed2333",3:"1c18827c",4:"a222ae79",5:"d89070b9",6:"1e60fa96",7:"dd5c479a",8:"8f5af31a",9:"77bda456",10:"6521a7ab",11:"b5dffaf5",12:"8c885184",13:"aeca5c08",14:"531e8cc9",15:"e1d4e55a",16:"b5733294",17:"6ebbc744",18:"70850c97",19:"58d5cecb",20:"8bcfd87e",21:"b607bcc6",22:"bbfb5196",23:"ca136498",24:"c1071b43",25:"95ea2f27",26:"5762bf58",27:"e32f1527",28:"cdc1ea65",29:"93771d6e",30:"825aa915",31:"e57c17c1",32:"2cb1de9c",33:"d25a33b3",34:"65ebcddc",35:"ddecc1a0",36:"09debf08",37:"4c887612",38:"1185428b",39:"158e04ca",40:"9f1b9e3d",41:"fc92a0ed",42:"67b089fe",43:"994f638e",44:"23d05733",45:"d04e70ee",46:"27d5a367",47:"c54f29e7"}[n]+".js"}(n);var c=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(l);var t=r[n];if(0!==t){if(t){var i=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;c.message="Loading chunk "+n+" failed.\n("+i+": "+a+")",c.name="ChunkLoadError",c.type=i,c.request=a,t[1](c)}r[n]=void 0}};var l=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=i,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)o.d(t,i,function(e){return n[e]}.bind(null,i));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],c=s.push.bind(s);s.push=e,s=s.slice();for(var l=0;l<s.length;l++)e(s[l]);var u=c;a.push([100,0]),t()}([function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var i=t(25),r=Function.prototype,a=r.bind,o=r.call,s=i&&a.bind(o,o);n.exports=i?function(n){return n&&s(n)}:function(n){return n&&function(){return o.apply(n,arguments)}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var i=t(67),r="object"==typeof self&&self&&self.Object===Object&&self,a=i||r||Function("return this")();n.exports=a},function(n,e,t){"use strict";function i(n,e,t,i,r,a,o,s){var c,l="function"==typeof n?n.options:n;if(e&&(l.render=e,l.staticRenderFns=t,l._compiled=!0),i&&(l.functional=!0),a&&(l._scopeId="data-v-"+a),o?(c=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},l._ssrRegister=c):r&&(c=s?function(){r.call(this,(l.functional?this.parent:this).$root.$options.shadowRoot)}:r),c)if(l.functional){l._injectStyles=c;var u=l.render;l.render=function(n,e){return c.call(e),u(n,e)}}else{var p=l.beforeCreate;l.beforeCreate=p?[].concat(p,c):[c]}return{exports:n,options:l}}t.d(e,"a",(function(){return i}))},function(n,e,t){var i=t(3);n.exports=!i((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var i=t(1),r=t(45),a=i({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(r(n),e)}},function(n,e,t){var i=t(0);n.exports=function(n){return"object"==typeof n?null!==n:i(n)}},function(n,e,t){var i=t(155),r=t(158);n.exports=function(n,e){var t=r(n,e);return i(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return i})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return c})),t.d(e,"h",(function(){return l})),t.d(e,"i",(function(){return u})),t.d(e,"c",(function(){return p})),t.d(e,"f",(function(){return d})),t.d(e,"l",(function(){return f})),t.d(e,"m",(function(){return m})),t.d(e,"d",(function(){return v})),t.d(e,"k",(function(){return g})),t.d(e,"n",(function(){return y})),t.d(e,"a",(function(){return _}));const i=/#.*$/,r=/\.(md|html)$/,a=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(i,"").replace(r,"")}function c(n){return o.test(n)}function l(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function p(n){if(c(n))return n;if(!n)return"404";const e=n.match(i),t=e?e[0]:"",r=s(n);return a.test(r)?n:r+".html"+t}function d(n,e){const t=n.hash,r=function(n){const e=n&&n.match(i);if(e)return e[0]}(e);if(r&&t!==r)return!1;return s(n.path)===s(e)}function f(n,e,t){if(c(e))return{type:"external",path:e};t&&(e=function(n,e,t){const i=n.charAt(0);if("/"===i)return n;if("?"===i||"#"===i)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const i=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===i)return Object.assign({},n[e],{type:"page",path:p(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function m(n,e,t,i){const{pages:r,themeConfig:a}=t,o=i&&a.locales&&a.locales[i]||a;if("auto"===(n.frontmatter.sidebar||o.sidebar||a.sidebar))return h(n);const s=o.sidebar||a.sidebar;if(s){const{base:t,config:i}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const i in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(i)))return{base:i,config:e[i]};var t;return{}}(e,s);return"auto"===i?h(n):i?i.map(n=>function n(e,t,i,r=1){if("string"==typeof e)return f(t,e,i);if(Array.isArray(e))return Object.assign(f(t,e[0],i),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(f(t,e.path,i),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,i,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function h(n){const e=v(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function v(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function g(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function y(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function b(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function _(n,e){return b(e)-b(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var i=t(14),r=t(140),a=t(141),o=i?i.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?r(n):a(n)}},function(n,e,t){var i=t(5).Symbol;n.exports=i},function(n,e,t){var i=t(7),r=t(61),a=t(96),o=t(24),s=t(52),c=TypeError,l=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=i?a?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var i=u(n,e);i&&i.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:i.configurable,enumerable:"enumerable"in t?t.enumerable:i.enumerable,writable:!1})}return l(n,e,t)}:l:function(n,e,t){if(o(n),e=s(e),o(t),r)try{return l(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var i=t(2),r=t(0),a=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(i[n]):i[n]&&i[n][e]}},function(n,e,t){var i=t(7),r=t(15),a=t(29);n.exports=i?function(n,e,t){return r.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var i=t(145),r=t(146),a=t(147),o=t(148),s=t(149);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}c.prototype.clear=i,c.prototype.delete=r,c.prototype.get=a,c.prototype.has=o,c.prototype.set=s,n.exports=c},function(n,e,t){var i=t(69);n.exports=function(n,e){for(var t=n.length;t--;)if(i(n[t][0],e))return t;return-1}},function(n,e,t){var i=t(10)(Object,"create");n.exports=i},function(n,e,t){var i=t(167);n.exports=function(n,e){var t=n.__data__;return i(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var i=t(40);n.exports=function(n){if("string"==typeof n||i(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var i,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(i=function(){var n,e,t={version:"0.2.0"},i=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(i[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,i.minimum,1),t.status=1===n?null:n;var c=t.render(!e),l=c.querySelector(i.barSelector),u=i.speed,p=i.easing;return c.offsetWidth,o((function(e){""===i.positionUsing&&(i.positionUsing=t.getPositioningCSS()),s(l,function(n,e,t){var r;return(r="translate3d"===i.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===i.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,r}(n,u,p)),1===n?(s(c,{transition:"none",opacity:1}),c.offsetWidth,setTimeout((function(){s(c,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),i.trickleSpeed)};return i.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*i.trickleRate)},n=0,e=0,t.promise=function(i){return i&&"resolved"!==i.state()?(0===e&&t.start(),n++,e++,i.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");l(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=i.template;var r,o=e.querySelector(i.barSelector),c=n?"-100":a(t.status||0),u=document.querySelector(i.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+c+"%,0,0)"}),i.showSpinner||(r=e.querySelector(i.spinnerSelector))&&d(r),u!=document.body&&l(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(i.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var i,r=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((i=n[r]+a)in t)return i;return e}(t))}function i(n,e,i){e=t(e),n.style[e]=i}return function(n,e){var t,r,a=arguments;if(2==a.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&i(n,t,r);else i(n,a[1],a[2])}}();function c(n,e){return("string"==typeof n?n:p(n)).indexOf(" "+e+" ")>=0}function l(n,e){var t=p(n),i=t+e;c(t,e)||(n.className=i.substring(1))}function u(n,e){var t,i=p(n);c(n,e)&&(t=i.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?i.call(e,t,e,n):i)||(n.exports=r)},function(n,e,t){var i=t(9),r=String,a=TypeError;n.exports=function(n){if(i(n))return n;throw a(r(n)+" is not an object")}},function(n,e,t){var i=t(3);n.exports=!i((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var i=t(43),r=t(51);n.exports=function(n){return i(r(n))}},function(n,e,t){var i=t(2),r=t(58),a=t(8),o=t(60),s=t(56),c=t(55),l=r("wks"),u=i.Symbol,p=u&&u.for,d=c?u:u&&u.withoutSetter||o;n.exports=function(n){if(!a(l,n)||!s&&"string"!=typeof l[n]){var e="Symbol."+n;s&&a(u,n)?l[n]=u[n]:l[n]=c&&p?p(e):d(e)}return l[n]}},function(n,e,t){var i=t(25),r=Function.prototype.call;n.exports=i?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var i=t(1),r=i({}.toString),a=i("".slice);n.exports=function(n){return a(r(n),8,-1)}},function(n,e,t){var i=t(2),r=t(32),a=i["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=a},function(n,e,t){var i=t(2),r=Object.defineProperty;n.exports=function(n,e){try{r(i,n,{value:e,configurable:!0,writable:!0})}catch(t){i[n]=e}return e}},function(n,e,t){var i=t(139),r=t(12),a=Object.prototype,o=a.hasOwnProperty,s=a.propertyIsEnumerable,c=i(function(){return arguments}())?i:function(n){return r(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=c},function(n,e,t){var i=t(10)(t(5),"Map");n.exports=i},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var i=t(159),r=t(166),a=t(168),o=t(169),s=t(170);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}c.prototype.clear=i,c.prototype.delete=r,c.prototype.get=a,c.prototype.has=o,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var i=t(4),r=t(40),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(i(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(o.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var i=t(13),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==i(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var i=t(2),r=t(50).f,a=t(17),o=t(108),s=t(32),c=t(63),l=t(120);n.exports=function(n,e){var t,u,p,d,f,m=n.target,h=n.global,v=n.stat;if(t=h?i:v?i[m]||s(m,{}):(i[m]||{}).prototype)for(u in e){if(d=e[u],p=n.dontCallGetSet?(f=r(t,u))&&f.value:t[u],!l(h?u:m+(v?".":"#")+u,n.forced)&&void 0!==p){if(typeof d==typeof p)continue;c(d,p)}(n.sham||p&&p.sham)&&a(d,"sham",!0),o(t,u,d,n)}}},function(n,e,t){var i=t(1),r=t(3),a=t(30),o=Object,s=i("".split);n.exports=r((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?s(n,""):o(n)}:o},function(n,e,t){var i=t(0),r=t(106),a=TypeError;n.exports=function(n){if(i(n))return n;throw a(r(n)+" is not a function")}},function(n,e,t){var i=t(51),r=Object;n.exports=function(n){return r(i(n))}},function(n,e){n.exports={}},function(n,e,t){var i=t(118);n.exports=function(n){return i(n.length)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,i=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,a=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,c="object"==typeof self&&self&&self.Object===Object&&self,l=s||c||Function("return this")(),u=Object.prototype.toString,p=Math.max,d=Math.min,f=function(){return l.Date.now()};function m(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function h(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(m(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=m(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=r.test(n);return s||a.test(n)?o(n.slice(2),s?2:8):i.test(n)?NaN:+n}n.exports=function(n,e,t){var i,r,a,o,s,c,l=0,u=!1,v=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function y(e){var t=i,a=r;return i=r=void 0,l=e,o=n.apply(a,t)}function b(n){return l=n,s=setTimeout(x,e),u?y(n):o}function _(n){var t=n-c;return void 0===c||t>=e||t<0||v&&n-l>=a}function x(){var n=f();if(_(n))return w(n);s=setTimeout(x,function(n){var t=e-(n-c);return v?d(t,a-(n-l)):t}(n))}function w(n){return s=void 0,g&&i?y(n):(i=r=void 0,o)}function C(){var n=f(),t=_(n);if(i=arguments,r=this,c=n,t){if(void 0===s)return b(c);if(v)return s=setTimeout(x,e),y(c)}return void 0===s&&(s=setTimeout(x,e)),o}return e=h(e)||0,m(t)&&(u=!!t.leading,a=(v="maxWait"in t)?p(h(t.maxWait)||0,e):a,g="trailing"in t?!!t.trailing:g),C.cancel=function(){void 0!==s&&clearTimeout(s),l=0,i=c=r=s=void 0},C.flush=function(){return void 0===s?o:w(f())},C}},function(n,e,t){var i=t(7),r=t(28),a=t(102),o=t(29),s=t(26),c=t(52),l=t(8),u=t(61),p=Object.getOwnPropertyDescriptor;e.f=i?p:function(n,e){if(n=s(n),e=c(e),u)try{return p(n,e)}catch(n){}if(l(n,e))return o(!r(a.f,n,e),n[e])}},function(n,e){var t=TypeError;n.exports=function(n){if(null==n)throw t("Can't call method on "+n);return n}},function(n,e,t){var i=t(103),r=t(53);n.exports=function(n){var e=i(n,"string");return r(e)?e:e+""}},function(n,e,t){var i=t(16),r=t(0),a=t(54),o=t(55),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=i("Symbol");return r(e)&&a(e.prototype,s(n))}},function(n,e,t){var i=t(1);n.exports=i({}.isPrototypeOf)},function(n,e,t){var i=t(56);n.exports=i&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var i=t(57),r=t(3);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&i&&i<41}))},function(n,e,t){var i,r,a=t(2),o=t(104),s=a.process,c=a.Deno,l=s&&s.versions||c&&c.version,u=l&&l.v8;u&&(r=(i=u.split("."))[0]>0&&i[0]<4?1:+(i[0]+i[1])),!r&&o&&(!(i=o.match(/Edge\/(\d+)/))||i[1]>=74)&&(i=o.match(/Chrome\/(\d+)/))&&(r=+i[1]),n.exports=r},function(n,e,t){var i=t(59),r=t(31);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.23.3",mode:i?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var i=t(1),r=0,a=Math.random(),o=i(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++r+a,36)}},function(n,e,t){var i=t(7),r=t(3),a=t(95);n.exports=!i&&!r((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var i=t(1),r=t(0),a=t(31),o=i(Function.toString);r(a.inspectSource)||(a.inspectSource=function(n){return o(n)}),n.exports=a.inspectSource},function(n,e,t){var i=t(8),r=t(113),a=t(50),o=t(15);n.exports=function(n,e,t){for(var s=r(e),c=o.f,l=a.f,u=0;u<s.length;u++){var p=s[u];i(n,p)||t&&i(t,p)||c(n,p,l(e,p))}}},function(n,e,t){var i=t(117);n.exports=function(n){var e=+n;return e!=e||0===e?0:i(e)}},function(n,e,t){var i=t(1),r=t(24),a=t(127);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=i(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,i){return r(t),a(i),e?n(t,i):t.__proto__=i,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,i=e.length,r=n.length;++t<i;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var i=t(18),r=t(150),a=t(151),o=t(152),s=t(153),c=t(154);function l(n){var e=this.__data__=new i(n);this.size=e.size}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=s,l.prototype.set=c,n.exports=l},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var i=t(13),r=t(35);n.exports=function(n){if(!r(n))return!1;var e=i(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var i=t(171),r=t(12);n.exports=function n(e,t,a,o,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:i(e,t,a,o,n,s))}},function(n,e,t){var i=t(74),r=t(174),a=t(75);n.exports=function(n,e,t,o,s,c){var l=1&t,u=n.length,p=e.length;if(u!=p&&!(l&&p>u))return!1;var d=c.get(n),f=c.get(e);if(d&&f)return d==e&&f==n;var m=-1,h=!0,v=2&t?new i:void 0;for(c.set(n,e),c.set(e,n);++m<u;){var g=n[m],y=e[m];if(o)var b=l?o(y,g,m,e,n,c):o(g,y,m,n,e,c);if(void 0!==b){if(b)continue;h=!1;break}if(v){if(!r(e,(function(n,e){if(!a(v,e)&&(g===n||s(g,n,t,o,c)))return v.push(e)}))){h=!1;break}}else if(g!==y&&!s(g,y,t,o,c)){h=!1;break}}return c.delete(n),c.delete(e),h}},function(n,e,t){var i=t(36),r=t(172),a=t(173);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new i;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=r,o.prototype.has=a,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var i=t(184),r=t(190),a=t(80);n.exports=function(n){return a(n)?i(n):r(n)}},function(n,e,t){(function(n){var i=t(5),r=t(186),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===a?i.Buffer:void 0,c=(s?s.isBuffer:void 0)||r;n.exports=c}).call(this,t(48)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var i=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==i||"symbol"!=i&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var i=t(187),r=t(188),a=t(189),o=a&&a.isTypedArray,s=o?r(o):i;n.exports=s},function(n,e,t){var i=t(70),r=t(38);n.exports=function(n){return null!=n&&r(n.length)&&!i(n)}},function(n,e,t){var i=t(10)(t(5),"Set");n.exports=i},function(n,e,t){var i=t(35);n.exports=function(n){return n==n&&!i(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var i=t(85),r=t(22);n.exports=function(n,e){for(var t=0,a=(e=i(e,n)).length;null!=n&&t<a;)n=n[r(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var i=t(4),r=t(39),a=t(201),o=t(204);n.exports=function(n,e){return i(n)?n:r(n,e)?[n]:a(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var i=t(137),r=t(142),a=t(213),o=t(221),s=t(230),c=t(99),l=a((function(n){var e=c(n);return s(e)&&(e=void 0),o(i(n,1,s,!0),r(e,2))}));n.exports=l},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var i=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=i.exec(t);if(!r)return t;var a="",o=0,s=0;for(o=r.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(a+=t.substring(s,o)),s=o+1,a+=e}return s!==o?a+t.substring(s,o):a}},function(n,e,t){"use strict";t.r(e);var i={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(233),t(6)),a=Object(r.a)(i,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"5a3e6e86",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);var i={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(234),t(6)),a=Object(r.a)(i,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(e,i){return t("li",{key:e.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":i===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(i)}}},[n._v("\n            "+n._s(e.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"392329f0",null);e.default=a.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var i=t(2),r=t(9),a=i.document,o=r(a)&&r(a.createElement);n.exports=function(n){return o?a.createElement(n):{}}},function(n,e,t){var i=t(7),r=t(3);n.exports=i&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var i=t(58),r=t(60),a=i("keys");n.exports=function(n){return a[n]||(a[n]=r(n))}},function(n,e,t){var i=t(1),r=t(8),a=t(26),o=t(115).indexOf,s=t(46),c=i([].push);n.exports=function(n,e){var t,i=a(n),l=0,u=[];for(t in i)!r(s,t)&&r(i,t)&&c(u,t);for(;e.length>l;)r(i,t=e[l++])&&(~o(u,t)||c(u,t));return u}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(239)},function(n,e,t){"use strict";var i=t(42),r=t(121).left,a=t(122),o=t(57),s=t(123);i({target:"Array",proto:!0,forced:!a("reduce")||!s&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var i={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,a=r&&!i.call({1:2},1);e.f=a?function(n){var e=r(this,n);return!!e&&e.enumerable}:i},function(n,e,t){var i=t(28),r=t(9),a=t(53),o=t(105),s=t(107),c=t(27),l=TypeError,u=c("toPrimitive");n.exports=function(n,e){if(!r(n)||a(n))return n;var t,c=o(n,u);if(c){if(void 0===e&&(e="default"),t=i(c,n,e),!r(t)||a(t))return t;throw l("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var i=t(16);n.exports=i("navigator","userAgent")||""},function(n,e,t){var i=t(44);n.exports=function(n,e){var t=n[e];return null==t?void 0:i(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var i=t(28),r=t(0),a=t(9),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&r(t=n.toString)&&!a(s=i(t,n)))return s;if(r(t=n.valueOf)&&!a(s=i(t,n)))return s;if("string"!==e&&r(t=n.toString)&&!a(s=i(t,n)))return s;throw o("Can't convert object to primitive value")}},function(n,e,t){var i=t(0),r=t(15),a=t(109),o=t(32);n.exports=function(n,e,t,s){s||(s={});var c=s.enumerable,l=void 0!==s.name?s.name:e;if(i(t)&&a(t,l,s),s.global)c?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(c=!0):delete n[e]}catch(n){}c?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var i=t(3),r=t(0),a=t(8),o=t(7),s=t(110).CONFIGURABLE,c=t(62),l=t(111),u=l.enforce,p=l.get,d=Object.defineProperty,f=o&&!i((function(){return 8!==d((function(){}),"length",{value:8}).length})),m=String(String).split("String"),h=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!a(n,"name")||s&&n.name!==e)&&(o?d(n,"name",{value:e,configurable:!0}):n.name=e),f&&t&&a(t,"arity")&&n.length!==t.arity&&d(n,"length",{value:t.arity});try{t&&a(t,"constructor")&&t.constructor?o&&d(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var i=u(n);return a(i,"source")||(i.source=m.join("string"==typeof e?e:"")),n};Function.prototype.toString=h((function(){return r(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){var i=t(7),r=t(8),a=Function.prototype,o=i&&Object.getOwnPropertyDescriptor,s=r(a,"name"),c=s&&"something"===function(){}.name,l=s&&(!i||i&&o(a,"name").configurable);n.exports={EXISTS:s,PROPER:c,CONFIGURABLE:l}},function(n,e,t){var i,r,a,o=t(112),s=t(2),c=t(1),l=t(9),u=t(17),p=t(8),d=t(31),f=t(97),m=t(46),h=s.TypeError,v=s.WeakMap;if(o||d.state){var g=d.state||(d.state=new v),y=c(g.get),b=c(g.has),_=c(g.set);i=function(n,e){if(b(g,n))throw new h("Object already initialized");return e.facade=n,_(g,n,e),e},r=function(n){return y(g,n)||{}},a=function(n){return b(g,n)}}else{var x=f("state");m[x]=!0,i=function(n,e){if(p(n,x))throw new h("Object already initialized");return e.facade=n,u(n,x,e),e},r=function(n){return p(n,x)?n[x]:{}},a=function(n){return p(n,x)}}n.exports={set:i,get:r,has:a,enforce:function(n){return a(n)?r(n):i(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=r(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var i=t(2),r=t(0),a=t(62),o=i.WeakMap;n.exports=r(o)&&/native code/.test(a(o))},function(n,e,t){var i=t(16),r=t(1),a=t(114),o=t(119),s=t(24),c=r([].concat);n.exports=i("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=o.f;return t?c(e,t(n)):e}},function(n,e,t){var i=t(98),r=t(94).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return i(n,r)}},function(n,e,t){var i=t(26),r=t(116),a=t(47),o=function(n){return function(e,t,o){var s,c=i(e),l=a(c),u=r(o,l);if(n&&t!=t){for(;l>u;)if((s=c[u++])!=s)return!0}else for(;l>u;u++)if((n||u in c)&&c[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var i=t(64),r=Math.max,a=Math.min;n.exports=function(n,e){var t=i(n);return t<0?r(t+e,0):a(t,e)}},function(n,e){var t=Math.ceil,i=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?i:t)(e)}},function(n,e,t){var i=t(64),r=Math.min;n.exports=function(n){return n>0?r(i(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var i=t(3),r=t(0),a=/#|\.prototype\./,o=function(n,e){var t=c[s(n)];return t==u||t!=l&&(r(e)?i(e):!!e)},s=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},c=o.data={},l=o.NATIVE="N",u=o.POLYFILL="P";n.exports=o},function(n,e,t){var i=t(44),r=t(45),a=t(43),o=t(47),s=TypeError,c=function(n){return function(e,t,c,l){i(t);var u=r(e),p=a(u),d=o(u),f=n?d-1:0,m=n?-1:1;if(c<2)for(;;){if(f in p){l=p[f],f+=m;break}if(f+=m,n?f<0:d<=f)throw s("Reduce of empty array with no initial value")}for(;n?f>=0:d>f;f+=m)f in p&&(l=t(l,p[f],f,u));return l}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var i=t(3);n.exports=function(n,e){var t=[][n];return!!t&&i((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var i=t(30),r=t(2);n.exports="process"==i(r.process)},function(n,e,t){var i=t(42),r=t(2),a=t(125),o=t(126),s=r.WebAssembly,c=7!==Error("e",{cause:7}).cause,l=function(n,e){var t={};t[n]=o(n,e,c),i({global:!0,constructor:!0,arity:1,forced:c},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,c),i({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:c},t)}};l("Error",(function(n){return function(e){return a(n,this,arguments)}})),l("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),l("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),l("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),l("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),l("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),l("URIError",(function(n){return function(e){return a(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var i=t(25),r=Function.prototype,a=r.apply,o=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(i?o.bind(a):function(){return o.apply(a,arguments)})},function(n,e,t){"use strict";var i=t(16),r=t(8),a=t(17),o=t(54),s=t(65),c=t(63),l=t(128),u=t(129),p=t(130),d=t(134),f=t(135),m=t(136),h=t(7),v=t(59);n.exports=function(n,e,t,g){var y=g?2:1,b=n.split("."),_=b[b.length-1],x=i.apply(null,b);if(x){var w=x.prototype;if(!v&&r(w,"cause")&&delete w.cause,!t)return x;var C=i("Error"),k=e((function(n,e){var t=p(g?e:n,void 0),i=g?new x(n):new x;return void 0!==t&&a(i,"message",t),m&&a(i,"stack",f(i.stack,2)),this&&o(w,this)&&u(i,this,k),arguments.length>y&&d(i,arguments[y]),i}));if(k.prototype=w,"Error"!==_?s?s(k,C):c(k,C,{name:!0}):h&&"stackTraceLimit"in x&&(l(k,x,"stackTraceLimit"),l(k,x,"prepareStackTrace")),c(k,x),!v)try{w.name!==_&&a(w,"name",_),w.constructor=k}catch(n){}return k}}},function(n,e,t){var i=t(0),r=String,a=TypeError;n.exports=function(n){if("object"==typeof n||i(n))return n;throw a("Can't set "+r(n)+" as a prototype")}},function(n,e,t){var i=t(15).f;n.exports=function(n,e,t){t in n||i(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var i=t(0),r=t(9),a=t(65);n.exports=function(n,e,t){var o,s;return a&&i(o=e.constructor)&&o!==t&&r(s=o.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e,t){var i=t(131);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:i(n)}},function(n,e,t){var i=t(132),r=String;n.exports=function(n){if("Symbol"===i(n))throw TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){var i=t(133),r=t(0),a=t(30),o=t(27)("toStringTag"),s=Object,c="Arguments"==a(function(){return arguments}());n.exports=i?a:function(n){var e,t,i;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:c?a(e):"Object"==(i=a(e))&&r(e.callee)?"Arguments":i}},function(n,e,t){var i={};i[t(27)("toStringTag")]="z",n.exports="[object z]"===String(i)},function(n,e,t){var i=t(9),r=t(17);n.exports=function(n,e){i(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var i=t(1),r=Error,a=i("".replace),o=String(r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,c=s.test(o);n.exports=function(n,e){if(c&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){var i=t(3),r=t(29);n.exports=!i((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var i=t(66),r=t(138);n.exports=function n(e,t,a,o,s){var c=-1,l=e.length;for(a||(a=r),s||(s=[]);++c<l;){var u=e[c];t>0&&a(u)?t>1?n(u,t-1,a,o,s):i(s,u):o||(s[s.length]=u)}return s}},function(n,e,t){var i=t(14),r=t(33),a=t(4),o=i?i.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||r(n)||!!(o&&n&&n[o])}},function(n,e,t){var i=t(13),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==i(n)}},function(n,e,t){var i=t(14),r=Object.prototype,a=r.hasOwnProperty,o=r.toString,s=i?i.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var i=!0}catch(n){}var r=o.call(n);return i&&(e?n[s]=t:delete n[s]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var i=t(143),r=t(199),a=t(41),o=t(4),s=t(210);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?o(n)?r(n[0],n[1]):i(n):s(n)}},function(n,e,t){var i=t(144),r=t(198),a=t(83);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||i(t,n,e)}}},function(n,e,t){var i=t(68),r=t(72);n.exports=function(n,e,t,a){var o=t.length,s=o,c=!a;if(null==n)return!s;for(n=Object(n);o--;){var l=t[o];if(c&&l[2]?l[1]!==n[l[0]]:!(l[0]in n))return!1}for(;++o<s;){var u=(l=t[o])[0],p=n[u],d=l[1];if(c&&l[2]){if(void 0===p&&!(u in n))return!1}else{var f=new i;if(a)var m=a(p,d,u,n,e,f);if(!(void 0===m?r(d,p,3,a,f):m))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var i=t(19),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=i(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var i=t(19);n.exports=function(n){var e=this.__data__,t=i(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var i=t(19);n.exports=function(n){return i(this.__data__,n)>-1}},function(n,e,t){var i=t(19);n.exports=function(n,e){var t=this.__data__,r=i(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var i=t(18);n.exports=function(){this.__data__=new i,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var i=t(18),r=t(34),a=t(36);n.exports=function(n,e){var t=this.__data__;if(t instanceof i){var o=t.__data__;if(!r||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var i=t(70),r=t(156),a=t(35),o=t(71),s=/^\[object .+?Constructor\]$/,c=Function.prototype,l=Object.prototype,u=c.toString,p=l.hasOwnProperty,d=RegExp("^"+u.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||r(n))&&(i(n)?d:s).test(o(n))}},function(n,e,t){var i,r=t(157),a=(i=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+i:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var i=t(5)["__core-js_shared__"];n.exports=i},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var i=t(160),r=t(18),a=t(34);n.exports=function(){this.size=0,this.__data__={hash:new i,map:new(a||r),string:new i}}},function(n,e,t){var i=t(161),r=t(162),a=t(163),o=t(164),s=t(165);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}c.prototype.clear=i,c.prototype.delete=r,c.prototype.get=a,c.prototype.has=o,c.prototype.set=s,n.exports=c},function(n,e,t){var i=t(20);n.exports=function(){this.__data__=i?i(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var i=t(20),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(i){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var i=t(20),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return i?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var i=t(20);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=i&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var i=t(21);n.exports=function(n){var e=i(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var i=t(21);n.exports=function(n){return i(this,n).get(n)}},function(n,e,t){var i=t(21);n.exports=function(n){return i(this,n).has(n)}},function(n,e,t){var i=t(21);n.exports=function(n,e){var t=i(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var i=t(68),r=t(73),a=t(175),o=t(178),s=t(194),c=t(4),l=t(77),u=t(79),p="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,f,m,h){var v=c(n),g=c(e),y=v?"[object Array]":s(n),b=g?"[object Array]":s(e),_=(y="[object Arguments]"==y?p:y)==p,x=(b="[object Arguments]"==b?p:b)==p,w=y==b;if(w&&l(n)){if(!l(e))return!1;v=!0,_=!1}if(w&&!_)return h||(h=new i),v||u(n)?r(n,e,t,f,m,h):a(n,e,y,t,f,m,h);if(!(1&t)){var C=_&&d.call(n,"__wrapped__"),k=x&&d.call(e,"__wrapped__");if(C||k){var T=C?n.value():n,I=k?e.value():e;return h||(h=new i),m(T,I,t,f,h)}}return!!w&&(h||(h=new i),o(n,e,t,f,m,h))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length;++t<i;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var i=t(14),r=t(176),a=t(69),o=t(73),s=t(177),c=t(37),l=i?i.prototype:void 0,u=l?l.valueOf:void 0;n.exports=function(n,e,t,i,l,p,d){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!p(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var f=s;case"[object Set]":var m=1&i;if(f||(f=c),n.size!=e.size&&!m)return!1;var h=d.get(n);if(h)return h==e;i|=2,d.set(n,e);var v=o(f(n),f(e),i,l,p,d);return d.delete(n),v;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var i=t(5).Uint8Array;n.exports=i},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,i){t[++e]=[i,n]})),t}},function(n,e,t){var i=t(179),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,o,s){var c=1&t,l=i(n),u=l.length;if(u!=i(e).length&&!c)return!1;for(var p=u;p--;){var d=l[p];if(!(c?d in e:r.call(e,d)))return!1}var f=s.get(n),m=s.get(e);if(f&&m)return f==e&&m==n;var h=!0;s.set(n,e),s.set(e,n);for(var v=c;++p<u;){var g=n[d=l[p]],y=e[d];if(a)var b=c?a(y,g,d,e,n,s):a(g,y,d,n,e,s);if(!(void 0===b?g===y||o(g,y,t,a,s):b)){h=!1;break}v||(v="constructor"==d)}if(h&&!v){var _=n.constructor,x=e.constructor;_==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof _&&_ instanceof _&&"function"==typeof x&&x instanceof x||(h=!1)}return s.delete(n),s.delete(e),h}},function(n,e,t){var i=t(180),r=t(181),a=t(76);n.exports=function(n){return i(n,a,r)}},function(n,e,t){var i=t(66),r=t(4);n.exports=function(n,e,t){var a=e(n);return r(n)?a:i(a,t(n))}},function(n,e,t){var i=t(182),r=t(183),a=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),i(o(n),(function(e){return a.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length,r=0,a=[];++t<i;){var o=n[t];e(o,t,n)&&(a[r++]=o)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var i=t(185),r=t(33),a=t(4),o=t(77),s=t(78),c=t(79),l=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),u=!t&&r(n),p=!t&&!u&&o(n),d=!t&&!u&&!p&&c(n),f=t||u||p||d,m=f?i(n.length,String):[],h=m.length;for(var v in n)!e&&!l.call(n,v)||f&&("length"==v||p&&("offset"==v||"parent"==v)||d&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||s(v,h))||m.push(v);return m}},function(n,e){n.exports=function(n,e){for(var t=-1,i=Array(n);++t<n;)i[t]=e(t);return i}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var i=t(13),r=t(38),a=t(12),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&r(n.length)&&!!o[i(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var i=t(67),r=e&&!e.nodeType&&e,a=r&&"object"==typeof n&&n&&!n.nodeType&&n,o=a&&a.exports===r&&i.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(48)(n))},function(n,e,t){var i=t(191),r=t(192),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!i(n))return r(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var i=t(193)(Object.keys,Object);n.exports=i},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var i=t(195),r=t(34),a=t(196),o=t(81),s=t(197),c=t(13),l=t(71),u=l(i),p=l(r),d=l(a),f=l(o),m=l(s),h=c;(i&&"[object DataView]"!=h(new i(new ArrayBuffer(1)))||r&&"[object Map]"!=h(new r)||a&&"[object Promise]"!=h(a.resolve())||o&&"[object Set]"!=h(new o)||s&&"[object WeakMap]"!=h(new s))&&(h=function(n){var e=c(n),t="[object Object]"==e?n.constructor:void 0,i=t?l(t):"";if(i)switch(i){case u:return"[object DataView]";case p:return"[object Map]";case d:return"[object Promise]";case f:return"[object Set]";case m:return"[object WeakMap]"}return e}),n.exports=h},function(n,e,t){var i=t(10)(t(5),"DataView");n.exports=i},function(n,e,t){var i=t(10)(t(5),"Promise");n.exports=i},function(n,e,t){var i=t(10)(t(5),"WeakMap");n.exports=i},function(n,e,t){var i=t(82),r=t(76);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var a=e[t],o=n[a];e[t]=[a,o,i(o)]}return e}},function(n,e,t){var i=t(72),r=t(200),a=t(207),o=t(39),s=t(82),c=t(83),l=t(22);n.exports=function(n,e){return o(n)&&s(e)?c(l(n),e):function(t){var o=r(t,n);return void 0===o&&o===e?a(t,n):i(e,o,3)}}},function(n,e,t){var i=t(84);n.exports=function(n,e,t){var r=null==n?void 0:i(n,e);return void 0===r?t:r}},function(n,e,t){var i=t(202),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,o=i((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,i,r){e.push(i?r.replace(a,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var i=t(203);n.exports=function(n){var e=i(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var i=t(36);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var i=arguments,r=e?e.apply(this,i):i[0],a=t.cache;if(a.has(r))return a.get(r);var o=n.apply(this,i);return t.cache=a.set(r,o)||a,o};return t.cache=new(r.Cache||i),t}r.Cache=i,n.exports=r},function(n,e,t){var i=t(205);n.exports=function(n){return null==n?"":i(n)}},function(n,e,t){var i=t(14),r=t(206),a=t(4),o=t(40),s=i?i.prototype:void 0,c=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return r(e,n)+"";if(o(e))return c?c.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length,r=Array(i);++t<i;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var i=t(208),r=t(209);n.exports=function(n,e){return null!=n&&r(n,e,i)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var i=t(85),r=t(33),a=t(4),o=t(78),s=t(38),c=t(22);n.exports=function(n,e,t){for(var l=-1,u=(e=i(e,n)).length,p=!1;++l<u;){var d=c(e[l]);if(!(p=null!=n&&t(n,d)))break;n=n[d]}return p||++l!=u?p:!!(u=null==n?0:n.length)&&s(u)&&o(d,u)&&(a(n)||r(n))}},function(n,e,t){var i=t(211),r=t(212),a=t(39),o=t(22);n.exports=function(n){return a(n)?i(o(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var i=t(84);n.exports=function(n){return function(e){return i(e,n)}}},function(n,e,t){var i=t(41),r=t(214),a=t(216);n.exports=function(n,e){return a(r(n,e,i),n+"")}},function(n,e,t){var i=t(215),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var a=arguments,o=-1,s=r(a.length-e,0),c=Array(s);++o<s;)c[o]=a[e+o];o=-1;for(var l=Array(e+1);++o<e;)l[o]=a[o];return l[e]=t(c),i(n,this,l)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var i=t(217),r=t(220)(i);n.exports=r},function(n,e,t){var i=t(218),r=t(219),a=t(41),o=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:i(e),writable:!0})}:a;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var i=t(10),r=function(){try{var n=i(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,i=0;return function(){var r=t(),a=16-(r-i);if(i=r,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var i=t(74),r=t(222),a=t(227),o=t(75),s=t(228),c=t(37);n.exports=function(n,e,t){var l=-1,u=r,p=n.length,d=!0,f=[],m=f;if(t)d=!1,u=a;else if(p>=200){var h=e?null:s(n);if(h)return c(h);d=!1,u=o,m=new i}else m=e?[]:f;n:for(;++l<p;){var v=n[l],g=e?e(v):v;if(v=t||0!==v?v:0,d&&g==g){for(var y=m.length;y--;)if(m[y]===g)continue n;e&&m.push(g),f.push(v)}else u(m,g,t)||(m!==f&&m.push(g),f.push(v))}return f}},function(n,e,t){var i=t(223);n.exports=function(n,e){return!!(null==n?0:n.length)&&i(n,e,0)>-1}},function(n,e,t){var i=t(224),r=t(225),a=t(226);n.exports=function(n,e,t){return e==e?a(n,e,t):i(n,r,t)}},function(n,e){n.exports=function(n,e,t,i){for(var r=n.length,a=t+(i?1:-1);i?a--:++a<r;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var i=t-1,r=n.length;++i<r;)if(n[i]===e)return i;return-1}},function(n,e){n.exports=function(n,e,t){for(var i=-1,r=null==n?0:n.length;++i<r;)if(t(e,n[i]))return!0;return!1}},function(n,e,t){var i=t(81),r=t(229),a=t(37),o=i&&1/a(new i([,-0]))[1]==1/0?function(n){return new i(n)}:r;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var i=t(80),r=t(12);n.exports=function(n){return r(n)&&i(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(86)},function(n,e,t){"use strict";t(87)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(88)},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
var i=Object.freeze({});function r(n){return null==n}function a(n){return null!=n}function o(n){return!0===n}function s(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return null!==n&&"object"==typeof n}var l=Object.prototype.toString;function u(n){return"[object Object]"===l.call(n)}function p(n){return"[object RegExp]"===l.call(n)}function d(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return a(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function m(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===l?JSON.stringify(n,null,2):String(n)}function h(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),i=n.split(","),r=0;r<i.length;r++)t[i[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var g=v("key,ref,slot,slot-scope,is");function y(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var b=Object.prototype.hasOwnProperty;function _(n,e){return b.call(n,e)}function x(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var w=/-(\w)/g,C=x((function(n){return n.replace(w,(function(n,e){return e?e.toUpperCase():""}))})),k=x((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),T=/\B([A-Z])/g,I=x((function(n){return n.replace(T,"-$1").toLowerCase()}));var z=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var i=arguments.length;return i?i>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function S(n,e){e=e||0;for(var t=n.length-e,i=new Array(t);t--;)i[t]=n[t+e];return i}function E(n,e){for(var t in e)n[t]=e[t];return n}function j(n){for(var e={},t=0;t<n.length;t++)n[t]&&E(e,n[t]);return e}function P(n,e,t){}var A=function(n,e,t){return!1},O=function(n){return n};function $(n,e){if(n===e)return!0;var t=c(n),i=c(e);if(!t||!i)return!t&&!i&&String(n)===String(e);try{var r=Array.isArray(n),a=Array.isArray(e);if(r&&a)return n.length===e.length&&n.every((function(n,t){return $(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||a)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return $(n[t],e[t])}))}catch(n){return!1}}function L(n,e){for(var t=0;t<n.length;t++)if($(n[t],e))return t;return-1}function R(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var M=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],D={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:A,isReservedAttr:A,isUnknownElement:A,getTagNamespace:P,parsePlatformTagName:O,mustUseProp:A,async:!0,_lifecycleHooks:N},B=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function W(n,e,t,i){Object.defineProperty(n,e,{value:t,enumerable:!!i,writable:!0,configurable:!0})}var U=new RegExp("[^"+B.source+".$_\\d]");var F,q="__proto__"in{},V="undefined"!=typeof window,G="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,J=G&&WXEnvironment.platform.toLowerCase(),H=V&&window.navigator.userAgent.toLowerCase(),Y=H&&/msie|trident/.test(H),Q=H&&H.indexOf("msie 9.0")>0,K=H&&H.indexOf("edge/")>0,Z=(H&&H.indexOf("android"),H&&/iphone|ipad|ipod|ios/.test(H)||"ios"===J),X=(H&&/chrome\/\d+/.test(H),H&&/phantomjs/.test(H),H&&H.match(/firefox\/(\d+)/)),nn={}.watch,en=!1;if(V)try{var tn={};Object.defineProperty(tn,"passive",{get:function(){en=!0}}),window.addEventListener("test-passive",null,tn)}catch(n){}var rn=function(){return void 0===F&&(F=!V&&!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),F},an=V&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function on(n){return"function"==typeof n&&/native code/.test(n.toString())}var sn,cn="undefined"!=typeof Symbol&&on(Symbol)&&"undefined"!=typeof Reflect&&on(Reflect.ownKeys);sn="undefined"!=typeof Set&&on(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var ln=P,un=0,pn=function(){this.id=un++,this.subs=[]};pn.prototype.addSub=function(n){this.subs.push(n)},pn.prototype.removeSub=function(n){y(this.subs,n)},pn.prototype.depend=function(){pn.target&&pn.target.addDep(this)},pn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},pn.target=null;var dn=[];function fn(n){dn.push(n),pn.target=n}function mn(){dn.pop(),pn.target=dn[dn.length-1]}var hn=function(n,e,t,i,r,a,o,s){this.tag=n,this.data=e,this.children=t,this.text=i,this.elm=r,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},vn={child:{configurable:!0}};vn.child.get=function(){return this.componentInstance},Object.defineProperties(hn.prototype,vn);var gn=function(n){void 0===n&&(n="");var e=new hn;return e.text=n,e.isComment=!0,e};function yn(n){return new hn(void 0,void 0,void 0,String(n))}function bn(n){var e=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var _n=Array.prototype,xn=Object.create(_n);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=_n[n];W(xn,n,(function(){for(var t=[],i=arguments.length;i--;)t[i]=arguments[i];var r,a=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&o.observeArray(r),o.dep.notify(),a}))}));var wn=Object.getOwnPropertyNames(xn),Cn=!0;function kn(n){Cn=n}var Tn=function(n){this.value=n,this.dep=new pn,this.vmCount=0,W(n,"__ob__",this),Array.isArray(n)?(q?function(n,e){n.__proto__=e}(n,xn):function(n,e,t){for(var i=0,r=t.length;i<r;i++){var a=t[i];W(n,a,e[a])}}(n,xn,wn),this.observeArray(n)):this.walk(n)};function In(n,e){var t;if(c(n)&&!(n instanceof hn))return _(n,"__ob__")&&n.__ob__ instanceof Tn?t=n.__ob__:Cn&&!rn()&&(Array.isArray(n)||u(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new Tn(n)),e&&t&&t.vmCount++,t}function zn(n,e,t,i,r){var a=new pn,o=Object.getOwnPropertyDescriptor(n,e);if(!o||!1!==o.configurable){var s=o&&o.get,c=o&&o.set;s&&!c||2!==arguments.length||(t=n[e]);var l=!r&&In(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(n):t;return pn.target&&(a.depend(),l&&(l.dep.depend(),Array.isArray(e)&&jn(e))),e},set:function(e){var i=s?s.call(n):t;e===i||e!=e&&i!=i||s&&!c||(c?c.call(n,e):t=e,l=!r&&In(e),a.notify())}})}}function Sn(n,e,t){if(Array.isArray(n)&&d(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var i=n.__ob__;return n._isVue||i&&i.vmCount?t:i?(zn(i.value,e,t),i.dep.notify(),t):(n[e]=t,t)}function En(n,e){if(Array.isArray(n)&&d(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||_(n,e)&&(delete n[e],t&&t.dep.notify())}}function jn(n){for(var e=void 0,t=0,i=n.length;t<i;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&jn(e)}Tn.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)zn(n,e[t])},Tn.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)In(n[e])};var Pn=D.optionMergeStrategies;function An(n,e){if(!e)return n;for(var t,i,r,a=cn?Reflect.ownKeys(e):Object.keys(e),o=0;o<a.length;o++)"__ob__"!==(t=a[o])&&(i=n[t],r=e[t],_(n,t)?i!==r&&u(i)&&u(r)&&An(i,r):Sn(n,t,r));return n}function On(n,e,t){return t?function(){var i="function"==typeof e?e.call(t,t):e,r="function"==typeof n?n.call(t,t):n;return i?An(i,r):r}:e?n?function(){return An("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function $n(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Ln(n,e,t,i){var r=Object.create(n||null);return e?E(r,e):r}Pn.data=function(n,e,t){return t?On(n,e,t):e&&"function"!=typeof e?n:On(n,e)},N.forEach((function(n){Pn[n]=$n})),M.forEach((function(n){Pn[n+"s"]=Ln})),Pn.watch=function(n,e,t,i){if(n===nn&&(n=void 0),e===nn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var r={};for(var a in E(r,n),e){var o=r[a],s=e[a];o&&!Array.isArray(o)&&(o=[o]),r[a]=o?o.concat(s):Array.isArray(s)?s:[s]}return r},Pn.props=Pn.methods=Pn.inject=Pn.computed=function(n,e,t,i){if(!n)return e;var r=Object.create(null);return E(r,n),e&&E(r,e),r},Pn.provide=On;var Rn=function(n,e){return void 0===e?n:e};function Mn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var i,r,a={};if(Array.isArray(t))for(i=t.length;i--;)"string"==typeof(r=t[i])&&(a[C(r)]={type:null});else if(u(t))for(var o in t)r=t[o],a[C(o)]=u(r)?r:{type:r};else 0;n.props=a}}(e),function(n,e){var t=n.inject;if(t){var i=n.inject={};if(Array.isArray(t))for(var r=0;r<t.length;r++)i[t[r]]={from:t[r]};else if(u(t))for(var a in t){var o=t[a];i[a]=u(o)?E({from:a},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var i=e[t];"function"==typeof i&&(e[t]={bind:i,update:i})}}(e),!e._base&&(e.extends&&(n=Mn(n,e.extends,t)),e.mixins))for(var i=0,r=e.mixins.length;i<r;i++)n=Mn(n,e.mixins[i],t);var a,o={};for(a in n)s(a);for(a in e)_(n,a)||s(a);function s(i){var r=Pn[i]||Rn;o[i]=r(n[i],e[i],t,i)}return o}function Nn(n,e,t,i){if("string"==typeof t){var r=n[e];if(_(r,t))return r[t];var a=C(t);if(_(r,a))return r[a];var o=k(a);return _(r,o)?r[o]:r[t]||r[a]||r[o]}}function Dn(n,e,t,i){var r=e[n],a=!_(t,n),o=t[n],s=Fn(Boolean,r.type);if(s>-1)if(a&&!_(r,"default"))o=!1;else if(""===o||o===I(n)){var c=Fn(String,r.type);(c<0||s<c)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!_(e,"default"))return;var i=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof i&&"Function"!==Wn(e.type)?i.call(n):i}(i,r,n);var l=Cn;kn(!0),In(o),kn(l)}return o}var Bn=/^\s*function (\w+)/;function Wn(n){var e=n&&n.toString().match(Bn);return e?e[1]:""}function Un(n,e){return Wn(n)===Wn(e)}function Fn(n,e){if(!Array.isArray(e))return Un(e,n)?0:-1;for(var t=0,i=e.length;t<i;t++)if(Un(e[t],n))return t;return-1}function qn(n,e,t){fn();try{if(e)for(var i=e;i=i.$parent;){var r=i.$options.errorCaptured;if(r)for(var a=0;a<r.length;a++)try{if(!1===r[a].call(i,n,e,t))return}catch(n){Gn(n,i,"errorCaptured hook")}}Gn(n,e,t)}finally{mn()}}function Vn(n,e,t,i,r){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&f(a)&&!a._handled&&(a.catch((function(n){return qn(n,i,r+" (Promise/async)")})),a._handled=!0)}catch(n){qn(n,i,r)}return a}function Gn(n,e,t){if(D.errorHandler)try{return D.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Jn(e,null,"config.errorHandler")}Jn(n,e,t)}function Jn(n,e,t){if(!V&&!G||"undefined"==typeof console)throw n;console.error(n)}var Hn,Yn=!1,Qn=[],Kn=!1;function Zn(){Kn=!1;var n=Qn.slice(0);Qn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&on(Promise)){var Xn=Promise.resolve();Hn=function(){Xn.then(Zn),Z&&setTimeout(P)},Yn=!0}else if(Y||"undefined"==typeof MutationObserver||!on(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Hn="undefined"!=typeof setImmediate&&on(setImmediate)?function(){setImmediate(Zn)}:function(){setTimeout(Zn,0)};else{var ne=1,ee=new MutationObserver(Zn),te=document.createTextNode(String(ne));ee.observe(te,{characterData:!0}),Hn=function(){ne=(ne+1)%2,te.data=String(ne)},Yn=!0}function ie(n,e){var t;if(Qn.push((function(){if(n)try{n.call(e)}catch(n){qn(n,e,"nextTick")}else t&&t(e)})),Kn||(Kn=!0,Hn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var re=new sn;function ae(n){!function n(e,t){var i,r,a=Array.isArray(e);if(!a&&!c(e)||Object.isFrozen(e)||e instanceof hn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(a)for(i=e.length;i--;)n(e[i],t);else for(r=Object.keys(e),i=r.length;i--;)n(e[r[i]],t)}(n,re),re.clear()}var oe=x((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),i="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=i?n.slice(1):n,once:t,capture:i,passive:e}}));function se(n,e){function t(){var n=arguments,i=t.fns;if(!Array.isArray(i))return Vn(i,null,arguments,e,"v-on handler");for(var r=i.slice(),a=0;a<r.length;a++)Vn(r[a],null,n,e,"v-on handler")}return t.fns=n,t}function ce(n,e,t,i,a,s){var c,l,u,p;for(c in n)l=n[c],u=e[c],p=oe(c),r(l)||(r(u)?(r(l.fns)&&(l=n[c]=se(l,s)),o(p.once)&&(l=n[c]=a(p.name,l,p.capture)),t(p.name,l,p.capture,p.passive,p.params)):l!==u&&(u.fns=l,n[c]=u));for(c in e)r(n[c])&&i((p=oe(c)).name,e[c],p.capture)}function le(n,e,t){var i;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var s=n[e];function c(){t.apply(this,arguments),y(i.fns,c)}r(s)?i=se([c]):a(s.fns)&&o(s.merged)?(i=s).fns.push(c):i=se([s,c]),i.merged=!0,n[e]=i}function ue(n,e,t,i,r){if(a(e)){if(_(e,t))return n[t]=e[t],r||delete e[t],!0;if(_(e,i))return n[t]=e[i],r||delete e[i],!0}return!1}function pe(n){return s(n)?[yn(n)]:Array.isArray(n)?function n(e,t){var i,c,l,u,p=[];for(i=0;i<e.length;i++)r(c=e[i])||"boolean"==typeof c||(l=p.length-1,u=p[l],Array.isArray(c)?c.length>0&&(de((c=n(c,(t||"")+"_"+i))[0])&&de(u)&&(p[l]=yn(u.text+c[0].text),c.shift()),p.push.apply(p,c)):s(c)?de(u)?p[l]=yn(u.text+c):""!==c&&p.push(yn(c)):de(c)&&de(u)?p[l]=yn(u.text+c.text):(o(e._isVList)&&a(c.tag)&&r(c.key)&&a(t)&&(c.key="__vlist"+t+"_"+i+"__"),p.push(c)));return p}(n):void 0}function de(n){return a(n)&&a(n.text)&&!1===n.isComment}function fe(n,e){if(n){for(var t=Object.create(null),i=cn?Reflect.ownKeys(n):Object.keys(n),r=0;r<i.length;r++){var a=i[r];if("__ob__"!==a){for(var o=n[a].from,s=e;s;){if(s._provided&&_(s._provided,o)){t[a]=s._provided[o];break}s=s.$parent}if(!s)if("default"in n[a]){var c=n[a].default;t[a]="function"==typeof c?c.call(e):c}else 0}}return t}}function me(n,e){if(!n||!n.length)return{};for(var t={},i=0,r=n.length;i<r;i++){var a=n[i],o=a.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,a.context!==e&&a.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(a);else{var s=o.slot,c=t[s]||(t[s]=[]);"template"===a.tag?c.push.apply(c,a.children||[]):c.push(a)}}for(var l in t)t[l].every(he)&&delete t[l];return t}function he(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ve(n){return n.isComment&&n.asyncFactory}function ge(n,e,t){var r,a=Object.keys(e).length>0,o=n?!!n.$stable:!a,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&t&&t!==i&&s===t.$key&&!a&&!t.$hasNormal)return t;for(var c in r={},n)n[c]&&"$"!==c[0]&&(r[c]=ye(e,c,n[c]))}else r={};for(var l in e)l in r||(r[l]=be(e,l));return n&&Object.isExtensible(n)&&(n._normalized=r),W(r,"$stable",o),W(r,"$key",s),W(r,"$hasNormal",a),r}function ye(n,e,t){var i=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:pe(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!ve(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:i,enumerable:!0,configurable:!0}),i}function be(n,e){return function(){return n[e]}}function _e(n,e){var t,i,r,o,s;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),i=0,r=n.length;i<r;i++)t[i]=e(n[i],i);else if("number"==typeof n)for(t=new Array(n),i=0;i<n;i++)t[i]=e(i+1,i);else if(c(n))if(cn&&n[Symbol.iterator]){t=[];for(var l=n[Symbol.iterator](),u=l.next();!u.done;)t.push(e(u.value,t.length)),u=l.next()}else for(o=Object.keys(n),t=new Array(o.length),i=0,r=o.length;i<r;i++)s=o[i],t[i]=e(n[s],s,i);return a(t)||(t=[]),t._isVList=!0,t}function xe(n,e,t,i){var r,a=this.$scopedSlots[n];a?(t=t||{},i&&(t=E(E({},i),t)),r=a(t)||("function"==typeof e?e():e)):r=this.$slots[n]||("function"==typeof e?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},r):r}function we(n){return Nn(this.$options,"filters",n)||O}function Ce(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function ke(n,e,t,i,r){var a=D.keyCodes[e]||t;return r&&i&&!D.keyCodes[e]?Ce(r,i):a?Ce(a,n):i?I(i)!==e:void 0===n}function Te(n,e,t,i,r){if(t)if(c(t)){var a;Array.isArray(t)&&(t=j(t));var o=function(o){if("class"===o||"style"===o||g(o))a=n;else{var s=n.attrs&&n.attrs.type;a=i||D.mustUseProp(e,s,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var c=C(o),l=I(o);c in a||l in a||(a[o]=t[o],r&&((n.on||(n.on={}))["update:"+o]=function(n){t[o]=n}))};for(var s in t)o(s)}else;return n}function Ie(n,e){var t=this._staticTrees||(this._staticTrees=[]),i=t[n];return i&&!e||Se(i=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),i}function ze(n,e,t){return Se(n,"__once__"+e+(t?"_"+t:""),!0),n}function Se(n,e,t){if(Array.isArray(n))for(var i=0;i<n.length;i++)n[i]&&"string"!=typeof n[i]&&Ee(n[i],e+"_"+i,t);else Ee(n,e,t)}function Ee(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function je(n,e){if(e)if(u(e)){var t=n.on=n.on?E({},n.on):{};for(var i in e){var r=t[i],a=e[i];t[i]=r?[].concat(r,a):a}}else;return n}function Pe(n,e,t,i){e=e||{$stable:!t};for(var r=0;r<n.length;r++){var a=n[r];Array.isArray(a)?Pe(a,e,t):a&&(a.proxy&&(a.fn.proxy=!0),e[a.key]=a.fn)}return i&&(e.$key=i),e}function Ae(n,e){for(var t=0;t<e.length;t+=2){var i=e[t];"string"==typeof i&&i&&(n[e[t]]=e[t+1])}return n}function Oe(n,e){return"string"==typeof n?e+n:n}function $e(n){n._o=ze,n._n=h,n._s=m,n._l=_e,n._t=xe,n._q=$,n._i=L,n._m=Ie,n._f=we,n._k=ke,n._b=Te,n._v=yn,n._e=gn,n._u=Pe,n._g=je,n._d=Ae,n._p=Oe}function Le(n,e,t,r,a){var s,c=this,l=a.options;_(r,"_uid")?(s=Object.create(r))._original=r:(s=r,r=r._original);var u=o(l._compiled),p=!u;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||i,this.injections=fe(l.inject,r),this.slots=function(){return c.$slots||ge(n.scopedSlots,c.$slots=me(t,r)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(n.scopedSlots,this.slots())}}),u&&(this.$options=l,this.$slots=this.slots(),this.$scopedSlots=ge(n.scopedSlots,this.$slots)),l._scopeId?this._c=function(n,e,t,i){var a=Ue(s,n,e,t,i,p);return a&&!Array.isArray(a)&&(a.fnScopeId=l._scopeId,a.fnContext=r),a}:this._c=function(n,e,t,i){return Ue(s,n,e,t,i,p)}}function Re(n,e,t,i,r){var a=bn(n);return a.fnContext=t,a.fnOptions=i,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function Me(n,e){for(var t in e)n[C(t)]=e[t]}$e(Le.prototype);var Ne={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Ne.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},i=n.data.inlineTemplate;a(i)&&(t.render=i.render,t.staticRenderFns=i.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,a){0;var o=r.data.scopedSlots,s=n.$scopedSlots,c=!!(o&&!o.$stable||s!==i&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),l=!!(a||n.$options._renderChildren||c);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=a,n.$attrs=r.data.attrs||i,n.$listeners=t||i,e&&n.$options.props){kn(!1);for(var u=n._props,p=n.$options._propKeys||[],d=0;d<p.length;d++){var f=p[d],m=n.$options.props;u[f]=Dn(f,m,e,n)}kn(!0),n.$options.propsData=e}t=t||i;var h=n.$options._parentListeners;n.$options._parentListeners=t,Qe(n,t,h),l&&(n.$slots=me(a,r.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,i=n.componentInstance;i._isMounted||(i._isMounted=!0,et(i,"mounted")),n.data.keepAlive&&(t._isMounted?((e=i)._inactive=!1,it.push(e)):nt(i,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,Xe(e)))return;if(!e._inactive){e._inactive=!0;for(var i=0;i<e.$children.length;i++)n(e.$children[i]);et(e,"deactivated")}}(e,!0):e.$destroy())}},De=Object.keys(Ne);function Be(n,e,t,s,l){if(!r(n)){var u=t.$options._base;if(c(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(r(n.cid)&&void 0===(n=function(n,e){if(o(n.error)&&a(n.errorComp))return n.errorComp;if(a(n.resolved))return n.resolved;var t=qe;t&&a(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(o(n.loading)&&a(n.loadingComp))return n.loadingComp;if(t&&!a(n.owners)){var i=n.owners=[t],s=!0,l=null,u=null;t.$on("hook:destroyed",(function(){return y(i,t)}));var p=function(n){for(var e=0,t=i.length;e<t;e++)i[e].$forceUpdate();n&&(i.length=0,null!==l&&(clearTimeout(l),l=null),null!==u&&(clearTimeout(u),u=null))},d=R((function(t){n.resolved=Ve(t,e),s?i.length=0:p(!0)})),m=R((function(e){a(n.errorComp)&&(n.error=!0,p(!0))})),h=n(d,m);return c(h)&&(f(h)?r(n.resolved)&&h.then(d,m):f(h.component)&&(h.component.then(d,m),a(h.error)&&(n.errorComp=Ve(h.error,e)),a(h.loading)&&(n.loadingComp=Ve(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,r(n.resolved)&&r(n.error)&&(n.loading=!0,p(!1))}),h.delay||200)),a(h.timeout)&&(u=setTimeout((function(){u=null,r(n.resolved)&&m(null)}),h.timeout)))),s=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,e,t,i,r){var a=gn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:i,tag:r},a}(p,e,t,s,l);e=e||{},Ct(n),a(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",i=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var r=e.on||(e.on={}),o=r[i],s=e.model.callback;a(o)?(Array.isArray(o)?-1===o.indexOf(s):o!==s)&&(r[i]=[s].concat(o)):r[i]=s}(n.options,e);var d=function(n,e,t){var i=e.options.props;if(!r(i)){var o={},s=n.attrs,c=n.props;if(a(s)||a(c))for(var l in i){var u=I(l);ue(o,c,l,u,!0)||ue(o,s,l,u,!1)}return o}}(e,n);if(o(n.options.functional))return function(n,e,t,r,o){var s=n.options,c={},l=s.props;if(a(l))for(var u in l)c[u]=Dn(u,l,e||i);else a(t.attrs)&&Me(c,t.attrs),a(t.props)&&Me(c,t.props);var p=new Le(t,c,o,r,n),d=s.render.call(null,p._c,p);if(d instanceof hn)return Re(d,t,p.parent,s,p);if(Array.isArray(d)){for(var f=pe(d)||[],m=new Array(f.length),h=0;h<f.length;h++)m[h]=Re(f[h],t,p.parent,s,p);return m}}(n,d,e,t,s);var m=e.on;if(e.on=e.nativeOn,o(n.options.abstract)){var h=e.slot;e={},h&&(e.slot=h)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<De.length;t++){var i=De[t],r=e[i],a=Ne[i];r===a||r&&r._merged||(e[i]=r?We(a,r):a)}}(e);var v=n.options.name||l;return new hn("vue-component-"+n.cid+(v?"-"+v:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:d,listeners:m,tag:l,children:s},p)}}}function We(n,e){var t=function(t,i){n(t,i),e(t,i)};return t._merged=!0,t}function Ue(n,e,t,i,l,u){return(Array.isArray(t)||s(t))&&(l=i,i=t,t=void 0),o(u)&&(l=2),function(n,e,t,i,s){if(a(t)&&a(t.__ob__))return gn();a(t)&&a(t.is)&&(e=t.is);if(!e)return gn();0;Array.isArray(i)&&"function"==typeof i[0]&&((t=t||{}).scopedSlots={default:i[0]},i.length=0);2===s?i=pe(i):1===s&&(i=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(i));var l,u;if("string"==typeof e){var p;u=n.$vnode&&n.$vnode.ns||D.getTagNamespace(e),l=D.isReservedTag(e)?new hn(D.parsePlatformTagName(e),t,i,void 0,void 0,n):t&&t.pre||!a(p=Nn(n.$options,"components",e))?new hn(e,t,i,void 0,void 0,n):Be(p,t,n,i,e)}else l=Be(e,t,n,i);return Array.isArray(l)?l:a(l)?(a(u)&&function n(e,t,i){e.ns=t,"foreignObject"===e.tag&&(t=void 0,i=!0);if(a(e.children))for(var s=0,c=e.children.length;s<c;s++){var l=e.children[s];a(l.tag)&&(r(l.ns)||o(i)&&"svg"!==l.tag)&&n(l,t,i)}}(l,u),a(t)&&function(n){c(n.style)&&ae(n.style);c(n.class)&&ae(n.class)}(t),l):gn()}(n,e,t,i,l)}var Fe,qe=null;function Ve(n,e){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function Ge(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(a(t)&&(a(t.componentOptions)||ve(t)))return t}}function Je(n,e){Fe.$on(n,e)}function He(n,e){Fe.$off(n,e)}function Ye(n,e){var t=Fe;return function i(){var r=e.apply(null,arguments);null!==r&&t.$off(n,i)}}function Qe(n,e,t){Fe=n,ce(e,t||{},Je,He,Ye,n),Fe=void 0}var Ke=null;function Ze(n){var e=Ke;return Ke=n,function(){Ke=e}}function Xe(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Xe(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e){fn();var t=n.$options[e],i=e+" hook";if(t)for(var r=0,a=t.length;r<a;r++)Vn(t[r],n,null,n,i);n._hasHookEvent&&n.$emit("hook:"+e),mn()}var tt=[],it=[],rt={},at=!1,ot=!1,st=0;var ct=0,lt=Date.now;if(V&&!Y){var ut=window.performance;ut&&"function"==typeof ut.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ut.now()})}function pt(){var n,e;for(ct=lt(),ot=!0,tt.sort((function(n,e){return n.id-e.id})),st=0;st<tt.length;st++)(n=tt[st]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=it.slice(),i=tt.slice();st=tt.length=it.length=0,rt={},at=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],i=t.vm;i._watcher===t&&i._isMounted&&!i._isDestroyed&&et(i,"updated")}}(i),an&&D.devtools&&an.emit("flush")}var dt=0,ft=function(n,e,t,i,r){this.vm=n,r&&(n._watcher=this),n._watchers.push(this),i?(this.deep=!!i.deep,this.user=!!i.user,this.lazy=!!i.lazy,this.sync=!!i.sync,this.before=i.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++dt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new sn,this.newDepIds=new sn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!U.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=P)),this.value=this.lazy?void 0:this.get()};ft.prototype.get=function(){var n;fn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;qn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&ae(n),mn(),this.cleanupDeps()}return n},ft.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},ft.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},ft.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==rt[e]){if(rt[e]=!0,ot){for(var t=tt.length-1;t>st&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);at||(at=!0,ie(pt))}}(this)},ft.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Vn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},ft.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},ft.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},ft.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||y(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var mt={enumerable:!0,configurable:!0,get:P,set:P};function ht(n,e,t){mt.get=function(){return this[e][t]},mt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,mt)}function vt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},i=n._props={},r=n.$options._propKeys=[];n.$parent&&kn(!1);var a=function(a){r.push(a);var o=Dn(a,e,t,n);zn(i,a,o),a in n||ht(n,"_props",a)};for(var o in e)a(o);kn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?P:z(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;u(e=n._data="function"==typeof e?function(n,e){fn();try{return n.call(e,e)}catch(n){return qn(n,e,"data()"),{}}finally{mn()}}(e,n):e||{})||(e={});var t=Object.keys(e),i=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var a=t[r];0,i&&_(i,a)||(o=void 0,36!==(o=(a+"").charCodeAt(0))&&95!==o&&ht(n,"_data",a))}var o;In(e,!0)}(n):In(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),i=rn();for(var r in e){var a=e[r],o="function"==typeof a?a:a.get;0,i||(t[r]=new ft(n,o||P,P,gt)),r in n||yt(n,r,a)}}(n,e.computed),e.watch&&e.watch!==nn&&function(n,e){for(var t in e){var i=e[t];if(Array.isArray(i))for(var r=0;r<i.length;r++)xt(n,t,i[r]);else xt(n,t,i)}}(n,e.watch)}var gt={lazy:!0};function yt(n,e,t){var i=!rn();"function"==typeof t?(mt.get=i?bt(e):_t(t),mt.set=P):(mt.get=t.get?i&&!1!==t.cache?bt(e):_t(t.get):P,mt.set=t.set||P),Object.defineProperty(n,e,mt)}function bt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),pn.target&&e.depend(),e.value}}function _t(n){return function(){return n.call(this,this)}}function xt(n,e,t,i){return u(t)&&(i=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,i)}var wt=0;function Ct(n){var e=n.options;if(n.super){var t=Ct(n.super);if(t!==n.superOptions){n.superOptions=t;var i=function(n){var e,t=n.options,i=n.sealedOptions;for(var r in t)t[r]!==i[r]&&(e||(e={}),e[r]=t[r]);return e}(n);i&&E(n.extendOptions,i),(e=n.options=Mn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function kt(n){this._init(n)}function Tt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,i=t.cid,r=n._Ctor||(n._Ctor={});if(r[i])return r[i];var a=n.name||t.options.name;var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Mn(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)ht(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)yt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,M.forEach((function(n){o[n]=t[n]})),a&&(o.options.components[a]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=E({},o.options),r[i]=o,o}}function It(n){return n&&(n.Ctor.options.name||n.tag)}function zt(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function St(n,e){var t=n.cache,i=n.keys,r=n._vnode;for(var a in t){var o=t[a];if(o){var s=o.name;s&&!e(s)&&Et(t,a,i,r)}}}function Et(n,e,t,i){var r=n[e];!r||i&&r.tag===i.tag||r.componentInstance.$destroy(),n[e]=null,y(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=wt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),i=e._parentVnode;t.parent=e.parent,t._parentVnode=i;var r=i.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Mn(Ct(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Qe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=me(e._renderChildren,r),n.$scopedSlots=i,n._c=function(e,t,i,r){return Ue(n,e,t,i,r,!1)},n.$createElement=function(e,t,i,r){return Ue(n,e,t,i,r,!0)};var a=t&&t.data;zn(n,"$attrs",a&&a.attrs||i,null,!0),zn(n,"$listeners",e._parentListeners||i,null,!0)}(e),et(e,"beforeCreate"),function(n){var e=fe(n.$options.inject,n);e&&(kn(!1),Object.keys(e).forEach((function(t){zn(n,t,e[t])})),kn(!0))}(e),vt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(kt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Sn,n.prototype.$delete=En,n.prototype.$watch=function(n,e,t){if(u(e))return xt(this,n,e,t);(t=t||{}).user=!0;var i=new ft(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'+i.expression+'"';fn(),Vn(e,this,[i.value],this,r),mn()}return function(){i.teardown()}}}(kt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var i=this;if(Array.isArray(n))for(var r=0,a=n.length;r<a;r++)i.$on(n[r],t);else(i._events[n]||(i._events[n]=[])).push(t),e.test(n)&&(i._hasHookEvent=!0);return i},n.prototype.$once=function(n,e){var t=this;function i(){t.$off(n,i),e.apply(t,arguments)}return i.fn=e,t.$on(n,i),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var i=0,r=n.length;i<r;i++)t.$off(n[i],e);return t}var a,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var s=o.length;s--;)if((a=o[s])===e||a.fn===e){o.splice(s,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?S(t):t;for(var i=S(arguments,1),r='event handler for "'+n+'"',a=0,o=t.length;a<o;a++)Vn(t[a],e,i,e,r)}return e}}(kt),function(n){n.prototype._update=function(n,e){var t=this,i=t.$el,r=t._vnode,a=Ze(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),a(),i&&(i.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(kt),function(n){$e(n.prototype),n.prototype.$nextTick=function(n){return ie(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,i=t.render,r=t._parentVnode;r&&(e.$scopedSlots=ge(r.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=r;try{qe=e,n=i.call(e._renderProxy,e.$createElement)}catch(t){qn(t,e,"render"),n=e._vnode}finally{qe=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof hn||(n=gn()),n.parent=r,n}}(kt);var jt=[String,RegExp,Array],Pt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:jt,exclude:jt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,i=this.keyToCache;if(t){var r=t.tag,a=t.componentInstance,o=t.componentOptions;n[i]={name:It(o),tag:r,componentInstance:a},e.push(i),this.max&&e.length>parseInt(this.max)&&Et(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Et(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){St(n,(function(n){return zt(e,n)}))})),this.$watch("exclude",(function(e){St(n,(function(n){return!zt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ge(n),t=e&&e.componentOptions;if(t){var i=It(t),r=this.include,a=this.exclude;if(r&&(!i||!zt(r,i))||a&&i&&zt(a,i))return e;var o=this.cache,s=this.keys,c=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;o[c]?(e.componentInstance=o[c].componentInstance,y(s,c),s.push(c)):(this.vnodeToCache=e,this.keyToCache=c),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return D}};Object.defineProperty(n,"config",e),n.util={warn:ln,extend:E,mergeOptions:Mn,defineReactive:zn},n.set=Sn,n.delete=En,n.nextTick=ie,n.observable=function(n){return In(n),n},n.options=Object.create(null),M.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,E(n.options.components,Pt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=S(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Mn(this.options,n),this}}(n),Tt(n),function(n){M.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(kt),Object.defineProperty(kt.prototype,"$isServer",{get:rn}),Object.defineProperty(kt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(kt,"FunctionalRenderContext",{value:Le}),kt.version="2.6.14";var At=v("style,class"),Ot=v("input,textarea,option,select,progress"),$t=v("contenteditable,draggable,spellcheck"),Lt=v("events,caret,typing,plaintext-only"),Rt=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Mt="http://www.w3.org/1999/xlink",Nt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Dt=function(n){return Nt(n)?n.slice(6,n.length):""},Bt=function(n){return null==n||!1===n};function Wt(n){for(var e=n.data,t=n,i=n;a(i.componentInstance);)(i=i.componentInstance._vnode)&&i.data&&(e=Ut(i.data,e));for(;a(t=t.parent);)t&&t.data&&(e=Ut(e,t.data));return function(n,e){if(a(n)||a(e))return Ft(n,qt(e));return""}(e.staticClass,e.class)}function Ut(n,e){return{staticClass:Ft(n.staticClass,e.staticClass),class:a(n.class)?[n.class,e.class]:e.class}}function Ft(n,e){return n?e?n+" "+e:n:e||""}function qt(n){return Array.isArray(n)?function(n){for(var e,t="",i=0,r=n.length;i<r;i++)a(e=qt(n[i]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Vt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Gt=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Jt=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Ht=function(n){return Gt(n)||Jt(n)};var Yt=Object.create(null);var Qt=v("text,number,password,search,email,tel,url");var Kt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Vt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Zt={create:function(n,e){Xt(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Xt(n,!0),Xt(e))},destroy:function(n){Xt(n,!0)}};function Xt(n,e){var t=n.data.ref;if(a(t)){var i=n.context,r=n.componentInstance||n.elm,o=i.$refs;e?Array.isArray(o[t])?y(o[t],r):o[t]===r&&(o[t]=void 0):n.data.refInFor?Array.isArray(o[t])?o[t].indexOf(r)<0&&o[t].push(r):o[t]=[r]:o[t]=r}}var ni=new hn("",{},[]),ei=["create","activate","update","remove","destroy"];function ti(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&a(n.data)===a(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,i=a(t=n.data)&&a(t=t.attrs)&&t.type,r=a(t=e.data)&&a(t=t.attrs)&&t.type;return i===r||Qt(i)&&Qt(r)}(n,e)||o(n.isAsyncPlaceholder)&&r(e.asyncFactory.error))}function ii(n,e,t){var i,r,o={};for(i=e;i<=t;++i)a(r=n[i].key)&&(o[r]=i);return o}var ri={create:ai,update:ai,destroy:function(n){ai(n,ni)}};function ai(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,i,r,a=n===ni,o=e===ni,s=si(n.data.directives,n.context),c=si(e.data.directives,e.context),l=[],u=[];for(t in c)i=s[t],r=c[t],i?(r.oldValue=i.value,r.oldArg=i.arg,li(r,"update",e,n),r.def&&r.def.componentUpdated&&u.push(r)):(li(r,"bind",e,n),r.def&&r.def.inserted&&l.push(r));if(l.length){var p=function(){for(var t=0;t<l.length;t++)li(l[t],"inserted",e,n)};a?le(e,"insert",p):p()}u.length&&le(e,"postpatch",(function(){for(var t=0;t<u.length;t++)li(u[t],"componentUpdated",e,n)}));if(!a)for(t in s)c[t]||li(s[t],"unbind",n,n,o)}(n,e)}var oi=Object.create(null);function si(n,e){var t,i,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++)(i=n[t]).modifiers||(i.modifiers=oi),r[ci(i)]=i,i.def=Nn(e.$options,"directives",i.name);return r}function ci(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function li(n,e,t,i,r){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,i,r)}catch(i){qn(i,t.context,"directive "+n.name+" "+e+" hook")}}var ui=[Zt,ri];function pi(n,e){var t=e.componentOptions;if(!(a(t)&&!1===t.Ctor.options.inheritAttrs||r(n.data.attrs)&&r(e.data.attrs))){var i,o,s=e.elm,c=n.data.attrs||{},l=e.data.attrs||{};for(i in a(l.__ob__)&&(l=e.data.attrs=E({},l)),l)o=l[i],c[i]!==o&&di(s,i,o,e.data.pre);for(i in(Y||K)&&l.value!==c.value&&di(s,"value",l.value),c)r(l[i])&&(Nt(i)?s.removeAttributeNS(Mt,Dt(i)):$t(i)||s.removeAttribute(i))}}function di(n,e,t,i){i||n.tagName.indexOf("-")>-1?fi(n,e,t):Rt(e)?Bt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):$t(e)?n.setAttribute(e,function(n,e){return Bt(e)||"false"===e?"false":"contenteditable"===n&&Lt(e)?e:"true"}(e,t)):Nt(e)?Bt(t)?n.removeAttributeNS(Mt,Dt(e)):n.setAttributeNS(Mt,e,t):fi(n,e,t)}function fi(n,e,t){if(Bt(t))n.removeAttribute(e);else{if(Y&&!Q&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var i=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",i)};n.addEventListener("input",i),n.__ieph=!0}n.setAttribute(e,t)}}var mi={create:pi,update:pi};function hi(n,e){var t=e.elm,i=e.data,o=n.data;if(!(r(i.staticClass)&&r(i.class)&&(r(o)||r(o.staticClass)&&r(o.class)))){var s=Wt(e),c=t._transitionClasses;a(c)&&(s=Ft(s,qt(c))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var vi,gi={create:hi,update:hi};function yi(n,e,t){var i=vi;return function r(){var a=e.apply(null,arguments);null!==a&&xi(n,r,t,i)}}var bi=Yn&&!(X&&Number(X[1])<=53);function _i(n,e,t,i){if(bi){var r=ct,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}vi.addEventListener(n,e,en?{capture:t,passive:i}:t)}function xi(n,e,t,i){(i||vi).removeEventListener(n,e._wrapper||e,t)}function wi(n,e){if(!r(n.data.on)||!r(e.data.on)){var t=e.data.on||{},i=n.data.on||{};vi=e.elm,function(n){if(a(n.__r)){var e=Y?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}a(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),ce(t,i,_i,xi,yi,e.context),vi=void 0}}var Ci,ki={create:wi,update:wi};function Ti(n,e){if(!r(n.data.domProps)||!r(e.data.domProps)){var t,i,o=e.elm,s=n.data.domProps||{},c=e.data.domProps||{};for(t in a(c.__ob__)&&(c=e.data.domProps=E({},c)),s)t in c||(o[t]="");for(t in c){if(i=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),i===s[t])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===t&&"PROGRESS"!==o.tagName){o._value=i;var l=r(i)?"":String(i);Ii(o,l)&&(o.value=l)}else if("innerHTML"===t&&Jt(o.tagName)&&r(o.innerHTML)){(Ci=Ci||document.createElement("div")).innerHTML="<svg>"+i+"</svg>";for(var u=Ci.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;u.firstChild;)o.appendChild(u.firstChild)}else if(i!==s[t])try{o[t]=i}catch(n){}}}}function Ii(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,i=n._vModifiers;if(a(i)){if(i.number)return h(t)!==h(e);if(i.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var zi={create:Ti,update:Ti},Si=x((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var i=n.split(t);i.length>1&&(e[i[0].trim()]=i[1].trim())}})),e}));function Ei(n){var e=ji(n.style);return n.staticStyle?E(n.staticStyle,e):e}function ji(n){return Array.isArray(n)?j(n):"string"==typeof n?Si(n):n}var Pi,Ai=/^--/,Oi=/\s*!important$/,$i=function(n,e,t){if(Ai.test(e))n.style.setProperty(e,t);else if(Oi.test(t))n.style.setProperty(I(e),t.replace(Oi,""),"important");else{var i=Ri(e);if(Array.isArray(t))for(var r=0,a=t.length;r<a;r++)n.style[i]=t[r];else n.style[i]=t}},Li=["Webkit","Moz","ms"],Ri=x((function(n){if(Pi=Pi||document.createElement("div").style,"filter"!==(n=C(n))&&n in Pi)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Li.length;t++){var i=Li[t]+e;if(i in Pi)return i}}));function Mi(n,e){var t=e.data,i=n.data;if(!(r(t.staticStyle)&&r(t.style)&&r(i.staticStyle)&&r(i.style))){var o,s,c=e.elm,l=i.staticStyle,u=i.normalizedStyle||i.style||{},p=l||u,d=ji(e.data.style)||{};e.data.normalizedStyle=a(d.__ob__)?E({},d):d;var f=function(n,e){var t,i={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Ei(r.data))&&E(i,t);(t=Ei(n.data))&&E(i,t);for(var a=n;a=a.parent;)a.data&&(t=Ei(a.data))&&E(i,t);return i}(e,!0);for(s in p)r(f[s])&&$i(c,s,"");for(s in f)(o=f[s])!==p[s]&&$i(c,s,null==o?"":o)}}var Ni={create:Mi,update:Mi},Di=/\s+/;function Bi(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Di).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Wi(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Di).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",i=" "+e+" ";t.indexOf(i)>=0;)t=t.replace(i," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Ui(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&E(e,Fi(n.name||"v")),E(e,n),e}return"string"==typeof n?Fi(n):void 0}}var Fi=x((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),qi=V&&!Q,Vi="transition",Gi="transitionend",Ji="animation",Hi="animationend";qi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Vi="WebkitTransition",Gi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ji="WebkitAnimation",Hi="webkitAnimationEnd"));var Yi=V?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Qi(n){Yi((function(){Yi(n)}))}function Ki(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Bi(n,e))}function Zi(n,e){n._transitionClasses&&y(n._transitionClasses,e),Wi(n,e)}function Xi(n,e,t){var i=er(n,e),r=i.type,a=i.timeout,o=i.propCount;if(!r)return t();var s="transition"===r?Gi:Hi,c=0,l=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++c>=o&&l()};setTimeout((function(){c<o&&l()}),a+1),n.addEventListener(s,u)}var nr=/\b(transform|all)(,|$)/;function er(n,e){var t,i=window.getComputedStyle(n),r=(i[Vi+"Delay"]||"").split(", "),a=(i[Vi+"Duration"]||"").split(", "),o=tr(r,a),s=(i[Ji+"Delay"]||"").split(", "),c=(i[Ji+"Duration"]||"").split(", "),l=tr(s,c),u=0,p=0;return"transition"===e?o>0&&(t="transition",u=o,p=a.length):"animation"===e?l>0&&(t="animation",u=l,p=c.length):p=(t=(u=Math.max(o,l))>0?o>l?"transition":"animation":null)?"transition"===t?a.length:c.length:0,{type:t,timeout:u,propCount:p,hasTransform:"transition"===t&&nr.test(i[Vi+"Property"])}}function tr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ir(e)+ir(n[t])})))}function ir(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function rr(n,e){var t=n.elm;a(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var i=Ui(n.data.transition);if(!r(i)&&!a(t._enterCb)&&1===t.nodeType){for(var o=i.css,s=i.type,l=i.enterClass,u=i.enterToClass,p=i.enterActiveClass,d=i.appearClass,f=i.appearToClass,m=i.appearActiveClass,v=i.beforeEnter,g=i.enter,y=i.afterEnter,b=i.enterCancelled,_=i.beforeAppear,x=i.appear,w=i.afterAppear,C=i.appearCancelled,k=i.duration,T=Ke,I=Ke.$vnode;I&&I.parent;)T=I.context,I=I.parent;var z=!T._isMounted||!n.isRootInsert;if(!z||x||""===x){var S=z&&d?d:l,E=z&&m?m:p,j=z&&f?f:u,P=z&&_||v,A=z&&"function"==typeof x?x:g,O=z&&w||y,$=z&&C||b,L=h(c(k)?k.enter:k);0;var M=!1!==o&&!Q,N=sr(A),D=t._enterCb=R((function(){M&&(Zi(t,j),Zi(t,E)),D.cancelled?(M&&Zi(t,S),$&&$(t)):O&&O(t),t._enterCb=null}));n.data.show||le(n,"insert",(function(){var e=t.parentNode,i=e&&e._pending&&e._pending[n.key];i&&i.tag===n.tag&&i.elm._leaveCb&&i.elm._leaveCb(),A&&A(t,D)})),P&&P(t),M&&(Ki(t,S),Ki(t,E),Qi((function(){Zi(t,S),D.cancelled||(Ki(t,j),N||(or(L)?setTimeout(D,L):Xi(t,s,D)))}))),n.data.show&&(e&&e(),A&&A(t,D)),M||N||D()}}}function ar(n,e){var t=n.elm;a(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var i=Ui(n.data.transition);if(r(i)||1!==t.nodeType)return e();if(!a(t._leaveCb)){var o=i.css,s=i.type,l=i.leaveClass,u=i.leaveToClass,p=i.leaveActiveClass,d=i.beforeLeave,f=i.leave,m=i.afterLeave,v=i.leaveCancelled,g=i.delayLeave,y=i.duration,b=!1!==o&&!Q,_=sr(f),x=h(c(y)?y.leave:y);0;var w=t._leaveCb=R((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),b&&(Zi(t,u),Zi(t,p)),w.cancelled?(b&&Zi(t,l),v&&v(t)):(e(),m&&m(t)),t._leaveCb=null}));g?g(C):C()}function C(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),d&&d(t),b&&(Ki(t,l),Ki(t,p),Qi((function(){Zi(t,l),w.cancelled||(Ki(t,u),_||(or(x)?setTimeout(w,x):Xi(t,s,w)))}))),f&&f(t,w),b||_||w())}}function or(n){return"number"==typeof n&&!isNaN(n)}function sr(n){if(r(n))return!1;var e=n.fns;return a(e)?sr(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function cr(n,e){!0!==e.data.show&&rr(e)}var lr=function(n){var e,t,i={},c=n.modules,l=n.nodeOps;for(e=0;e<ei.length;++e)for(i[ei[e]]=[],t=0;t<c.length;++t)a(c[t][ei[e]])&&i[ei[e]].push(c[t][ei[e]]);function u(n){var e=l.parentNode(n);a(e)&&l.removeChild(e,n)}function p(n,e,t,r,s,c,u){if(a(n.elm)&&a(c)&&(n=c[u]=bn(n)),n.isRootInsert=!s,!function(n,e,t,r){var s=n.data;if(a(s)){var c=a(n.componentInstance)&&s.keepAlive;if(a(s=s.hook)&&a(s=s.init)&&s(n,!1),a(n.componentInstance))return d(n,e),f(t,n.elm,r),o(c)&&function(n,e,t,r){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,a(o=s.data)&&a(o=o.transition)){for(o=0;o<i.activate.length;++o)i.activate[o](ni,s);e.push(s);break}f(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var p=n.data,h=n.children,v=n.tag;a(v)?(n.elm=n.ns?l.createElementNS(n.ns,v):l.createElement(v,n),y(n),m(n,h,e),a(p)&&g(n,e),f(t,n.elm,r)):o(n.isComment)?(n.elm=l.createComment(n.text),f(t,n.elm,r)):(n.elm=l.createTextNode(n.text),f(t,n.elm,r))}}function d(n,e){a(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,h(n)?(g(n,e),y(n)):(Xt(n),e.push(n))}function f(n,e,t){a(n)&&(a(t)?l.parentNode(t)===n&&l.insertBefore(n,e,t):l.appendChild(n,e))}function m(n,e,t){if(Array.isArray(e)){0;for(var i=0;i<e.length;++i)p(e[i],t,n.elm,null,!0,e,i)}else s(n.text)&&l.appendChild(n.elm,l.createTextNode(String(n.text)))}function h(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return a(n.tag)}function g(n,t){for(var r=0;r<i.create.length;++r)i.create[r](ni,n);a(e=n.data.hook)&&(a(e.create)&&e.create(ni,n),a(e.insert)&&t.push(n))}function y(n){var e;if(a(e=n.fnScopeId))l.setStyleScope(n.elm,e);else for(var t=n;t;)a(e=t.context)&&a(e=e.$options._scopeId)&&l.setStyleScope(n.elm,e),t=t.parent;a(e=Ke)&&e!==n.context&&e!==n.fnContext&&a(e=e.$options._scopeId)&&l.setStyleScope(n.elm,e)}function b(n,e,t,i,r,a){for(;i<=r;++i)p(t[i],a,n,e,!1,t,i)}function _(n){var e,t,r=n.data;if(a(r))for(a(e=r.hook)&&a(e=e.destroy)&&e(n),e=0;e<i.destroy.length;++e)i.destroy[e](n);if(a(e=n.children))for(t=0;t<n.children.length;++t)_(n.children[t])}function x(n,e,t){for(;e<=t;++e){var i=n[e];a(i)&&(a(i.tag)?(w(i),_(i)):u(i.elm))}}function w(n,e){if(a(e)||a(n.data)){var t,r=i.remove.length+1;for(a(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,r),a(t=n.componentInstance)&&a(t=t._vnode)&&a(t.data)&&w(t,e),t=0;t<i.remove.length;++t)i.remove[t](n,e);a(t=n.data.hook)&&a(t=t.remove)?t(n,e):e()}else u(n.elm)}function C(n,e,t,i){for(var r=t;r<i;r++){var o=e[r];if(a(o)&&ti(n,o))return r}}function k(n,e,t,s,c,u){if(n!==e){a(e.elm)&&a(s)&&(e=s[c]=bn(e));var d=e.elm=n.elm;if(o(n.isAsyncPlaceholder))a(e.asyncFactory.resolved)?z(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(o(e.isStatic)&&o(n.isStatic)&&e.key===n.key&&(o(e.isCloned)||o(e.isOnce)))e.componentInstance=n.componentInstance;else{var f,m=e.data;a(m)&&a(f=m.hook)&&a(f=f.prepatch)&&f(n,e);var v=n.children,g=e.children;if(a(m)&&h(e)){for(f=0;f<i.update.length;++f)i.update[f](n,e);a(f=m.hook)&&a(f=f.update)&&f(n,e)}r(e.text)?a(v)&&a(g)?v!==g&&function(n,e,t,i,o){var s,c,u,d=0,f=0,m=e.length-1,h=e[0],v=e[m],g=t.length-1,y=t[0],_=t[g],w=!o;for(0;d<=m&&f<=g;)r(h)?h=e[++d]:r(v)?v=e[--m]:ti(h,y)?(k(h,y,i,t,f),h=e[++d],y=t[++f]):ti(v,_)?(k(v,_,i,t,g),v=e[--m],_=t[--g]):ti(h,_)?(k(h,_,i,t,g),w&&l.insertBefore(n,h.elm,l.nextSibling(v.elm)),h=e[++d],_=t[--g]):ti(v,y)?(k(v,y,i,t,f),w&&l.insertBefore(n,v.elm,h.elm),v=e[--m],y=t[++f]):(r(s)&&(s=ii(e,d,m)),r(c=a(y.key)?s[y.key]:C(y,e,d,m))?p(y,i,n,h.elm,!1,t,f):ti(u=e[c],y)?(k(u,y,i,t,f),e[c]=void 0,w&&l.insertBefore(n,u.elm,h.elm)):p(y,i,n,h.elm,!1,t,f),y=t[++f]);d>m?b(n,r(t[g+1])?null:t[g+1].elm,t,f,g,i):f>g&&x(e,d,m)}(d,v,g,t,u):a(g)?(a(n.text)&&l.setTextContent(d,""),b(d,null,g,0,g.length-1,t)):a(v)?x(v,0,v.length-1):a(n.text)&&l.setTextContent(d,""):n.text!==e.text&&l.setTextContent(d,e.text),a(m)&&a(f=m.hook)&&a(f=f.postpatch)&&f(n,e)}}}function T(n,e,t){if(o(t)&&a(n.parent))n.parent.data.pendingInsert=e;else for(var i=0;i<e.length;++i)e[i].data.hook.insert(e[i])}var I=v("attrs,class,staticClass,staticStyle,key");function z(n,e,t,i){var r,s=e.tag,c=e.data,l=e.children;if(i=i||c&&c.pre,e.elm=n,o(e.isComment)&&a(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(a(c)&&(a(r=c.hook)&&a(r=r.init)&&r(e,!0),a(r=e.componentInstance)))return d(e,t),!0;if(a(s)){if(a(l))if(n.hasChildNodes())if(a(r=c)&&a(r=r.domProps)&&a(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var u=!0,p=n.firstChild,f=0;f<l.length;f++){if(!p||!z(p,l[f],t,i)){u=!1;break}p=p.nextSibling}if(!u||p)return!1}else m(e,l,t);if(a(c)){var h=!1;for(var v in c)if(!I(v)){h=!0,g(e,t);break}!h&&c.class&&ae(c.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,s){if(!r(e)){var c,u=!1,d=[];if(r(n))u=!0,p(e,d);else{var f=a(n.nodeType);if(!f&&ti(n,e))k(n,e,d,null,null,s);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),o(t)&&z(n,e,d))return T(e,d,!0),n;c=n,n=new hn(l.tagName(c).toLowerCase(),{},[],void 0,c)}var m=n.elm,v=l.parentNode(m);if(p(e,d,m._leaveCb?null:v,l.nextSibling(m)),a(e.parent))for(var g=e.parent,y=h(e);g;){for(var b=0;b<i.destroy.length;++b)i.destroy[b](g);if(g.elm=e.elm,y){for(var w=0;w<i.create.length;++w)i.create[w](ni,g);var C=g.data.hook.insert;if(C.merged)for(var I=1;I<C.fns.length;I++)C.fns[I]()}else Xt(g);g=g.parent}a(v)?x([n],0,0):a(n.tag)&&_(n)}}return T(e,d,u),e.elm}a(n)&&_(n)}}({nodeOps:Kt,modules:[mi,gi,ki,zi,Ni,V?{create:cr,activate:cr,remove:function(n,e){!0!==n.data.show?ar(n,e):e()}}:{}].concat(ui)});Q&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&gr(n,"input")}));var ur={inserted:function(n,e,t,i){"select"===t.tag?(i.elm&&!i.elm._vOptions?le(t,"postpatch",(function(){ur.componentUpdated(n,e,t)})):pr(n,e,t.context),n._vOptions=[].map.call(n.options,mr)):("textarea"===t.tag||Qt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",hr),n.addEventListener("compositionend",vr),n.addEventListener("change",vr),Q&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){pr(n,e,t.context);var i=n._vOptions,r=n._vOptions=[].map.call(n.options,mr);if(r.some((function(n,e){return!$(n,i[e])})))(n.multiple?e.value.some((function(n){return fr(n,r)})):e.value!==e.oldValue&&fr(e.value,r))&&gr(n,"change")}}};function pr(n,e,t){dr(n,e,t),(Y||K)&&setTimeout((function(){dr(n,e,t)}),0)}function dr(n,e,t){var i=e.value,r=n.multiple;if(!r||Array.isArray(i)){for(var a,o,s=0,c=n.options.length;s<c;s++)if(o=n.options[s],r)a=L(i,mr(o))>-1,o.selected!==a&&(o.selected=a);else if($(mr(o),i))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function fr(n,e){return e.every((function(e){return!$(e,n)}))}function mr(n){return"_value"in n?n._value:n.value}function hr(n){n.target.composing=!0}function vr(n){n.target.composing&&(n.target.composing=!1,gr(n.target,"input"))}function gr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function yr(n){return!n.componentInstance||n.data&&n.data.transition?n:yr(n.componentInstance._vnode)}var br={model:ur,show:{bind:function(n,e,t){var i=e.value,r=(t=yr(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;i&&r?(t.data.show=!0,rr(t,(function(){n.style.display=a}))):n.style.display=i?a:"none"},update:function(n,e,t){var i=e.value;!i!=!e.oldValue&&((t=yr(t)).data&&t.data.transition?(t.data.show=!0,i?rr(t,(function(){n.style.display=n.__vOriginalDisplay})):ar(t,(function(){n.style.display="none"}))):n.style.display=i?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,i,r){r||(n.style.display=n.__vOriginalDisplay)}}},_r={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function xr(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?xr(Ge(e.children)):n}function wr(n){var e={},t=n.$options;for(var i in t.propsData)e[i]=n[i];var r=t._parentListeners;for(var a in r)e[C(a)]=r[a];return e}function Cr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var kr=function(n){return n.tag||ve(n)},Tr=function(n){return"show"===n.name},Ir={name:"transition",props:_r,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(kr)).length){0;var i=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var a=xr(r);if(!a)return r;if(this._leaving)return Cr(n,r);var o="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?o+"comment":o+a.tag:s(a.key)?0===String(a.key).indexOf(o)?a.key:o+a.key:a.key;var c=(a.data||(a.data={})).transition=wr(this),l=this._vnode,u=xr(l);if(a.data.directives&&a.data.directives.some(Tr)&&(a.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,u)&&!ve(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var p=u.data.transition=E({},c);if("out-in"===i)return this._leaving=!0,le(p,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Cr(n,r);if("in-out"===i){if(ve(a))return l;var d,f=function(){d()};le(c,"afterEnter",f),le(c,"enterCancelled",f),le(p,"delayLeave",(function(n){d=n}))}}return r}}},zr=E({tag:String,moveClass:String},_r);function Sr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Er(n){n.data.newPos=n.elm.getBoundingClientRect()}function jr(n){var e=n.data.pos,t=n.data.newPos,i=e.left-t.left,r=e.top-t.top;if(i||r){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate("+i+"px,"+r+"px)",a.transitionDuration="0s"}}delete zr.mode;var Pr={Transition:Ir,TransitionGroup:{props:zr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,i){var r=Ze(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,i)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),i=this.prevChildren=this.children,r=this.$slots.default||[],a=this.children=[],o=wr(this),s=0;s<r.length;s++){var c=r[s];if(c.tag)if(null!=c.key&&0!==String(c.key).indexOf("__vlist"))a.push(c),t[c.key]=c,(c.data||(c.data={})).transition=o;else;}if(i){for(var l=[],u=[],p=0;p<i.length;p++){var d=i[p];d.data.transition=o,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?l.push(d):u.push(d)}this.kept=n(e,null,l),this.removed=u}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Sr),n.forEach(Er),n.forEach(jr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,i=t.style;Ki(t,e),i.transform=i.WebkitTransform=i.transitionDuration="",t.addEventListener(Gi,t._moveCb=function n(i){i&&i.target!==t||i&&!/transform$/.test(i.propertyName)||(t.removeEventListener(Gi,n),t._moveCb=null,Zi(t,e))})}})))},methods:{hasMove:function(n,e){if(!qi)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Wi(t,n)})),Bi(t,e),t.style.display="none",this.$el.appendChild(t);var i=er(t);return this.$el.removeChild(t),this._hasMove=i.hasTransform}}}};kt.config.mustUseProp=function(n,e,t){return"value"===t&&Ot(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},kt.config.isReservedTag=Ht,kt.config.isReservedAttr=At,kt.config.getTagNamespace=function(n){return Jt(n)?"svg":"math"===n?"math":void 0},kt.config.isUnknownElement=function(n){if(!V)return!0;if(Ht(n))return!1;if(n=n.toLowerCase(),null!=Yt[n])return Yt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Yt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Yt[n]=/HTMLUnknownElement/.test(e.toString())},E(kt.options.directives,br),E(kt.options.components,Pr),kt.prototype.__patch__=V?lr:P,kt.prototype.$mount=function(n,e){return function(n,e,t){var i;return n.$el=e,n.$options.render||(n.$options.render=gn),et(n,"beforeMount"),i=function(){n._update(n._render(),t)},new ft(n,i,P,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&V?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},V&&setTimeout((function(){D.devtools&&an&&an.emit("init",kt)}),0);var Ar=kt;
/*!
  * vue-router v3.5.4
  * (c) 2022 Evan You
  * @license MIT
  */function Or(n,e){for(var t in e)n[t]=e[t];return n}var $r=/[!'()*]/g,Lr=function(n){return"%"+n.charCodeAt(0).toString(16)},Rr=/%2C/g,Mr=function(n){return encodeURIComponent(n).replace($r,Lr).replace(Rr,",")};function Nr(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Dr=function(n){return null==n||"object"==typeof n?n:String(n)};function Br(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),i=Nr(t.shift()),r=t.length>0?Nr(t.join("=")):null;void 0===e[i]?e[i]=r:Array.isArray(e[i])?e[i].push(r):e[i]=[e[i],r]})),e):e}function Wr(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Mr(e);if(Array.isArray(t)){var i=[];return t.forEach((function(n){void 0!==n&&(null===n?i.push(Mr(e)):i.push(Mr(e)+"="+Mr(n)))})),i.join("&")}return Mr(e)+"="+Mr(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Ur=/\/?$/;function Fr(n,e,t,i){var r=i&&i.options.stringifyQuery,a=e.query||{};try{a=qr(a)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:Jr(e,r),matched:n?Gr(n):[]};return t&&(o.redirectedFrom=Jr(t,r)),Object.freeze(o)}function qr(n){if(Array.isArray(n))return n.map(qr);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=qr(n[t]);return e}return n}var Vr=Fr(null,{path:"/"});function Gr(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Jr(n,e){var t=n.path,i=n.query;void 0===i&&(i={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||Wr)(i)+r}function Hr(n,e,t){return e===Vr?n===e:!!e&&(n.path&&e.path?n.path.replace(Ur,"")===e.path.replace(Ur,"")&&(t||n.hash===e.hash&&Yr(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Yr(n.query,e.query)&&Yr(n.params,e.params))))}function Yr(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),i=Object.keys(e).sort();return t.length===i.length&&t.every((function(t,r){var a=n[t];if(i[r]!==t)return!1;var o=e[t];return null==a||null==o?a===o:"object"==typeof a&&"object"==typeof o?Yr(a,o):String(a)===String(o)}))}function Qr(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var i in t.instances){var r=t.instances[i],a=t.enteredCbs[i];if(r&&a){delete t.enteredCbs[i];for(var o=0;o<a.length;o++)r._isBeingDestroyed||a[o](r)}}}}var Kr={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,i=e.children,r=e.parent,a=e.data;a.routerView=!0;for(var o=r.$createElement,s=t.name,c=r.$route,l=r._routerViewCache||(r._routerViewCache={}),u=0,p=!1;r&&r._routerRoot!==r;){var d=r.$vnode?r.$vnode.data:{};d.routerView&&u++,d.keepAlive&&r._directInactive&&r._inactive&&(p=!0),r=r.$parent}if(a.routerViewDepth=u,p){var f=l[s],m=f&&f.component;return m?(f.configProps&&Zr(m,a,f.route,f.configProps),o(m,a,i)):o()}var h=c.matched[u],v=h&&h.components[s];if(!h||!v)return l[s]=null,o();l[s]={component:v},a.registerRouteInstance=function(n,e){var t=h.instances[s];(e&&t!==n||!e&&t===n)&&(h.instances[s]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){h.instances[s]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[s]&&(h.instances[s]=n.componentInstance),Qr(c)};var g=h.props&&h.props[s];return g&&(Or(l[s],{route:c,configProps:g}),Zr(v,a,c,g)),o(v,a,i)}};function Zr(n,e,t,i){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,i);if(r){r=e.props=Or({},r);var a=e.attrs=e.attrs||{};for(var o in r)n.props&&o in n.props||(a[o]=r[o],delete r[o])}}function Xr(n,e,t){var i=n.charAt(0);if("/"===i)return n;if("?"===i||"#"===i)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var s=a[o];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function na(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var ea=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ta=va,ia=ca,ra=function(n,e){return ua(ca(n,e),e)},aa=ua,oa=ha,sa=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function ca(n,e){for(var t,i=[],r=0,a=0,o="",s=e&&e.delimiter||"/";null!=(t=sa.exec(n));){var c=t[0],l=t[1],u=t.index;if(o+=n.slice(a,u),a=u+c.length,l)o+=l[1];else{var p=n[a],d=t[2],f=t[3],m=t[4],h=t[5],v=t[6],g=t[7];o&&(i.push(o),o="");var y=null!=d&&null!=p&&p!==d,b="+"===v||"*"===v,_="?"===v||"*"===v,x=t[2]||s,w=m||h;i.push({name:f||r++,prefix:d||"",delimiter:x,optional:_,repeat:b,partial:y,asterisk:!!g,pattern:w?da(w):g?".*":"[^"+pa(x)+"]+?"})}}return a<n.length&&(o+=n.substr(a)),o&&i.push(o),i}function la(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function ua(n,e){for(var t=new Array(n.length),i=0;i<n.length;i++)"object"==typeof n[i]&&(t[i]=new RegExp("^(?:"+n[i].pattern+")$",ma(e)));return function(e,i){for(var r="",a=e||{},o=(i||{}).pretty?la:encodeURIComponent,s=0;s<n.length;s++){var c=n[s];if("string"!=typeof c){var l,u=a[c.name];if(null==u){if(c.optional){c.partial&&(r+=c.prefix);continue}throw new TypeError('Expected "'+c.name+'" to be defined')}if(ea(u)){if(!c.repeat)throw new TypeError('Expected "'+c.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(c.optional)continue;throw new TypeError('Expected "'+c.name+'" to not be empty')}for(var p=0;p<u.length;p++){if(l=o(u[p]),!t[s].test(l))throw new TypeError('Expected all "'+c.name+'" to match "'+c.pattern+'", but received `'+JSON.stringify(l)+"`");r+=(0===p?c.prefix:c.delimiter)+l}}else{if(l=c.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(u),!t[s].test(l))throw new TypeError('Expected "'+c.name+'" to match "'+c.pattern+'", but received "'+l+'"');r+=c.prefix+l}}else r+=c}return r}}function pa(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function da(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function fa(n,e){return n.keys=e,n}function ma(n){return n&&n.sensitive?"":"i"}function ha(n,e,t){ea(e)||(t=e||t,e=[]);for(var i=(t=t||{}).strict,r=!1!==t.end,a="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)a+=pa(s);else{var c=pa(s.prefix),l="(?:"+s.pattern+")";e.push(s),s.repeat&&(l+="(?:"+c+l+")*"),a+=l=s.optional?s.partial?c+"("+l+")?":"(?:"+c+"("+l+"))?":c+"("+l+")"}}var u=pa(t.delimiter||"/"),p=a.slice(-u.length)===u;return i||(a=(p?a.slice(0,-u.length):a)+"(?:"+u+"(?=$))?"),a+=r?"$":i&&p?"":"(?="+u+"|$)",fa(new RegExp("^"+a,ma(t)),e)}function va(n,e,t){return ea(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var i=0;i<t.length;i++)e.push({name:i,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return fa(n,e)}(n,e):ea(n)?function(n,e,t){for(var i=[],r=0;r<n.length;r++)i.push(va(n[r],e,t).source);return fa(new RegExp("(?:"+i.join("|")+")",ma(t)),e)}(n,e,t):function(n,e,t){return ha(ca(n,t),e,t)}(n,e,t)}ta.parse=ia,ta.compile=ra,ta.tokensToFunction=aa,ta.tokensToRegExp=oa;var ga=Object.create(null);function ya(n,e,t){e=e||{};try{var i=ga[n]||(ga[n]=ta.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),i(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function ba(n,e,t,i){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var a=(r=Or({},n)).params;return a&&"object"==typeof a&&(r.params=Or({},a)),r}if(!r.path&&r.params&&e){(r=Or({},r))._normalized=!0;var o=Or(Or({},e.params),r.params);if(e.name)r.name=e.name,r.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;r.path=ya(s,o,e.path)}else 0;return r}var c=function(n){var e="",t="",i=n.indexOf("#");i>=0&&(e=n.slice(i),n=n.slice(0,i));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),l=e&&e.path||"/",u=c.path?Xr(c.path,l,t||r.append):l,p=function(n,e,t){void 0===e&&(e={});var i,r=t||Br;try{i=r(n||"")}catch(n){i={}}for(var a in e){var o=e[a];i[a]=Array.isArray(o)?o.map(Dr):Dr(o)}return i}(c.query,r.query,i&&i.options.parseQuery),d=r.hash||c.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:u,query:p,hash:d}}var _a,xa=function(){},wa={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,i=this.$route,r=t.resolve(this.to,i,this.append),a=r.location,o=r.route,s=r.href,c={},l=t.options.linkActiveClass,u=t.options.linkExactActiveClass,p=null==l?"router-link-active":l,d=null==u?"router-link-exact-active":u,f=null==this.activeClass?p:this.activeClass,m=null==this.exactActiveClass?d:this.exactActiveClass,h=o.redirectedFrom?Fr(null,ba(o.redirectedFrom),null,t):o;c[m]=Hr(i,h,this.exactPath),c[f]=this.exact||this.exactPath?c[m]:function(n,e){return 0===n.path.replace(Ur,"/").indexOf(e.path.replace(Ur,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(i,h);var v=c[m]?this.ariaCurrentValue:null,g=function(n){Ca(n)&&(e.replace?t.replace(a,xa):t.push(a,xa))},y={click:Ca};Array.isArray(this.event)?this.event.forEach((function(n){y[n]=g})):y[this.event]=g;var b={class:c},_=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:g,isActive:c[f],isExactActive:c[m]});if(_){if(1===_.length)return _[0];if(_.length>1||!_.length)return 0===_.length?n():n("span",{},_)}if("a"===this.tag)b.on=y,b.attrs={href:s,"aria-current":v};else{var x=function n(e){var t;if(e)for(var i=0;i<e.length;i++){if("a"===(t=e[i]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var w=x.data=Or({},x.data);for(var C in w.on=w.on||{},w.on){var k=w.on[C];C in y&&(w.on[C]=Array.isArray(k)?k:[k])}for(var T in y)T in w.on?w.on[T].push(y[T]):w.on[T]=g;var I=x.data.attrs=Or({},x.data.attrs);I.href=s,I["aria-current"]=v}else b.on=y}return n(this.tag,b,this.$slots.default)}};function Ca(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var ka="undefined"!=typeof window;function Ta(n,e,t,i,r){var a=e||[],o=t||Object.create(null),s=i||Object.create(null);n.forEach((function(n){!function n(e,t,i,r,a,o){var s=r.path,c=r.name;0;var l=r.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return na(e.path+"/"+n)}(s,a,l.strict);"boolean"==typeof r.caseSensitive&&(l.sensitive=r.caseSensitive);var p={path:u,regex:Ia(u,l),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:c,parent:a,matchAs:o,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var a=o?na(o+"/"+r.path):void 0;n(e,t,i,r,p,a)}));t[p.path]||(e.push(p.path),t[p.path]=p);if(void 0!==r.alias)for(var d=Array.isArray(r.alias)?r.alias:[r.alias],f=0;f<d.length;++f){0;var m={path:d[f],children:r.children};n(e,t,i,m,a,p.path||"/")}c&&(i[c]||(i[c]=p))}(a,o,s,n,r)}));for(var c=0,l=a.length;c<l;c++)"*"===a[c]&&(a.push(a.splice(c,1)[0]),l--,c--);return{pathList:a,pathMap:o,nameMap:s}}function Ia(n,e){return ta(n,[],e)}function za(n,e){var t=Ta(n),i=t.pathList,r=t.pathMap,a=t.nameMap;function o(n,t,o){var s=ba(n,t,!1,e),l=s.name;if(l){var u=a[l];if(!u)return c(null,s);var p=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var d in t.params)!(d in s.params)&&p.indexOf(d)>-1&&(s.params[d]=t.params[d]);return s.path=ya(u.path,s.params),c(u,s,o)}if(s.path){s.params={};for(var f=0;f<i.length;f++){var m=i[f],h=r[m];if(Sa(h.regex,s.path,s.params))return c(h,s,o)}}return c(null,s)}function s(n,t){var i=n.redirect,r="function"==typeof i?i(Fr(n,t,null,e)):i;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return c(null,t);var s=r,l=s.name,u=s.path,p=t.query,d=t.hash,f=t.params;if(p=s.hasOwnProperty("query")?s.query:p,d=s.hasOwnProperty("hash")?s.hash:d,f=s.hasOwnProperty("params")?s.params:f,l){a[l];return o({_normalized:!0,name:l,query:p,hash:d,params:f},void 0,t)}if(u){var m=function(n,e){return Xr(n,e.parent?e.parent.path:"/",!0)}(u,n);return o({_normalized:!0,path:ya(m,f),query:p,hash:d},void 0,t)}return c(null,t)}function c(n,t,i){return n&&n.redirect?s(n,i||t):n&&n.matchAs?function(n,e,t){var i=o({_normalized:!0,path:ya(t,e.params)});if(i){var r=i.matched,a=r[r.length-1];return e.params=i.params,c(a,e)}return c(null,e)}(0,t,n.matchAs):Fr(n,t,i,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Ta([e||n],i,r,a,t),t&&t.alias.length&&Ta(t.alias.map((function(n){return{path:n,children:[e]}})),i,r,a,t)},getRoutes:function(){return i.map((function(n){return r[n]}))},addRoutes:function(n){Ta(n,i,r,a)}}}function Sa(n,e,t){var i=e.match(n);if(!i)return!1;if(!t)return!0;for(var r=1,a=i.length;r<a;++r){var o=n.keys[r-1];o&&(t[o.name||"pathMatch"]="string"==typeof i[r]?Nr(i[r]):i[r])}return!0}var Ea=ka&&window.performance&&window.performance.now?window.performance:Date;function ja(){return Ea.now().toFixed(3)}var Pa=ja();function Aa(){return Pa}function Oa(n){return Pa=n}var $a=Object.create(null);function La(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Or({},window.history.state);return t.key=Aa(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Na),function(){window.removeEventListener("popstate",Na)}}function Ra(n,e,t,i){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var a=function(){var n=Aa();if(n)return $a[n]}(),o=r.call(n,e,t,i?a:null);o&&("function"==typeof o.then?o.then((function(n){Fa(n,a)})).catch((function(n){0})):Fa(o,a))}))}}function Ma(){var n=Aa();n&&($a[n]={x:window.pageXOffset,y:window.pageYOffset})}function Na(n){Ma(),n.state&&n.state.key&&Oa(n.state.key)}function Da(n){return Wa(n.x)||Wa(n.y)}function Ba(n){return{x:Wa(n.x)?n.x:window.pageXOffset,y:Wa(n.y)?n.y:window.pageYOffset}}function Wa(n){return"number"==typeof n}var Ua=/^#\d/;function Fa(n,e){var t,i="object"==typeof n;if(i&&"string"==typeof n.selector){var r=Ua.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),i=n.getBoundingClientRect();return{x:i.left-t.left-e.x,y:i.top-t.top-e.y}}(r,a={x:Wa((t=a).x)?t.x:0,y:Wa(t.y)?t.y:0})}else Da(n)&&(e=Ba(n))}else i&&Da(n)&&(e=Ba(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var qa,Va=ka&&((-1===(qa=window.navigator.userAgent).indexOf("Android 2.")&&-1===qa.indexOf("Android 4.0")||-1===qa.indexOf("Mobile Safari")||-1!==qa.indexOf("Chrome")||-1!==qa.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Ga(n,e){Ma();var t=window.history;try{if(e){var i=Or({},t.state);i.key=Aa(),t.replaceState(i,"",n)}else t.pushState({key:Oa(ja())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Ja(n){Ga(n,!0)}function Ha(n,e,t){var i=function(r){r>=n.length?t():n[r]?e(n[r],(function(){i(r+1)})):i(r+1)};i(0)}var Ya={redirected:2,aborted:4,cancelled:8,duplicated:16};function Qa(n,e){return Za(n,e,Ya.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Xa.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Ka(n,e){return Za(n,e,Ya.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Za(n,e,t,i){var r=new Error(i);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var Xa=["params","query","hash"];function no(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function eo(n,e){return no(n)&&n._isRouter&&(null==e||n.type===e)}function to(n){return function(e,t,i){var r=!1,a=0,o=null;io(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,a++;var c,l=oo((function(e){var r;((r=e).__esModule||ao&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:_a.extend(e),t.components[s]=e,--a<=0&&i()})),u=oo((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=no(n)?n:new Error(e),i(o))}));try{c=n(l,u)}catch(n){u(n)}if(c)if("function"==typeof c.then)c.then(l,u);else{var p=c.component;p&&"function"==typeof p.then&&p.then(l,u)}}})),r||i()}}function io(n,e){return ro(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function ro(n){return Array.prototype.concat.apply([],n)}var ao="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function oo(n){var e=!1;return function(){for(var t=[],i=arguments.length;i--;)t[i]=arguments[i];if(!e)return e=!0,n.apply(this,t)}}var so=function(n,e){this.router=n,this.base=function(n){if(!n)if(ka){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Vr,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function co(n,e,t,i){var r=io(n,(function(n,i,r,a){var o=function(n,e){"function"!=typeof n&&(n=_a.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,i,r,a)})):t(o,i,r,a)}));return ro(i?r.reverse():r)}function lo(n,e){if(e)return function(){return n.apply(e,arguments)}}so.prototype.listen=function(n){this.cb=n},so.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},so.prototype.onError=function(n){this.errorCbs.push(n)},so.prototype.transitionTo=function(n,e,t){var i,r=this;try{i=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(i,(function(){r.updateRoute(i),e&&e(i),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(i,a)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(i)})))}),(function(n){t&&t(n),n&&!r.ready&&(eo(n,Ya.redirected)&&a===Vr||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},so.prototype.confirmTransition=function(n,e,t){var i=this,r=this.current;this.pending=n;var a,o,s=function(n){!eo(n)&&no(n)&&(i.errorCbs.length?i.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},c=n.matched.length-1,l=r.matched.length-1;if(Hr(n,r)&&c===l&&n.matched[c]===r.matched[l])return this.ensureURL(),n.hash&&Ra(this.router,r,n,!1),s(((o=Za(a=r,n,Ya.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",o));var u=function(n,e){var t,i=Math.max(n.length,e.length);for(t=0;t<i&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),p=u.updated,d=u.deactivated,f=u.activated,m=[].concat(function(n){return co(n,"beforeRouteLeave",lo,!0)}(d),this.router.beforeHooks,function(n){return co(n,"beforeRouteUpdate",lo)}(p),f.map((function(n){return n.beforeEnter})),to(f)),h=function(e,t){if(i.pending!==n)return s(Ka(r,n));try{e(n,r,(function(e){!1===e?(i.ensureURL(!0),s(function(n,e){return Za(n,e,Ya.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):no(e)?(i.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(Qa(r,n)),"object"==typeof e&&e.replace?i.replace(e):i.push(e)):t(e)}))}catch(n){s(n)}};Ha(m,h,(function(){Ha(function(n){return co(n,"beforeRouteEnter",(function(n,e,t,i){return function(n,e,t){return function(i,r,a){return n(i,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,i)}))}(f).concat(i.router.resolveHooks),h,(function(){if(i.pending!==n)return s(Ka(r,n));i.pending=null,e(n),i.router.app&&i.router.app.$nextTick((function(){Qr(n)}))}))}))},so.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},so.prototype.setupListeners=function(){},so.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Vr,this.pending=null};var uo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=po(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,i=Va&&t;i&&this.listeners.push(La());var r=function(){var t=n.current,r=po(n.base);n.current===Vr&&r===n._startLocation||n.transitionTo(r,(function(n){i&&Ra(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){Ga(na(i.base+n.fullPath)),Ra(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){Ja(na(i.base+n.fullPath)),Ra(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(po(this.base)!==this.current.fullPath){var e=na(this.base+this.current.fullPath);n?Ga(e):Ja(e)}},e.prototype.getCurrentLocation=function(){return po(this.base)},e}(so);function po(n){var e=window.location.pathname,t=e.toLowerCase(),i=n.toLowerCase();return!n||t!==i&&0!==t.indexOf(na(i+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var fo=function(n){function e(e,t,i){n.call(this,e,t),i&&function(n){var e=po(n);if(!/^\/#/.test(e))return window.location.replace(na(n+"/#"+e)),!0}(this.base)||mo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Va&&e;t&&this.listeners.push(La());var i=function(){var e=n.current;mo()&&n.transitionTo(ho(),(function(i){t&&Ra(n.router,i,e,!0),Va||yo(i.fullPath)}))},r=Va?"popstate":"hashchange";window.addEventListener(r,i),this.listeners.push((function(){window.removeEventListener(r,i)}))}},e.prototype.push=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){go(n.fullPath),Ra(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){yo(n.fullPath),Ra(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;ho()!==e&&(n?go(e):yo(e))},e.prototype.getCurrentLocation=function(){return ho()},e}(so);function mo(){var n=ho();return"/"===n.charAt(0)||(yo("/"+n),!1)}function ho(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function vo(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function go(n){Va?Ga(vo(n)):window.location.hash=n}function yo(n){Va?Ja(vo(n)):window.location.replace(vo(n))}var bo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var i=this;this.transitionTo(n,(function(n){i.stack=i.stack.slice(0,i.index+1).concat(n),i.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this;this.transitionTo(n,(function(n){i.stack=i.stack.slice(0,i.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var i=this.stack[t];this.confirmTransition(i,(function(){var n=e.current;e.index=t,e.updateRoute(i),e.router.afterHooks.forEach((function(e){e&&e(i,n)}))}),(function(n){eo(n,Ya.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(so),_o=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=za(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Va&&!1!==n.fallback,this.fallback&&(e="hash"),ka||(e="abstract"),this.mode=e,e){case"history":this.history=new uo(this,n.base);break;case"hash":this.history=new fo(this,n.base,this.fallback);break;case"abstract":this.history=new bo(this,n.base);break;default:0}},xo={currentRoute:{configurable:!0}};function wo(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}_o.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},xo.currentRoute.get=function(){return this.history&&this.history.current},_o.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof uo||t instanceof fo){var i=function(n){t.setupListeners(),function(n){var i=t.current,r=e.options.scrollBehavior;Va&&r&&"fullPath"in n&&Ra(e,n,i,!1)}(n)};t.transitionTo(t.getCurrentLocation(),i,i)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},_o.prototype.beforeEach=function(n){return wo(this.beforeHooks,n)},_o.prototype.beforeResolve=function(n){return wo(this.resolveHooks,n)},_o.prototype.afterEach=function(n){return wo(this.afterHooks,n)},_o.prototype.onReady=function(n,e){this.history.onReady(n,e)},_o.prototype.onError=function(n){this.history.onError(n)},_o.prototype.push=function(n,e,t){var i=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){i.history.push(n,e,t)}));this.history.push(n,e,t)},_o.prototype.replace=function(n,e,t){var i=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){i.history.replace(n,e,t)}));this.history.replace(n,e,t)},_o.prototype.go=function(n){this.history.go(n)},_o.prototype.back=function(){this.go(-1)},_o.prototype.forward=function(){this.go(1)},_o.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},_o.prototype.resolve=function(n,e,t){var i=ba(n,e=e||this.history.current,t,this),r=this.match(i,e),a=r.redirectedFrom||r.fullPath;return{location:i,route:r,href:function(n,e,t){var i="hash"===t?"#"+e:e;return n?na(n+"/"+i):i}(this.history.base,a,this.mode),normalizedTo:i,resolved:r}},_o.prototype.getRoutes=function(){return this.matcher.getRoutes()},_o.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Vr&&this.history.transitionTo(this.history.getCurrentLocation())},_o.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Vr&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(_o.prototype,xo),_o.install=function n(e){if(!n.installed||_a!==e){n.installed=!0,_a=e;var t=function(n){return void 0!==n},i=function(n,e){var i=n.$options._parentVnode;t(i)&&t(i=i.data)&&t(i=i.registerRouteInstance)&&i(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,i(this,this)},destroyed:function(){i(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Kr),e.component("RouterLink",wa);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},_o.version="3.5.4",_o.isNavigationFailure=eo,_o.NavigationFailureType=Ya,_o.START_LOCATION=Vr,ka&&window.Vue&&window.Vue.use(_o);var Co=_o;t(101);t(124);var ko={NotFound:()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,324)),Layout:()=>Promise.all([t.e(0),t.e(3),t.e(2)]).then(t.bind(null,323))},To={"v-465a10a3":()=>t.e(6).then(t.bind(null,325)),"v-7a9dff07":()=>t.e(8).then(t.bind(null,326)),"v-ae8ce3d2":()=>t.e(7).then(t.bind(null,327)),"v-18718c04":()=>t.e(9).then(t.bind(null,328)),"v-16253573":()=>t.e(12).then(t.bind(null,329)),"v-52de352b":()=>t.e(13).then(t.bind(null,330)),"v-602d1c42":()=>t.e(11).then(t.bind(null,331)),"v-6a18abfa":()=>t.e(14).then(t.bind(null,332)),"v-7d0fcd4a":()=>t.e(10).then(t.bind(null,333)),"v-9b512a1a":()=>t.e(15).then(t.bind(null,334)),"v-a31e7cfa":()=>t.e(16).then(t.bind(null,335)),"v-adaed63a":()=>t.e(17).then(t.bind(null,336)),"v-0eba4323":()=>t.e(18).then(t.bind(null,337)),"v-38c4d983":()=>t.e(19).then(t.bind(null,338)),"v-808e1b3a":()=>t.e(20).then(t.bind(null,339)),"v-19e58c3a":()=>t.e(21).then(t.bind(null,340)),"v-448f6e72":()=>t.e(22).then(t.bind(null,341)),"v-acc65afa":()=>t.e(23).then(t.bind(null,342)),"v-3cdd7c23":()=>t.e(24).then(t.bind(null,343)),"v-28c8daa4":()=>t.e(25).then(t.bind(null,344)),"v-1497abd7":()=>t.e(26).then(t.bind(null,345)),"v-e027eb68":()=>t.e(27).then(t.bind(null,346)),"v-7b0d9a9e":()=>t.e(28).then(t.bind(null,347)),"v-7dbd198c":()=>t.e(29).then(t.bind(null,348)),"v-249122e1":()=>t.e(31).then(t.bind(null,349)),"v-5687f1b4":()=>t.e(32).then(t.bind(null,350)),"v-06ae3d06":()=>t.e(33).then(t.bind(null,351)),"v-7fefcb5b":()=>t.e(34).then(t.bind(null,352)),"v-18172e6c":()=>t.e(30).then(t.bind(null,353)),"v-1cc12d3b":()=>t.e(35).then(t.bind(null,354)),"v-2f694f79":()=>t.e(36).then(t.bind(null,355)),"v-64b006d2":()=>t.e(37).then(t.bind(null,356)),"v-4cf7131f":()=>t.e(38).then(t.bind(null,357)),"v-3dcfaa6a":()=>t.e(39).then(t.bind(null,358)),"v-76d7a407":()=>t.e(40).then(t.bind(null,359)),"v-04def3fa":()=>t.e(41).then(t.bind(null,360)),"v-faf1db3a":()=>t.e(42).then(t.bind(null,361)),"v-b1c16cfa":()=>t.e(43).then(t.bind(null,362)),"v-cda71308":()=>t.e(44).then(t.bind(null,363)),"v-1bf730e3":()=>t.e(45).then(t.bind(null,364)),"v-f6245f3a":()=>t.e(46).then(t.bind(null,365)),"v-e5b4aac8":()=>t.e(47).then(t.bind(null,366))};function Io(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const zo=/-(\w)/g,So=Io(n=>n.replace(zo,(n,e)=>e?e.toUpperCase():"")),Eo=/\B([A-Z])/g,jo=Io(n=>n.replace(Eo,"-$1").toLowerCase()),Po=Io(n=>n.charAt(0).toUpperCase()+n.slice(1));function Ao(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Po(So(e))):n(Po(e))||n(jo(e))}const Oo=Object.assign({},ko,To),$o=n=>Oo[n],Lo=n=>To[n],Ro=n=>ko[n],Mo=n=>Ar.component(n);function No(n){return Ao(Lo,n)}function Do(n){return Ao(Ro,n)}function Bo(n){return Ao($o,n)}function Wo(n){return Ao(Mo,n)}function Uo(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!Wo(n)&&Bo(n)){const e=await Bo(n)();Ar.component(n,e.default)}}))}function Fo(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var qo=t(90),Vo=t.n(qo),Go=t(91),Jo=t.n(Go),Ho={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${Jo()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=Qo(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=Ko(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return Vo()([{name:"description",content:this.$description}],n,this.siteMeta,Zo)},updateCanonicalLink(){Yo(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",Qo(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){Ko(null,this.currentMetaTags),Yo()}};function Yo(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function Qo(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function Ko(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function Zo(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var Xo=t(49),ns={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(Xo)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],o=e[n+1],s=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),c=decodeURIComponent(this.$route.hash);if(s&&c!==decodeURIComponent(a.hash)){const t=a;if(r===i)for(let t=n+1;t<e.length;t++)if(c===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},es=t(23),ts=t.n(es),is={mounted(){ts.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Ar.component(n.name)||ts.a.start(),t()}),this.$router.afterEach(()=>{ts.a.done(),this.isSidebarOpen=!1})}};t(231),t(232);class rs{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var as={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new rs).show({text:"Copied",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var i=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&i.firstChild?i.insertBefore(r,i.firstChild):i.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var os={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},ss={},cs=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},ls=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:os[n]},us=function n(e,t,i){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),i&&i.forEach((function(e){var t=e.tag,i=e.attrs,a=e.children;r.appendChild(n(t,i,a))})),r},ps=function(n,e,t){var i,r=(i=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(i));return 1!==r.length||t?r:r[0]},ds=function(n,e){var t,i,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=cs(s.html),s.jsTpl=(t=s.js,i=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(i,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),i="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(i,{presets:["es2015"]}).code:i,a=[eval][0](r);return a.template=e,a}(s.js,s.html);var c=ls("vue");return s.jsLib.unshift(c),s},fs=function(n,e){var t,i=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),o={css:i&&i[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},ms=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function hs(){var n=ps(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=ps(n,"vuepress-plugin-demo-block__code"),t=ps(n,"vuepress-plugin-demo-block__display"),i=ps(n,"vuepress-plugin-demo-block__footer"),r=ps(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var c=e.querySelector("div").clientHeight,l="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,i="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(i))(),a={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:ms(n),htmlTpl:cs("")},o=ls("react"),s=ls("reactDOM");return a.jsLib.unshift(o,s),a}(a,o):"vanilla"===s?fs(a,o):ds(a,o),u=us("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(i.appendChild(u),u.addEventListener("click",vs.bind(null,u,c,e,i)),ls("jsfiddle")&&i.appendChild(function(n){var e=n.css,t=n.htmlTpl,i=n.jsTpl,r=n.jsLib,a=n.cssLib,o=r.concat(a).concat(ls("cssLib")).concat(ls("jsLib")).join(",");return us("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:i}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(l)),ls("codepen")&&i.appendChild(function(n){var e=n.css,t=n.htmlTpl,i=n.jsTpl,r=n.jsLib,a=n.cssLib,o=JSON.stringify({css:e,html:t,js:i,js_external:r.concat(ls("jsLib")).join(";"),css_external:a.concat(ls("cssLib")).join(";"),layout:ls("codepenLayout"),js_pre_processor:ls("codepenJsProcessor"),editors:ls("codepenEditors")});return us("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(l)),void 0!==o.horizontal?o.horizontal:ls("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=e.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(p)}if(l.css&&function(n){if(!ss[n]){var e=us("style",{innerHTML:n});document.body.appendChild(e),ss[n]=!0}}(l.css),"react"===s)ReactDOM.render(React.createElement(l.js),r);else if("vue"===s){var d=(new(Vue.extend(l.script))).$mount();r.appendChild(d.$el)}else"vanilla"===s&&(r.innerHTML=l.html,new Function("return (function(){".concat(l.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){hs()}),300)}function vs(n,e,t,i){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?i.classList.add("vuepress-plugin-demo-block__show-link"):i.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var gs={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},hs()},updated:function(){hs()}},ys="auto",bs="zoom-in",_s="zoom-out",xs="grab",ws="move";function Cs(n,e,t){var i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};i?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function ks(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Ts(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Is(n,e,t){!function(n){var e=zs,t=Ss;if(n.transition){var i=n.transition;delete n.transition,n[e]=i}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var i=n.style,r={};for(var a in e)t&&(r[a]=i[a]||""),i[a]=e[a];return r}var zs="transition",Ss="transform",Es="transform",js="transitionend";var Ps=function(){},As={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Ps,onClose:Ps,onGrab:Ps,onMove:Ps,onRelease:Ps,onBeforeOpen:Ps,onBeforeClose:Ps,onBeforeGrab:Ps,onBeforeRelease:Ps,onImageLoading:Ps,onImageLoaded:Ps},Os={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Ls(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var i=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(r)>=a||Math.abs(i)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if($s(n)&&!Ls(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){$s(n)&&!Ls(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,i=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,i)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,i=e.clientY;this.move(t,i)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function $s(n){return 0===n.button}function Ls(n){return n.metaKey||n.ctrlKey}var Rs={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Is(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Cs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Is(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Ms="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Ns=function(){function n(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}return function(e,t,i){return t&&n(e.prototype,t),i&&n(e,i),e}}(),Ds=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n},Bs={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Ts(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,i=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?xs:_s,transition:Es+"\n        "+i+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Is(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Is(this.el,{transform:"none"})},grab:function(n,e,t){var i=Ws(),r=i.x-n,a=i.y-e;Is(this.el,{cursor:ws,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var i=Ws(),r=i.x-n,a=i.y-e;Is(this.el,{transition:Es,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Is(this.el,this.styleClose)},restoreOpenStyle:function(){Is(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Ws(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,i=this.instance.options,r=i.customSize,a=i.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":Ms(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,c=Ws(),l={x:c.x-o,y:c.y-s},u=l.x/o,p=l.y/s,d=a+Math.min(u,p);if(r&&"string"==typeof r){var f=t||this.el.naturalWidth,m=e||this.el.naturalHeight,h=parseFloat(r)*f/(100*this.rect.width),v=parseFloat(r)*m/(100*this.rect.height);if(d>h||d>v)return{x:h,y:v}}return{x:d,y:d}}};function Ws(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Us(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(i){Cs(n,i,e[i],t)}))}var Fs=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Bs),this.overlay=Object.create(Rs),this.handler=Object.create(Os),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Ds({},As,e),this.overlay.init(this),this.handler.init(this)}return Ns(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=bs,Cs(n,"click",this.handler.click),this.options.preloadImage&&ks(Ts(n)));return this}},{key:"config",value:function(n){return n?(Ds(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var i="string"==typeof n?document.querySelector(n):n;if("IMG"===i.tagName){if(this.options.onBeforeOpen(i),this.target.init(i,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(i),ks(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Cs(document,"scroll",this.handler.scroll),Cs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Cs(window,"resize",this.handler.resizeWindow);var a=function n(){Cs(i,js,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Us(document,e.handler,!0),t(i)};return Cs(i,js,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=ys,this.overlay.fadeOut(),this.target.zoomOut(),Cs(document,"scroll",this.handler.scroll,!1),Cs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Cs(window,"resize",this.handler.resizeWindow,!1);var i=function i(){Cs(t,js,i,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Us(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Cs(t,js,i),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var a=function n(){Cs(r,js,n,!1),i(r)};return Cs(r,js,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=ws,this.target.move(n,e,t);var r=this.target.el,a=function n(){Cs(r,js,n,!1),i(r)};return Cs(r,js,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=ys,this.target.restoreOpenStyle();var i=function i(){Cs(t,js,i,!1),n.lock=!1,n.released=!0,e(t)};return Cs(t,js,i),this}}}]),n}();const qs=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),Vs=Number("500");class Gs{constructor(){this.instance=new Fs(qs)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=Vs){setTimeout(()=>this.update(n),e)}}var Js=[Ho,ns,is,as,gs,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new Gs,this.$vuepress.zooming.updateDelay()}}],Hs={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return Fo("layout",n),Ar.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Ys=t(6),Qs=Object(Ys.a)(Hs,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(Qs,"mixins",Js);const Ks=[{name:"v-465a10a3",path:"/wiki/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-465a10a3").then(t)}},{path:"/wiki/index.html",redirect:"/wiki/"},{path:"/00.NavBar/01.Wiki.html",redirect:"/wiki/"},{name:"v-7a9dff07",path:"/wiki/lean_in_c++/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-7a9dff07").then(t)}},{path:"/wiki/lean_in_c++/index.html",redirect:"/wiki/lean_in_c++/"},{path:"/01.Wiki/01.Lean in c++/00.ReadMe.html",redirect:"/wiki/lean_in_c++/"},{name:"v-ae8ce3d2",path:"/authoring/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-ae8ce3d2").then(t)}},{path:"/authoring/index.html",redirect:"/authoring/"},{path:"/00.NavBar/02.Authoring.html",redirect:"/authoring/"},{name:"v-18718c04",path:"/pages/8744f7/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-18718c04").then(t)}},{path:"/pages/8744f7/index.html",redirect:"/pages/8744f7/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/00.C++ Glimpse.html",redirect:"/pages/8744f7/"},{name:"v-16253573",path:"/pages/2b0a8f/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-16253573").then(t)}},{path:"/pages/2b0a8f/index.html",redirect:"/pages/2b0a8f/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/03.typename vs class.html",redirect:"/pages/2b0a8f/"},{name:"v-52de352b",path:"/pages/b9de04/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-52de352b").then(t)}},{path:"/pages/b9de04/index.html",redirect:"/pages/b9de04/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/04.const.html",redirect:"/pages/b9de04/"},{name:"v-602d1c42",path:"/pages/ab4daf/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-602d1c42").then(t)}},{path:"/pages/ab4daf/index.html",redirect:"/pages/ab4daf/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/02.typedef.html",redirect:"/pages/ab4daf/"},{name:"v-6a18abfa",path:"/pages/5bac8e/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-6a18abfa").then(t)}},{path:"/pages/5bac8e/index.html",redirect:"/pages/5bac8e/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/05.extern.html",redirect:"/pages/5bac8e/"},{name:"v-7d0fcd4a",path:"/pages/409de3/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-7d0fcd4a").then(t)}},{path:"/pages/409de3/index.html",redirect:"/pages/409de3/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/01.type cast.html",redirect:"/pages/409de3/"},{name:"v-9b512a1a",path:"/pages/c08a6e/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-9b512a1a").then(t)}},{path:"/pages/c08a6e/index.html",redirect:"/pages/c08a6e/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/06.pointer.html",redirect:"/pages/c08a6e/"},{name:"v-a31e7cfa",path:"/pages/9b131d/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-a31e7cfa").then(t)}},{path:"/pages/9b131d/index.html",redirect:"/pages/9b131d/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/07.static.html",redirect:"/pages/9b131d/"},{name:"v-adaed63a",path:"/pages/598385/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-adaed63a").then(t)}},{path:"/pages/598385/index.html",redirect:"/pages/598385/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/08.volatile.html",redirect:"/pages/598385/"},{name:"v-0eba4323",path:"/pages/91242f/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-0eba4323").then(t)}},{path:"/pages/91242f/index.html",redirect:"/pages/91242f/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/09.inline.html",redirect:"/pages/91242f/"},{name:"v-38c4d983",path:"/pages/efbaf4/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-38c4d983").then(t)}},{path:"/pages/efbaf4/index.html",redirect:"/pages/efbaf4/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/10.assert.html",redirect:"/pages/efbaf4/"},{name:"v-808e1b3a",path:"/pages/b4d0b6/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-808e1b3a").then(t)}},{path:"/pages/b4d0b6/index.html",redirect:"/pages/b4d0b6/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/11.void.html",redirect:"/pages/b4d0b6/"},{name:"v-19e58c3a",path:"/pages/fc5419/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-19e58c3a").then(t)}},{path:"/pages/fc5419/index.html",redirect:"/pages/fc5419/"},{path:"/01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/12.__global__.html",redirect:"/pages/fc5419/"},{name:"v-448f6e72",path:"/wiki/Performance_Engineering/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-448f6e72").then(t)}},{path:"/wiki/Performance_Engineering/index.html",redirect:"/wiki/Performance_Engineering/"},{path:"/01.Wiki/02.Performance Engineering/01.Perf.html",redirect:"/wiki/Performance_Engineering/"},{name:"v-acc65afa",path:"/pages/41a6c9/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-acc65afa").then(t)}},{path:"/pages/41a6c9/index.html",redirect:"/pages/41a6c9/"},{path:"/01.Wiki/10.Misc/01.Chrome.html",redirect:"/pages/41a6c9/"},{name:"v-3cdd7c23",path:"/pages/6f0fa2/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-3cdd7c23").then(t)}},{path:"/pages/6f0fa2/index.html",redirect:"/pages/6f0fa2/"},{path:"/01.Wiki/10.Misc/02.VsCode.html",redirect:"/pages/6f0fa2/"},{name:"v-28c8daa4",path:"/pages/f9e729/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-28c8daa4").then(t)}},{path:"/pages/f9e729/index.html",redirect:"/pages/f9e729/"},{path:"/01.Wiki/19.Reading Notes/01.Effective C++/01.习惯C++.html",redirect:"/pages/f9e729/"},{name:"v-1497abd7",path:"/pages/0d9870/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-1497abd7").then(t)}},{path:"/pages/0d9870/index.html",redirect:"/pages/0d9870/"},{path:"/01.Wiki/19.Reading Notes/01.Effective C++/02.构造_析构_运算符重载.html",redirect:"/pages/0d9870/"},{name:"v-e027eb68",path:"/pages/ad8b8b/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-e027eb68").then(t)}},{path:"/pages/ad8b8b/index.html",redirect:"/pages/ad8b8b/"},{path:"/01.Wiki/19.Reading Notes/01.Effective C++/03.资源管理.html",redirect:"/pages/ad8b8b/"},{name:"v-7b0d9a9e",path:"/pages/e85768/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-7b0d9a9e").then(t)}},{path:"/pages/e85768/index.html",redirect:"/pages/e85768/"},{path:"/01.Wiki/19.Reading Notes/01.Effective C++/04.设计与声明.html",redirect:"/pages/e85768/"},{name:"v-7dbd198c",path:"/pages/fb96c7/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-7dbd198c").then(t)}},{path:"/pages/fb96c7/index.html",redirect:"/pages/fb96c7/"},{path:"/01.Wiki/19.Reading Notes/01.Effective C++/05.实现.html",redirect:"/pages/fb96c7/"},{name:"v-249122e1",path:"/pages/61c62c/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-249122e1").then(t)}},{path:"/pages/61c62c/index.html",redirect:"/pages/61c62c/"},{path:"/01.Wiki/19.Reading Notes/01.Effective C++/07.模板.html",redirect:"/pages/61c62c/"},{name:"v-5687f1b4",path:"/pages/875a85/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-5687f1b4").then(t)}},{path:"/pages/875a85/index.html",redirect:"/pages/875a85/"},{path:"/01.Wiki/19.Reading Notes/01.Effective C++/08.定制new和delete.html",redirect:"/pages/875a85/"},{name:"v-06ae3d06",path:"/pages/589042/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-06ae3d06").then(t)}},{path:"/pages/589042/index.html",redirect:"/pages/589042/"},{path:"/01.Wiki/19.Reading Notes/01.Effective C++/09.杂项_Misc.html",redirect:"/pages/589042/"},{name:"v-7fefcb5b",path:"/pages/ce94a9/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-7fefcb5b").then(t)}},{path:"/pages/ce94a9/index.html",redirect:"/pages/ce94a9/"},{path:"/01.Wiki/19.Reading Notes/02.More Effective C++/01.基础议题.html",redirect:"/pages/ce94a9/"},{name:"v-18172e6c",path:"/pages/81fe36/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-18172e6c").then(t)}},{path:"/pages/81fe36/index.html",redirect:"/pages/81fe36/"},{path:"/01.Wiki/19.Reading Notes/01.Effective C++/06.继承与OOP.html",redirect:"/pages/81fe36/"},{name:"v-1cc12d3b",path:"/pages/225e98/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-1cc12d3b").then(t)}},{path:"/pages/225e98/index.html",redirect:"/pages/225e98/"},{path:"/01.Wiki/19.Reading Notes/02.More Effective C++/02.操作符.html",redirect:"/pages/225e98/"},{name:"v-2f694f79",path:"/pages/3e106f/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-2f694f79").then(t)}},{path:"/pages/3e106f/index.html",redirect:"/pages/3e106f/"},{path:"/01.Wiki/19.Reading Notes/02.More Effective C++/03.异常.html",redirect:"/pages/3e106f/"},{name:"v-64b006d2",path:"/pages/24653b/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-64b006d2").then(t)}},{path:"/pages/24653b/index.html",redirect:"/pages/24653b/"},{path:"/01.Wiki/19.Reading Notes/02.More Effective C++/04.性能.html",redirect:"/pages/24653b/"},{name:"v-4cf7131f",path:"/pages/b26674/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-4cf7131f").then(t)}},{path:"/pages/b26674/index.html",redirect:"/pages/b26674/"},{path:"/01.Wiki/19.Reading Notes/02.More Effective C++/05.技术.html",redirect:"/pages/b26674/"},{name:"v-3dcfaa6a",path:"/pages/b3853a/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-3dcfaa6a").then(t)}},{path:"/pages/b3853a/index.html",redirect:"/pages/b3853a/"},{path:"/01.Wiki/19.Reading Notes/02.More Effective C++/06.杂项.html",redirect:"/pages/b3853a/"},{name:"v-76d7a407",path:"/wiki/Reading_Notes/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-76d7a407").then(t)}},{path:"/wiki/Reading_Notes/index.html",redirect:"/wiki/Reading_Notes/"},{path:"/01.Wiki/19.Reading Notes/03.C++性能优化指南.html",redirect:"/wiki/Reading_Notes/"},{name:"v-04def3fa",path:"/archives/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-04def3fa").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-faf1db3a",path:"/categories/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-faf1db3a").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-b1c16cfa",path:"/tags/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-b1c16cfa").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-cda71308",path:"/pages/9b7dad/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-cda71308").then(t)}},{path:"/pages/9b7dad/index.html",redirect:"/pages/9b7dad/"},{path:"/_posts/Notes/编程议题.html",redirect:"/pages/9b7dad/"},{name:"v-1bf730e3",path:"/pages/cc9a5c/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-1bf730e3").then(t)}},{path:"/pages/cc9a5c/index.html",redirect:"/pages/cc9a5c/"},{path:"/_posts/Writing/WhyYouHave2Write.html",redirect:"/pages/cc9a5c/"},{name:"v-f6245f3a",path:"/pages/dcdff1/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-f6245f3a").then(t)}},{path:"/pages/dcdff1/index.html",redirect:"/pages/dcdff1/"},{path:"/_posts/Writing/thePowerOfTime.html",redirect:"/pages/dcdff1/"},{name:"v-e5b4aac8",path:"/",component:Qs,beforeEnter:(n,e,t)=>{Uo("Layout","v-e5b4aac8").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:Qs}],Zs={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/more.png"}],["meta",{name:"keywords",content:"optimization, analysis, profile, performance, latency, throughput, metrics, linux, cache, CPU, architecture"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"Wiki",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.Wiki",description:"Technical & Lab doc"}},title:"Wiki",date:"2020-03-11T21:50:53.000Z",permalink:"/wiki/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/00.NavBar/01.Wiki.html",relativePath:"00.NavBar/01.Wiki.md",key:"v-465a10a3",path:"/wiki/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/30, 23:47:28",lastUpdatedTimestamp:1656604048e3},{title:"Lean in C++",frontmatter:{pageClass:"notes",title:"Lean in C++",date:"2022-06-27T07:53:54.000Z",categories:["Wiki","C++"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/wiki/lean_in_c++/"},regularPath:"/01.Wiki/01.Lean%20in%20c++/00.ReadMe.html",relativePath:"01.Wiki/01.Lean in c++/00.ReadMe.md",key:"v-7a9dff07",path:"/wiki/lean_in_c++/",headersStr:null,content:"这其实是一个C++的常识合辑， 不得不说C++的学习给很多人都带来了挑战， 不同于其他知识的学习， C++的学习总是让人对这一块知识的边界望而生畏， 而在平时生活中， 我们对其他知识的学习， 其实多数时候内心都至少会知晓一个边界， 从这个边界往里走， 不断对边界内的知识进行分层， 分块， 解构， 一点一点地完善自己对知识的理解。\n\n但是C++仿佛一上来就把知识边界拉的十分分散， 在中国， 很多人学习编程都是从C语言， 汇编开始， 逐渐丰富到C++， 这导致越往后， 其实越感觉对底层知识边界的模糊。当边界清晰的时候， 人们往往容易建立起对一个知识掌握的信息， 而边界变得模糊的时候， 人们常常会望而生畏， 既无法规划出一个完美的学习策略， 也容易丧失信心。\n\nLean in 在这里表示一步一步加深理解的意思， 由于C++的知识边界模糊， 我希望采取一种渐进式加深理解的方式，而非直接在知识层面进行分层理解， 我们实际上需要的是在认知的早期阶段就构建出一种让自己有条不紊逐渐变强的策略， 而非对一事一物完美无缺的理解。这也是能够体现学习经验是否丰富的一个地方。既然在一开始就不能够或者就无法设置一个清晰的知识边界， 我们不妨先设立一个框架， 在一个三维立体的知识地图里面先抓住一个自己最容易抓住的把手， 然后从这个点出发， 不断在层次中进行水平或者垂直的移动， 来丰富自己已经掌握的知识结构；\n\n我们先从最基本的C/C++语法的关键字开始，从最小的代码片段需要注意些什么开始，这里主要是消灭在阅读代码的时候一些容易混淆的语法点，称之为Phase 0\n\n暂时计划Phase1可以是多个代码片段， 函数， 类和对象， 在构建一个大程序的时候， 一些让人傻傻分不清的概念。还有一些常规语法之外的编程技巧， 常规用法。例如前向声明， RTTI, CRTP，\n\n更进一步， 我们希望通过Phase2 和Phase 3 ， 能够了解到最核心的内容， 通过理清楚这些内容， 我们能够过渡到计算机的各个方面， 例如OS, compiler, network SW stack中， 以及Compute Arch， 理解软硬接结合之后是如何工作的，\n\n前面几个其实都是线性的关系， 到Phase3 其实就可以分叉， 会涉及到很多很多不同的方面里面去。 需要其他的很多领域知识， 并且要循环往复在不同的phase之间进行巩固对这些知识的理解，从而不断拓展和前进；\n\n关于如何划分不同的Level， 还在规划中，但是已经有了一个基本的结构",normalizedContent:"这其实是一个c++的常识合辑， 不得不说c++的学习给很多人都带来了挑战， 不同于其他知识的学习， c++的学习总是让人对这一块知识的边界望而生畏， 而在平时生活中， 我们对其他知识的学习， 其实多数时候内心都至少会知晓一个边界， 从这个边界往里走， 不断对边界内的知识进行分层， 分块， 解构， 一点一点地完善自己对知识的理解。\n\n但是c++仿佛一上来就把知识边界拉的十分分散， 在中国， 很多人学习编程都是从c语言， 汇编开始， 逐渐丰富到c++， 这导致越往后， 其实越感觉对底层知识边界的模糊。当边界清晰的时候， 人们往往容易建立起对一个知识掌握的信息， 而边界变得模糊的时候， 人们常常会望而生畏， 既无法规划出一个完美的学习策略， 也容易丧失信心。\n\nlean in 在这里表示一步一步加深理解的意思， 由于c++的知识边界模糊， 我希望采取一种渐进式加深理解的方式，而非直接在知识层面进行分层理解， 我们实际上需要的是在认知的早期阶段就构建出一种让自己有条不紊逐渐变强的策略， 而非对一事一物完美无缺的理解。这也是能够体现学习经验是否丰富的一个地方。既然在一开始就不能够或者就无法设置一个清晰的知识边界， 我们不妨先设立一个框架， 在一个三维立体的知识地图里面先抓住一个自己最容易抓住的把手， 然后从这个点出发， 不断在层次中进行水平或者垂直的移动， 来丰富自己已经掌握的知识结构；\n\n我们先从最基本的c/c++语法的关键字开始，从最小的代码片段需要注意些什么开始，这里主要是消灭在阅读代码的时候一些容易混淆的语法点，称之为phase 0\n\n暂时计划phase1可以是多个代码片段， 函数， 类和对象， 在构建一个大程序的时候， 一些让人傻傻分不清的概念。还有一些常规语法之外的编程技巧， 常规用法。例如前向声明， rtti, crtp，\n\n更进一步， 我们希望通过phase2 和phase 3 ， 能够了解到最核心的内容， 通过理清楚这些内容， 我们能够过渡到计算机的各个方面， 例如os, compiler, network sw stack中， 以及compute arch， 理解软硬接结合之后是如何工作的，\n\n前面几个其实都是线性的关系， 到phase3 其实就可以分叉， 会涉及到很多很多不同的方面里面去。 需要其他的很多领域知识， 并且要循环往复在不同的phase之间进行巩固对这些知识的理解，从而不断拓展和前进；\n\n关于如何划分不同的level， 还在规划中，但是已经有了一个基本的结构",charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"Authoring",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"02.Authoring",description:"some simple writings"}},title:"Authoring",date:"2020-03-11T21:50:54.000Z",permalink:"/authoring/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/00.NavBar/02.Authoring.html",relativePath:"00.NavBar/02.Authoring.md",key:"v-ae8ce3d2",path:"/authoring/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/30, 23:47:28",lastUpdatedTimestamp:1656604048e3},{title:"C++ Glimpse",frontmatter:{title:"C++ Glimpse",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/8744f7/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/00.C++%20Glimpse.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/00.C++ Glimpse.md",key:"v-18718c04",path:"/pages/8744f7/",headers:[{level:2,title:"关键字是最好的边界：C++ Keywords",slug:"关键字是最好的边界-c-keywords",normalizedTitle:"关键字是最好的边界：c++ keywords",charIndex:61},{level:2,title:"C++ Preprocess（预处理）",slug:"c-preprocess-预处理",normalizedTitle:"c++ preprocess（预处理）",charIndex:3364},{level:3,title:"conditionally ：#if #else #elif #ifdef #ifndef #endif #elifdef, #elifndef (since C++23)",slug:"conditionally-if-else-elif-ifdef-ifndef-endif-elifdef-elifndef-since-c-23",normalizedTitle:"conditionally ：#if #else #elif #ifdef #ifndef #endif #elifdef, #elifndef (since c++23)",charIndex:3858},{level:3,title:"replace：",slug:"replace",normalizedTitle:"replace：",charIndex:3953},{level:3,title:"Include",slug:"include",normalizedTitle:"include",charIndex:4344},{level:3,title:"error",slug:"error",normalizedTitle:"error",charIndex:3597},{level:3,title:"Implementation defined :   behavior control",slug:"implementation-defined-behavior-control",normalizedTitle:"implementation defined :   behavior control",charIndex:null},{level:3,title:"File name and line information",slug:"file-name-and-line-information",normalizedTitle:"file name and line information",charIndex:4844},{level:3,title:"其他一些预处理指令:  defined export (C++20) import (C++20) module (C++20)",slug:"其他一些预处理指令-defined-export-c-20-import-c-20-module-c-20",normalizedTitle:"其他一些预处理指令:  defined export (c++20) import (c++20) module (c++20)",charIndex:null},{level:2,title:"C++ Expression(表达式)",slug:"c-expression-表达式",normalizedTitle:"c++ expression(表达式)",charIndex:4968},{level:3,title:"Operators 运算符",slug:"operators-运算符",normalizedTitle:"operators 运算符",charIndex:4996},{level:3,title:"Primary expressions",slug:"primary-expressions",normalizedTitle:"primary expressions",charIndex:7478},{level:3,title:"Unevaluated expressions： typeid、sizeof、noexcept 和 decltype (C++11 起)",slug:"unevaluated-expressions-typeid、sizeof、noexcept-和-decltype-c-11-起",normalizedTitle:"unevaluated expressions： typeid、sizeof、noexcept 和 decltype (c++11 起)",charIndex:7878},{level:3,title:"Discarded-value expressions ：  void, volatile",slug:"discarded-value-expressions-void-volatile",normalizedTitle:"discarded-value expressions ：  void, volatile",charIndex:null},{level:2,title:"C++ Statement (语句)",slug:"c-statement-语句",normalizedTitle:"c++ statement (语句)",charIndex:8e3},{level:2,title:"C++ 11 新增关键字",slug:"c-11-新增关键字",normalizedTitle:"c++ 11 新增关键字",charIndex:8926},{level:2,title:"C++ 17 新增关键字",slug:"c-17-新增关键字",normalizedTitle:"c++ 17 新增关键字",charIndex:9170},{level:2,title:"C++ 20 新增关键字",slug:"c-20-新增关键字",normalizedTitle:"c++ 20 新增关键字",charIndex:9187},{level:2,title:"TM_TS (Transactional Memory Technical Specification)",slug:"tm-ts-transactional-memory-technical-specification",normalizedTitle:"tm_ts (transactional memory technical specification)",charIndex:9382},{level:3,title:"特殊含义的标识符",slug:"特殊含义的标识符",normalizedTitle:"特殊含义的标识符",charIndex:9569},{level:2,title:"C++ Websites for reference",slug:"c-websites-for-reference",normalizedTitle:"c++ websites for reference",charIndex:9757}],excerpt:"<p>关键字， 最基础的用法， 以及一些常用的参考网站， 以期可以能够对繁杂的内容确定边界， 日后可以有目标地不断填充</p>\n",headersStr:"关键字是最好的边界：C++ Keywords C++ Preprocess（预处理） conditionally ：#if #else #elif #ifdef #ifndef #endif #elifdef, #elifndef (since C++23) replace： Include error Implementation defined :   behavior control File name and line information 其他一些预处理指令:  defined export (C++20) import (C++20) module (C++20) C++ Expression(表达式) Operators 运算符 Primary expressions Unevaluated expressions： typeid、sizeof、noexcept 和 decltype (C++11 起) Discarded-value expressions ：  void, volatile C++ Statement (语句) C++ 11 新增关键字 C++ 17 新增关键字 C++ 20 新增关键字 TM_TS (Transactional Memory Technical Specification) 特殊含义的标识符 C++ Websites for reference",content:'关键字， 最基础的用法， 以及一些常用的参考网站， 以期可以能够对繁杂的内容确定边界， 日后可以有目标地不断填充\n\n\n# 关键字是最好的边界：C++ Keywords\n\n一些常见的C++关键字\n\nKEYWORDS                     DESCRIPTION   KEYWORDS                 DESCRIPTION\nand                                        auto (1)                 \nbool                                       break                    \ncase                                       catch                    \nchar                                       char8_t (since C++20)    \nchar16_t (since C++11)                     char32_t (since C++11)   \nclass (1)                                  const                    \nconstexpr (since C++11)                    const_cast               \ncontinue                                   decltype (since C++11)   \ndefault (1)                                delete (1)               \ndo                                         double                   \ndynamic_cast                               else                     \nenum                                       explicit                 \nextern(1)                                  false                    \nfloat                                      for                      \nfriend                                     goto                     \nif                                         inline (1)               \nint                                        long                     \nnamespace                                  new                      \nnoexcept (since C++11)                     not                      \nnullptr (since C++11)                      operator                 \nor                                         or_eq                    \nprivate                                    protected                \npublic                                     reinterpret_cast         \nreturn                                     short                    \nsigned                                     sizeof (1)               \nstatic                                     static_cast              \nstruct (1)                                 switch                   \ntemplate                                   this                     \nthread_local (since C++11)                 throw                    \ntrue                                       try                      \ntypedef                                    typeid                   \ntypename                                   union                    \nunsigned                                   using (1)                \nvirtual                                    void                     \nvolatile                                   wchar_t                  \nwhile                                      xor                      \nxor_eq                                                              \n\n一些不那么常见的关键字：\n\nKEYWORDS                  DESCRIPTION   KEYWORDS                  DESCRIPTION\nalignas (since C++11)                   alignof (since C++11)     \nand_eq                                  asm                       \natomic_cancel (TM TS)                   atomic_commit (TM TS)     \natomic_noexcept (TM TS)                 bitand                    \nbitor                                   compl                     \nconcept (since C++20)                   consteval (since C++20)   \nconstinit (since C++20)                 co_await (since C++20)    \nco_return (since C++20)                 co_yield (since C++20)    \n\n\n# C++ Preprocess（预处理）\n\n一些预处理指令, 由C++ 预处理器（preprocessor）进行处理；\n\nIF      IFDEF    INCLUDE   DEFINED                             EXPORT (C++20)\nelif    ifndef   line      __has_include (since C++17)         import (C++20)\nelse    define   error     __has_cpp_attribute (since C++20)   module (C++20)\nendif   undef    pragma                                        \n\nfollowing tokens are recognized by the preprocessor outside the context of a preprocessor directive:\n\n * _Pragma (since C++11)\n\n\n 1. # conditionally ：#if #else #elif #ifdef #ifndef #endif #elifdef, #elifndef (since C++23)\n\n\n 2. # replace：\n    \n    * #define #undef\n    * # : 在运行形参替换的基础上以引号包围，实际上创建一个字符串字面量。\n    * ##: 在运行形参替换的基础上将结果进行拼接。\n    * 其他的一些Macro:\n      * _FILE_ 展开成当前文件名，作为字符串字面量，可用 #line 指令更改(宏常量)\n      * __LINE: 展开成源文件行号，整数常量，可用 #line 指令更改(宏常量)\n      * __DATE: 展开成翻译日期，形式为 "Mmm dd yyyy" 的字符串。如果月中日期数小于 10 则 "dd" 的首字符为空格。月份名如同以 std::asctime() 生成(宏常量)\n      * _TIME_: 展开成翻译时间，形式为 "hh:mm:ss" 的字符串字面量(宏常量)\n\n\n 3. # Include\n    \n    1. #include\n    2. __has_include (C++17 起) 提供的可以判断是否include这个h文件\n    3. __has_cpp_attribute (C++20 起)\n\n\n 4. # error\n    \n    1. #error\n\n\n 5. # Implementation defined : behavior control\n    \n    1. #pragma\n    2. _Pragma(C++11 起)\n    3. #pragma STDC\n    4. #pragma once: 编译器只对其分析一次，即使它在同一源文件中（直接或间接）被包含了多次也是如此。\n    \n    类似的标准方式:\n\n#ifndef LIBRARY_FILENAME_H\n#define LIBRARY_FILENAME_H\n// 头文件的内容\n#endif /* LIBRARY_FILENAME_H */\n#pragma pack: 控制后续定义的类和union的最大对齐方式;\n\n\n1\n2\n3\n4\n5\n\n\n\n 6. # File name and line information\n    \n    * #line\n\n\n 7. # 其他一些预处理指令: defined export (C++20) import (C++20) module (C++20)\n\n\n# C++ Expression(表达式)\n\n\n 1. # Operators 运算符\n    \n    Common operators\n    \n    ASSIGNMENT   INCREMENT DECREMENT   ARITHMETIC   LOGICAL   COMPARISON   MEMBER ACCESS\n    a = b        ++a                   +a           !a        a == b       a[b]\n    a += b       --a                   -a           a && b    a != b       *a\n    a -= b       a++                   a + b        a || b    a < b        &a\n    a *= b       a--                   a - b                  a > b        a->b\n    a /= b                             a * b                  a <= b       a.b\n    a %= b                             a / b                  a >= b       a->*b\n    a &= b                             a % b                  a <=> b      a.*b\n    a |= b                             ~a\n    a ^= b                             a & b\n    a <<= b                            a | b\n    a >>= b                            a ^ b\n                                       a << b\n                                       a >> b\n    \n    SPECIAL OPERATORS\n    static_cast converts one type to another related type\n    dynamic_cast converts within inheritance hierarchies\n    const_cast adds or removes cv qualifiers\n    reinterpret_cast converts type to unrelated type\n    C-style cast converts one type to another by a mix of\n    static_cast, const_cast, and reinterpret_cast\n    new creates objects with dynamic storage duration\n    delete destructs objects previously created by the new\n    expression and releases obtained memory area sizeof queries\n    the size of a type\n    sizeof... queries the size of a parameter pack (since C++11)\n    typeid queries the type information of a type\n    noexcept checks if an expression can throw an exception\n    (since C++11)\n    alignof queries alignment requirements of a type (since\n    C++11)\n\n一些可以用别名代替的运算符：\n\nPRIMARY   ALTERNATIVE   含义\n&&        and           逻辑与\n||        or            逻辑或\n!         not           逻辑非\n&         bitand        按位与\n|         bitor         按位或\n&=        and_eq        按位与后赋值\n|=        or_eq         按位或后赋值\n!=        not_eq        按位取反后赋值\n^         xor           按位异或\n^=        xor_eq        按位异或后赋值\n~         compl         按位取反(Compliment)\n\nOperator overloading : operator\n\n 1. Conversions\n    1. const_cast\n    2. static_cast\n    3. dynamic_cast\n    4. reinterpret_cast\n    5. Other form of conversions\n 2. Memory allocation\n    1. new\n    2. delete(1)\n 3. Other\n    1. 常量表达式： constexpr (C++11 起)\n    2. sizeof(1)\n    3. alignof （alignas)\n    4. typeid\n    5. throw\n\n\n# Primary expressions\n\n 1. 字面量\n\n 2. CHAR           WCHAR_T           CHAR16_T (C++11 起)     CHAR32_T (C++11 起)   CHAR8_T (C++20 起)\n    float          double            long                                        \n    const char[]   const wchar_t[]   Bool （true or false)   nullptr              Std::size_t\n    \n    LAMBDA 表达式     (C++11 起)\n    折叠表达式          (C++17 起)\n    requires 表达式   (C++20 起)\n\n\n# Unevaluated expressions： typeid、sizeof、noexcept 和 decltype (C++11 起)\n\n\n# Discarded-value expressions ： void, volatile\n\n\n# C++ Statement (语句)\n\n 1.  标签：\n     \n     * Goto\n     * Switch语句中的case标签\n     * switch语句中default标签\n\n 2.  表达式语句（expression statement）；\n\n 3.  复合语句（compound statement）；\n\n 4.  选择语句（selection statement）；\n\n 5.  * If.. Else: if\n     * switch ... case ...\n     * If consteval\n\n 6.  循环语句（iteration statement）；\n\n 7.  * while\n     * do-while\n     * For …\n     * for–range-for (C++11)\n\n 8.  跳转语句（jump statement）；\n\n 9.  * Break\n     * Continue\n     * Return …\n     * Return\n     * goto\n     * continue – break – goto – return\n\n 10. 声明语句（declaration statement）；\n\n 11. try 块: Try … catch …\n\n 12. atomic 与 synchronized 块(TM TS)。 atomic 与 synchronized 块用来实现事务性内存。 synchronized and atomic (TM TS)\n\nSYNCHRONIZED 复合语句      (1)   (TM TS)\natomic_noexcept 复合语句   (2)   (TM TS)\natomic_cancel 复合语句     (3)   (TM TS)\natomic_commit 复合语句     (4)   (TM TS)\n\n(1) synchronized 块，与所有 synchronized 块在一个全序中执行； (2) 在发生异常时中止的 atomic 块； (3) 在发生异常时回滚的 atomic 块；\n\n\n# C++ 11 新增关键字\n\n * lignas (C++11 起)\n * alignof (C++11 起)\n * char16_t (C++11 起)\n * char32_t (C++11 起)\n * constexpr (C++11 起)\n * decltype (C++11 起)\n * noexcept (C++11 起)\n * nullptr (C++11 起)\n * static_assert (C++11 起)\n * thread_local (C++11 起)\n\n\n# C++ 17 新增关键字\n\n\n# C++ 20 新增关键字\n\n * char8_t (C++20 起)\n * concept (C++20 起)\n * consteval (C++20 起)\n * constinit (C++20 起)\n * co_await (C++20 起)\n * co_return (C++20 起)\n * co_yield (C++20 起)\n * requires (C++20 起)\n\n\n# TM_TS (Transactional Memory Technical Specification)\n\n * atomic_cancel (TM TS)\n * atomic_commit (TM TS)\n * atomic_noexcept (TM TS)\n * reflexpr (reflection TS)\n * synchronized (TM TS)\n\n\n# 特殊含义的标识符\n\n它们可用作对象或函数的名字，但在某些语境拥有特殊含义: (module 与 import 指令是预处理指令) override (C++11) final (C++11) import (C++20) module (C++20) transaction_safe (TM TS) transaction_safe_dynamic (TM TS)\n\n\n# C++ Websites for reference\n\n * C++ 标准基金会的官方网站: https://isocpp.org/\n   \n\n * http://www.cplusplus.com/\n   \n\n * https://en.cppreference.com/ 或者中文版 https://zh.cppreference.com/, 一些专用名词可以方便对照;\n   \n\n * C++ 标准委员会的文档列表: https://open-std.org/JTC1/SC22/WG21/docs/papers/\n   \n\n * 一些常用的额标准, 包括POSIX, C, C++: https://open-std.org/\n   ',normalizedContent:'关键字， 最基础的用法， 以及一些常用的参考网站， 以期可以能够对繁杂的内容确定边界， 日后可以有目标地不断填充\n\n\n# 关键字是最好的边界：c++ keywords\n\n一些常见的c++关键字\n\nkeywords                     description   keywords                 description\nand                                        auto (1)                 \nbool                                       break                    \ncase                                       catch                    \nchar                                       char8_t (since c++20)    \nchar16_t (since c++11)                     char32_t (since c++11)   \nclass (1)                                  const                    \nconstexpr (since c++11)                    const_cast               \ncontinue                                   decltype (since c++11)   \ndefault (1)                                delete (1)               \ndo                                         double                   \ndynamic_cast                               else                     \nenum                                       explicit                 \nextern(1)                                  false                    \nfloat                                      for                      \nfriend                                     goto                     \nif                                         inline (1)               \nint                                        long                     \nnamespace                                  new                      \nnoexcept (since c++11)                     not                      \nnullptr (since c++11)                      operator                 \nor                                         or_eq                    \nprivate                                    protected                \npublic                                     reinterpret_cast         \nreturn                                     short                    \nsigned                                     sizeof (1)               \nstatic                                     static_cast              \nstruct (1)                                 switch                   \ntemplate                                   this                     \nthread_local (since c++11)                 throw                    \ntrue                                       try                      \ntypedef                                    typeid                   \ntypename                                   union                    \nunsigned                                   using (1)                \nvirtual                                    void                     \nvolatile                                   wchar_t                  \nwhile                                      xor                      \nxor_eq                                                              \n\n一些不那么常见的关键字：\n\nkeywords                  description   keywords                  description\nalignas (since c++11)                   alignof (since c++11)     \nand_eq                                  asm                       \natomic_cancel (tm ts)                   atomic_commit (tm ts)     \natomic_noexcept (tm ts)                 bitand                    \nbitor                                   compl                     \nconcept (since c++20)                   consteval (since c++20)   \nconstinit (since c++20)                 co_await (since c++20)    \nco_return (since c++20)                 co_yield (since c++20)    \n\n\n# c++ preprocess（预处理）\n\n一些预处理指令, 由c++ 预处理器（preprocessor）进行处理；\n\nif      ifdef    include   defined                             export (c++20)\nelif    ifndef   line      __has_include (since c++17)         import (c++20)\nelse    define   error     __has_cpp_attribute (since c++20)   module (c++20)\nendif   undef    pragma                                        \n\nfollowing tokens are recognized by the preprocessor outside the context of a preprocessor directive:\n\n * _pragma (since c++11)\n\n\n 1. # conditionally ：#if #else #elif #ifdef #ifndef #endif #elifdef, #elifndef (since c++23)\n\n\n 2. # replace：\n    \n    * #define #undef\n    * # : 在运行形参替换的基础上以引号包围，实际上创建一个字符串字面量。\n    * ##: 在运行形参替换的基础上将结果进行拼接。\n    * 其他的一些macro:\n      * _file_ 展开成当前文件名，作为字符串字面量，可用 #line 指令更改(宏常量)\n      * __line: 展开成源文件行号，整数常量，可用 #line 指令更改(宏常量)\n      * __date: 展开成翻译日期，形式为 "mmm dd yyyy" 的字符串。如果月中日期数小于 10 则 "dd" 的首字符为空格。月份名如同以 std::asctime() 生成(宏常量)\n      * _time_: 展开成翻译时间，形式为 "hh:mm:ss" 的字符串字面量(宏常量)\n\n\n 3. # include\n    \n    1. #include\n    2. __has_include (c++17 起) 提供的可以判断是否include这个h文件\n    3. __has_cpp_attribute (c++20 起)\n\n\n 4. # error\n    \n    1. #error\n\n\n 5. # implementation defined : behavior control\n    \n    1. #pragma\n    2. _pragma(c++11 起)\n    3. #pragma stdc\n    4. #pragma once: 编译器只对其分析一次，即使它在同一源文件中（直接或间接）被包含了多次也是如此。\n    \n    类似的标准方式:\n\n#ifndef library_filename_h\n#define library_filename_h\n// 头文件的内容\n#endif /* library_filename_h */\n#pragma pack: 控制后续定义的类和union的最大对齐方式;\n\n\n1\n2\n3\n4\n5\n\n\n\n 6. # file name and line information\n    \n    * #line\n\n\n 7. # 其他一些预处理指令: defined export (c++20) import (c++20) module (c++20)\n\n\n# c++ expression(表达式)\n\n\n 1. # operators 运算符\n    \n    common operators\n    \n    assignment   increment decrement   arithmetic   logical   comparison   member access\n    a = b        ++a                   +a           !a        a == b       a[b]\n    a += b       --a                   -a           a && b    a != b       *a\n    a -= b       a++                   a + b        a || b    a < b        &a\n    a *= b       a--                   a - b                  a > b        a->b\n    a /= b                             a * b                  a <= b       a.b\n    a %= b                             a / b                  a >= b       a->*b\n    a &= b                             a % b                  a <=> b      a.*b\n    a |= b                             ~a\n    a ^= b                             a & b\n    a <<= b                            a | b\n    a >>= b                            a ^ b\n                                       a << b\n                                       a >> b\n    \n    special operators\n    static_cast converts one type to another related type\n    dynamic_cast converts within inheritance hierarchies\n    const_cast adds or removes cv qualifiers\n    reinterpret_cast converts type to unrelated type\n    c-style cast converts one type to another by a mix of\n    static_cast, const_cast, and reinterpret_cast\n    new creates objects with dynamic storage duration\n    delete destructs objects previously created by the new\n    expression and releases obtained memory area sizeof queries\n    the size of a type\n    sizeof... queries the size of a parameter pack (since c++11)\n    typeid queries the type information of a type\n    noexcept checks if an expression can throw an exception\n    (since c++11)\n    alignof queries alignment requirements of a type (since\n    c++11)\n\n一些可以用别名代替的运算符：\n\nprimary   alternative   含义\n&&        and           逻辑与\n||        or            逻辑或\n!         not           逻辑非\n&         bitand        按位与\n|         bitor         按位或\n&=        and_eq        按位与后赋值\n|=        or_eq         按位或后赋值\n!=        not_eq        按位取反后赋值\n^         xor           按位异或\n^=        xor_eq        按位异或后赋值\n~         compl         按位取反(compliment)\n\noperator overloading : operator\n\n 1. conversions\n    1. const_cast\n    2. static_cast\n    3. dynamic_cast\n    4. reinterpret_cast\n    5. other form of conversions\n 2. memory allocation\n    1. new\n    2. delete(1)\n 3. other\n    1. 常量表达式： constexpr (c++11 起)\n    2. sizeof(1)\n    3. alignof （alignas)\n    4. typeid\n    5. throw\n\n\n# primary expressions\n\n 1. 字面量\n\n 2. char           wchar_t           char16_t (c++11 起)     char32_t (c++11 起)   char8_t (c++20 起)\n    float          double            long                                        \n    const char[]   const wchar_t[]   bool （true or false)   nullptr              std::size_t\n    \n    lambda 表达式     (c++11 起)\n    折叠表达式          (c++17 起)\n    requires 表达式   (c++20 起)\n\n\n# unevaluated expressions： typeid、sizeof、noexcept 和 decltype (c++11 起)\n\n\n# discarded-value expressions ： void, volatile\n\n\n# c++ statement (语句)\n\n 1.  标签：\n     \n     * goto\n     * switch语句中的case标签\n     * switch语句中default标签\n\n 2.  表达式语句（expression statement）；\n\n 3.  复合语句（compound statement）；\n\n 4.  选择语句（selection statement）；\n\n 5.  * if.. else: if\n     * switch ... case ...\n     * if consteval\n\n 6.  循环语句（iteration statement）；\n\n 7.  * while\n     * do-while\n     * for …\n     * for–range-for (c++11)\n\n 8.  跳转语句（jump statement）；\n\n 9.  * break\n     * continue\n     * return …\n     * return\n     * goto\n     * continue – break – goto – return\n\n 10. 声明语句（declaration statement）；\n\n 11. try 块: try … catch …\n\n 12. atomic 与 synchronized 块(tm ts)。 atomic 与 synchronized 块用来实现事务性内存。 synchronized and atomic (tm ts)\n\nsynchronized 复合语句      (1)   (tm ts)\natomic_noexcept 复合语句   (2)   (tm ts)\natomic_cancel 复合语句     (3)   (tm ts)\natomic_commit 复合语句     (4)   (tm ts)\n\n(1) synchronized 块，与所有 synchronized 块在一个全序中执行； (2) 在发生异常时中止的 atomic 块； (3) 在发生异常时回滚的 atomic 块；\n\n\n# c++ 11 新增关键字\n\n * lignas (c++11 起)\n * alignof (c++11 起)\n * char16_t (c++11 起)\n * char32_t (c++11 起)\n * constexpr (c++11 起)\n * decltype (c++11 起)\n * noexcept (c++11 起)\n * nullptr (c++11 起)\n * static_assert (c++11 起)\n * thread_local (c++11 起)\n\n\n# c++ 17 新增关键字\n\n\n# c++ 20 新增关键字\n\n * char8_t (c++20 起)\n * concept (c++20 起)\n * consteval (c++20 起)\n * constinit (c++20 起)\n * co_await (c++20 起)\n * co_return (c++20 起)\n * co_yield (c++20 起)\n * requires (c++20 起)\n\n\n# tm_ts (transactional memory technical specification)\n\n * atomic_cancel (tm ts)\n * atomic_commit (tm ts)\n * atomic_noexcept (tm ts)\n * reflexpr (reflection ts)\n * synchronized (tm ts)\n\n\n# 特殊含义的标识符\n\n它们可用作对象或函数的名字，但在某些语境拥有特殊含义: (module 与 import 指令是预处理指令) override (c++11) final (c++11) import (c++20) module (c++20) transaction_safe (tm ts) transaction_safe_dynamic (tm ts)\n\n\n# c++ websites for reference\n\n * c++ 标准基金会的官方网站: https://isocpp.org/\n   \n\n * http://www.cplusplus.com/\n   \n\n * https://en.cppreference.com/ 或者中文版 https://zh.cppreference.com/, 一些专用名词可以方便对照;\n   \n\n * c++ 标准委员会的文档列表: https://open-std.org/jtc1/sc22/wg21/docs/papers/\n   \n\n * 一些常用的额标准, 包括posix, c, c++: https://open-std.org/\n   ',charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"class vs. typename",frontmatter:{title:"class vs. typename",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/2b0a8f/"},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/03.typename%20vs%20class.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/03.typename vs class.md",key:"v-16253573",path:"/pages/2b0a8f/",headers:[{level:2,title:"1.  共同点",slug:"_1-共同点",normalizedTitle:"1.  共同点",charIndex:null},{level:2,title:"2.   typename 独有的功能",slug:"_2-typename-独有的功能",normalizedTitle:"2.   typename 独有的功能",charIndex:null},{level:2,title:"3. class 独有的功能",slug:"_3-class-独有的功能",normalizedTitle:"3. class 独有的功能",charIndex:1382}],excerpt:"<p>在class template/function template 的声明中， 既可以使用class也可以使用typename来对类型T进行表示， 所以他们有什么区别呢？</p>\n",headersStr:"1.  共同点 2.   typename 独有的功能 3. class 独有的功能",content:"在class template/function template 的声明中， 既可以使用class也可以使用typename来对类型T进行表示， 所以他们有什么区别呢？\n\n\n# 1. 共同点\n\n在定义类模板或者函数模板时，typename 和 class 关键字都可以用于指定模板参数中的类型。也就是说，以下两种用法是完全等价的。这在大多数文章中都有提到。\n\ntemplate<typename T> /* class or function declaration */;\ntemplate<class T>  /* class or function declaration */;\n\n\n1\n2\n\n\nStan Lippman曾在其博客中表示，最早 Stroustrup 使用 class 来声明模板参数列表中的类型是为了避免增加不必要的关键字；后来标准委员会认为这样混用可能造成概念上的混淆才加上了 typename 关键字。\n\n\n# 2. typename 独有的功能\n\n由于 C++ 允许在类内定义类型别名，且其使用方法与通过类型名访问类成员的方法相同。故而，在类定义不可知的时候，编译器无法知晓类似 Type::foo 的写法具体指的是一个类型还是类内成员。这种情况下变量的类型发生了嵌套依赖类型(nested depended name)\n\n在下面的两段代码中，类模板 Bar 的原意是使用类 Foo 实例化，而后引用其中的 bar_type 定义名为 bar 的类内成员。然而，就 T::bar_type 而言，编译器在编译期无法确定它究竟是不是一个类型。此时就需要 typename 关键字来辅助编译器的判断。typename 的作用就是告诉 c++ 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有 typename，编译器没有任何办法知道 T::LengthType 是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。\n\nEXP 1:\n\nclass Foo {\n public:\n typedef int bar_type;\n};\n \ntemplate<typename T>\nclass Bar {\n T::bar_type bar; // Wrong !\n typename T::bar_type bar; // Right !\n}; \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nEXP 2：\n\nclass MyArray { \n    public：\n    typedef int LengthType;\n    ...\n}\n\ntemplate<class T>\nvoid MyMethod( T myarr ) { \n    typedef typename T::LengthType LengthType; \n    LengthType length = myarr.GetLength; \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这是常规的情形， <u>要注意的是，对于在编译期能够判断类型的场景，例如在上面例子中直接使用 Foo::bar_type 时，使用冗余的 typename 却会报错。</u>\n\n\n# 3. class 独有的功能\n\nclass 关键字最众所周知的功能是声明或定义一个类。这当然是其相对 typename 的一个独有功能。为了完整性，这里也列出。除此之外，在模板的使用中，class 关键字也有其特有的功能。而这是绝大多数文章不会提及的。\n\nC++ 的标准模板库中有名为 std::stack 的容器适配器，它能适配许多容器作为底层，实现栈的功能。其声明为\n\ntemplate <typename T, typename Containter = std::deque<T> >\nclass stack;\n\n\n1\n2\n\n\n因此，在使用中，我们可以使用 std::stack<int> 来声明一个以 std::deque<int> 保存整型变量的栈；也可以使用 std::stack<int, std::vector<int> > 来声明一个以 std::vector<int> 保存整型变量的栈。\n\n是否有可能以类似 Stack<int, std::vector> 的形式，来达到同样的目的？\n\n所以我们需要有类似这样的声明：\n\ntemplate <typename T,\n  template <typename E, typename = std::allocater<E> > class Container = std::deque>\nclass Stack;\n\n\n1\n2\n3\n\n\n由于 Container 必须是一个容器类模板，所以，如果不适用具体的模板参数实例化，就必须将其声明为一个类模板。故此，Container 之前需要保留标准库中容器类模板的模板参数。注意此处使用了标准库提供的内存分配器。\n\n此处 class 特有的功能，体现在 class Container 之处。此处虽然是在声明 Stack 这个类模板，但是这里的 class 不能替换为 typename；否则编译器会报错。\n\n不过，在 C++17标准中，这样的情况也允许使用 typename 了。参见此处。",normalizedContent:"在class template/function template 的声明中， 既可以使用class也可以使用typename来对类型t进行表示， 所以他们有什么区别呢？\n\n\n# 1. 共同点\n\n在定义类模板或者函数模板时，typename 和 class 关键字都可以用于指定模板参数中的类型。也就是说，以下两种用法是完全等价的。这在大多数文章中都有提到。\n\ntemplate<typename t> /* class or function declaration */;\ntemplate<class t>  /* class or function declaration */;\n\n\n1\n2\n\n\nstan lippman曾在其博客中表示，最早 stroustrup 使用 class 来声明模板参数列表中的类型是为了避免增加不必要的关键字；后来标准委员会认为这样混用可能造成概念上的混淆才加上了 typename 关键字。\n\n\n# 2. typename 独有的功能\n\n由于 c++ 允许在类内定义类型别名，且其使用方法与通过类型名访问类成员的方法相同。故而，在类定义不可知的时候，编译器无法知晓类似 type::foo 的写法具体指的是一个类型还是类内成员。这种情况下变量的类型发生了嵌套依赖类型(nested depended name)\n\n在下面的两段代码中，类模板 bar 的原意是使用类 foo 实例化，而后引用其中的 bar_type 定义名为 bar 的类内成员。然而，就 t::bar_type 而言，编译器在编译期无法确定它究竟是不是一个类型。此时就需要 typename 关键字来辅助编译器的判断。typename 的作用就是告诉 c++ 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有 typename，编译器没有任何办法知道 t::lengthtype 是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。\n\nexp 1:\n\nclass foo {\n public:\n typedef int bar_type;\n};\n \ntemplate<typename t>\nclass bar {\n t::bar_type bar; // wrong !\n typename t::bar_type bar; // right !\n}; \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nexp 2：\n\nclass myarray { \n    public：\n    typedef int lengthtype;\n    ...\n}\n\ntemplate<class t>\nvoid mymethod( t myarr ) { \n    typedef typename t::lengthtype lengthtype; \n    lengthtype length = myarr.getlength; \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这是常规的情形， <u>要注意的是，对于在编译期能够判断类型的场景，例如在上面例子中直接使用 foo::bar_type 时，使用冗余的 typename 却会报错。</u>\n\n\n# 3. class 独有的功能\n\nclass 关键字最众所周知的功能是声明或定义一个类。这当然是其相对 typename 的一个独有功能。为了完整性，这里也列出。除此之外，在模板的使用中，class 关键字也有其特有的功能。而这是绝大多数文章不会提及的。\n\nc++ 的标准模板库中有名为 std::stack 的容器适配器，它能适配许多容器作为底层，实现栈的功能。其声明为\n\ntemplate <typename t, typename containter = std::deque<t> >\nclass stack;\n\n\n1\n2\n\n\n因此，在使用中，我们可以使用 std::stack<int> 来声明一个以 std::deque<int> 保存整型变量的栈；也可以使用 std::stack<int, std::vector<int> > 来声明一个以 std::vector<int> 保存整型变量的栈。\n\n是否有可能以类似 stack<int, std::vector> 的形式，来达到同样的目的？\n\n所以我们需要有类似这样的声明：\n\ntemplate <typename t,\n  template <typename e, typename = std::allocater<e> > class container = std::deque>\nclass stack;\n\n\n1\n2\n3\n\n\n由于 container 必须是一个容器类模板，所以，如果不适用具体的模板参数实例化，就必须将其声明为一个类模板。故此，container 之前需要保留标准库中容器类模板的模板参数。注意此处使用了标准库提供的内存分配器。\n\n此处 class 特有的功能，体现在 class container 之处。此处虽然是在声明 stack 这个类模板，但是这里的 class 不能替换为 typename；否则编译器会报错。\n\n不过，在 c++17标准中，这样的情况也允许使用 typename 了。参见此处。",charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"const",frontmatter:{title:"const",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/b9de04/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/04.const.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/04.const.md",key:"v-52de352b",path:"/pages/b9de04/",headers:[{level:2,title:"const修饰一般变量",slug:"const修饰一般变量",normalizedTitle:"const修饰一般变量",charIndex:20},{level:2,title:"const修饰指针",slug:"const修饰指针",normalizedTitle:"const修饰指针",charIndex:570},{level:2,title:"const修饰引用",slug:"const修饰引用",normalizedTitle:"const修饰引用",charIndex:949},{level:2,title:"const修饰函数参数",slug:"const修饰函数参数",normalizedTitle:"const修饰函数参数",charIndex:1228},{level:2,title:"const修饰函数返回值",slug:"const修饰函数返回值",normalizedTitle:"const修饰函数返回值",charIndex:1548},{level:2,title:"const修饰类成员变量",slug:"const修饰类成员变量",normalizedTitle:"const修饰类成员变量",charIndex:2439},{level:2,title:"const修饰类成员函数",slug:"const修饰类成员函数",normalizedTitle:"const修饰类成员函数",charIndex:2713},{level:2,title:"const修饰类常量对象",slug:"const修饰类常量对象",normalizedTitle:"const修饰类常量对象",charIndex:3999},{level:2,title:"const和#define的区别",slug:"const和-define的区别",normalizedTitle:"const和#define的区别",charIndex:4413},{level:2,title:"使用const的一些建议",slug:"使用const的一些建议",normalizedTitle:"使用const的一些建议",charIndex:4663}],excerpt:"<p>一些const关键字常见的情况</p>\n",headersStr:"const修饰一般变量 const修饰指针 const修饰引用 const修饰函数参数 const修饰函数返回值 const修饰类成员变量 const修饰类成员函数 const修饰类常量对象 const和#define的区别 使用const的一些建议",content:'一些const关键字常见的情况\n\n\n# const修饰一般变量\n\nconst int a = 7; \nint b = a; // 正确\na = 8;    // 错误，不能改\n\n\n1\n2\n3\n\n\n即使用指针修改也是不可以的：\n\n#include<iostream>\nusing namespace std; \nint main(void)\n{\n    const int  a = 7;\n    int  *p = (int*)&a;\n    *p = 8;\n    cout<<a;  // 这里仍然输出a=7\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果需要修改， 可以通过用volatile来修饰const，\n\n#include<iostream>\nusing namespace std;\nint main(void)\n{\n    volatile const int  a = 7;\n    int  *p = (int*)&a;\n    *p = 8;\n    cout<<a; // 这里输出a=8\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# const修饰指针\n\nConst 在指针的不同位置， 代表的含义也不一样， C++ primer里面会分为顶层const和底层const， 顶层const指指针本身是个const， 底层const指指针所指的对象是个const：\n\nint* const x  = &y；                 //顶层const: const指针 --\x3e 指针指向的地址不能做修改\nconst int* x = &y；                  //底层const: const对象 --\x3e 变量的指向内容不能做修改, \n    \t\t\t\t\t\t\t  \t// y为一个const变量， 或者一个常规变量提升为一个const变量\nconst int* const x  = &y；           //Both两者都不能做修改\n\n\n1\n2\n3\n4\n\n\n\n# const修饰引用\n\nconst引用就是指向const对象的引用，普通变量可以绑定到const 引用, 但是const变量不可以绑定到普通的引用上\n\nint var1 = 1, var2 = 2;\nint &a = 0; // 一般引用无法绑定到字面值常量\nconst int &b = 0; //const引用可以绑定字面常量值\nint &c = var1 + var2; //错误，左值引用不可绑定右值, var1+var2为右值\nconst int &d = var1 + var2; //const引用可以绑定右值\n\n\n1\n2\n3\n4\n5\n\n\n\n# const修饰函数参数\n\n传入const变量，一般这种情况不需要 const 修饰，因为函数会自动产生临时变量复制实参值。\n\n传入const指针和const引用， 可以防止传入引用或指针改变原来的实参值\n\n#include <iostream>\nusing namespace std;\n\nvoid func(const int &a){\n    int &b = a;\n    b = 10;\n}\n\nint main(){\n    int a = 0;\n    func(a);\n    cout << a << endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# const修饰函数返回值\n\nconst 修饰内置类型的返回值，修饰与不修饰返回值作用一样。\n\nconst 修饰自定义类型的作为返回值，此时**返回的值不能作为左值使用，既不能被赋值，也不能被修改。**这时候返回值为一个常量值，可以降低用户错误而造成的意外\n\n#include <iostream>\n#include <string>\nusing namespace std;\nclass A\n{\nprivate:\n    int _a;\n    string _str;\npublic:\n    A(int a, string str):_a(a), _str(str){}\n    const A operator+(const A &rhs);\n\n    friend ostream &operator<<(ostream &os, const A &a)\n    {\n        os << a._str << " : " << a._a;\n        return os;\n    }\n};\n\nconst A A::operator+(const A &rhs)\n{\n    return A(this->_a + rhs._a, this->_str + rhs._str);\n}\n\nint main(int argc, char *argv[])\n{\n    A a1(1, "a1");\n    A a2(2, "a2");\n    A a3(3, "a3");\n    cout << (a1 + a2) << endl;\n    (a1 + a2) = a3;   //错误， 但是如果去掉const，这里会有怎样的变化\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nconst 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让使用者做什么。\n\n\n# const修饰类成员变量\n\n这个const关键字在修饰成员变量时，与上文提及的使用雷同，const变量主要在初始化列表中赋值，并且不能进行修改。\n\n    class object\n    { \n        …\n        const int value;         //const变量不能被修改 （int const value也可以）\n        …\n        object (int x): value(x) { } ;  // 构造函数初始化const变量\n     } \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# const修饰类成员函数\n\nconst 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。\n\n**注意：**const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。\n\n下面的 get_cm()const; 函数用到了 const 成员函数：\n\n#include<iostream>\nusing namespace std;\nclass Test\n{\npublic:\n    Test(){}\n    Test(int _m):_cm(_m){}\n    int get_cm()const\n    {\n       return _cm;\n    }\n \nprivate:\n    int _cm;\n};\n \n \n \nvoid Cmf(const Test& _tt)\n{\n    cout<<_tt.get_cm();\n}\n \nint main(void)\n{\n    Test t(8);\n    Cmf(t);\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n如果 get_cm() 去掉 const 修饰，则 Cmf 传递的 const _tt 即使没有改变对象的值，编译器也认为函数会改变对象的值，所以尽量将所有的不需要改变对象内容的函数都作为 const 成员函数。\n\n如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用 mutable 关键字修饰这个成员，mutable 的意思也是易变的，容易改变的意思，被 mutable 关键字修饰的成员可以处于不断变化中，如下面的例子。\n\n#include<iostream>\nusing namespace std;\nclass Test\n{\npublic:\n    Test(int _m,int _t):_cm(_m),_ct(_t){}\n    void Kf()const\n    {\n        ++_cm; // 错误\n        ++_ct; // 正确\n    }\nprivate:\n    int _cm;\n    mutable int _ct;\n};\n \nint main(void)\n{\n    Test t(8,7);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这里我们在 Kf() const 中通过 ++_ct; 修改 _ct 的值，但是通过 ++_cm 修改 _cm 则会报错。因为 ++_cm 没有用 mutable 修饰。\n\n\n# const修饰类常量对象\n\n常量对象所有成员默认添加了const修饰字，也就是所有的成员变量都不能进行修改。可以认为是关闭了写权限，所以const对象只能调用const成员函数，因为非const成员函数都有修改成员变量的权限。\n\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n    A(){cout << "non-const" << endl;}\n    void test() const{cout << "const" << endl;} //把这里的const去掉看看会发生什么\n};\n\nint main(int argc, char *argv[])\n{\n    const A a1;\n    a1.test();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# const和#define的区别\n\n 1. 宏定义是在预编译阶段进行文本替换，而const是在编译阶段进行代码的语义约束。\n 2. 由于二者所生效的阶段不同，所以能够起的作用也不同。const常量具有具体的类型，会在编译阶段进行类型检查，产生的代码显然会更加安全。（当然宏定义会更加灵活，可以定义代码或字符串，相对来讲如果要进行大量的宏替换，预编译时间会更长。）\n 3. 宏定义很多时候是展开给立即数，多次替换需要多次分配内存，而const可以通过全局的符号表，仅保存一份copy就完事了。\n\n\n# 使用const的一些建议\n\n 1. 要大胆的使用const，这将给你带来无尽的益处，但前提是你必须搞清楚原委；\n\n 2. 要避免最一般的赋值操作错误，如将const变量赋值；\n\n 3. 在参数中使用const应该使用引用或指针，而不是一般的对象实例，原因同上；\n\n 4. const在成员函数中的三种用法（参数、返回值、函数）要很好的使用；\n\n 5. 不要轻易的将函数的返回值类型定为const；\n\n 6. 除了重载操作符外一般不要将返回值类型定为对某个对象的const引用；',normalizedContent:'一些const关键字常见的情况\n\n\n# const修饰一般变量\n\nconst int a = 7; \nint b = a; // 正确\na = 8;    // 错误，不能改\n\n\n1\n2\n3\n\n\n即使用指针修改也是不可以的：\n\n#include<iostream>\nusing namespace std; \nint main(void)\n{\n    const int  a = 7;\n    int  *p = (int*)&a;\n    *p = 8;\n    cout<<a;  // 这里仍然输出a=7\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果需要修改， 可以通过用volatile来修饰const，\n\n#include<iostream>\nusing namespace std;\nint main(void)\n{\n    volatile const int  a = 7;\n    int  *p = (int*)&a;\n    *p = 8;\n    cout<<a; // 这里输出a=8\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# const修饰指针\n\nconst 在指针的不同位置， 代表的含义也不一样， c++ primer里面会分为顶层const和底层const， 顶层const指指针本身是个const， 底层const指指针所指的对象是个const：\n\nint* const x  = &y；                 //顶层const: const指针 --\x3e 指针指向的地址不能做修改\nconst int* x = &y；                  //底层const: const对象 --\x3e 变量的指向内容不能做修改, \n    \t\t\t\t\t\t\t  \t// y为一个const变量， 或者一个常规变量提升为一个const变量\nconst int* const x  = &y；           //both两者都不能做修改\n\n\n1\n2\n3\n4\n\n\n\n# const修饰引用\n\nconst引用就是指向const对象的引用，普通变量可以绑定到const 引用, 但是const变量不可以绑定到普通的引用上\n\nint var1 = 1, var2 = 2;\nint &a = 0; // 一般引用无法绑定到字面值常量\nconst int &b = 0; //const引用可以绑定字面常量值\nint &c = var1 + var2; //错误，左值引用不可绑定右值, var1+var2为右值\nconst int &d = var1 + var2; //const引用可以绑定右值\n\n\n1\n2\n3\n4\n5\n\n\n\n# const修饰函数参数\n\n传入const变量，一般这种情况不需要 const 修饰，因为函数会自动产生临时变量复制实参值。\n\n传入const指针和const引用， 可以防止传入引用或指针改变原来的实参值\n\n#include <iostream>\nusing namespace std;\n\nvoid func(const int &a){\n    int &b = a;\n    b = 10;\n}\n\nint main(){\n    int a = 0;\n    func(a);\n    cout << a << endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# const修饰函数返回值\n\nconst 修饰内置类型的返回值，修饰与不修饰返回值作用一样。\n\nconst 修饰自定义类型的作为返回值，此时**返回的值不能作为左值使用，既不能被赋值，也不能被修改。**这时候返回值为一个常量值，可以降低用户错误而造成的意外\n\n#include <iostream>\n#include <string>\nusing namespace std;\nclass a\n{\nprivate:\n    int _a;\n    string _str;\npublic:\n    a(int a, string str):_a(a), _str(str){}\n    const a operator+(const a &rhs);\n\n    friend ostream &operator<<(ostream &os, const a &a)\n    {\n        os << a._str << " : " << a._a;\n        return os;\n    }\n};\n\nconst a a::operator+(const a &rhs)\n{\n    return a(this->_a + rhs._a, this->_str + rhs._str);\n}\n\nint main(int argc, char *argv[])\n{\n    a a1(1, "a1");\n    a a2(2, "a2");\n    a a3(3, "a3");\n    cout << (a1 + a2) << endl;\n    (a1 + a2) = a3;   //错误， 但是如果去掉const，这里会有怎样的变化\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nconst 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让使用者做什么。\n\n\n# const修饰类成员变量\n\n这个const关键字在修饰成员变量时，与上文提及的使用雷同，const变量主要在初始化列表中赋值，并且不能进行修改。\n\n    class object\n    { \n        …\n        const int value;         //const变量不能被修改 （int const value也可以）\n        …\n        object (int x): value(x) { } ;  // 构造函数初始化const变量\n     } \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# const修饰类成员函数\n\nconst 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。\n\n**注意：**const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。\n\n下面的 get_cm()const; 函数用到了 const 成员函数：\n\n#include<iostream>\nusing namespace std;\nclass test\n{\npublic:\n    test(){}\n    test(int _m):_cm(_m){}\n    int get_cm()const\n    {\n       return _cm;\n    }\n \nprivate:\n    int _cm;\n};\n \n \n \nvoid cmf(const test& _tt)\n{\n    cout<<_tt.get_cm();\n}\n \nint main(void)\n{\n    test t(8);\n    cmf(t);\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n如果 get_cm() 去掉 const 修饰，则 cmf 传递的 const _tt 即使没有改变对象的值，编译器也认为函数会改变对象的值，所以尽量将所有的不需要改变对象内容的函数都作为 const 成员函数。\n\n如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用 mutable 关键字修饰这个成员，mutable 的意思也是易变的，容易改变的意思，被 mutable 关键字修饰的成员可以处于不断变化中，如下面的例子。\n\n#include<iostream>\nusing namespace std;\nclass test\n{\npublic:\n    test(int _m,int _t):_cm(_m),_ct(_t){}\n    void kf()const\n    {\n        ++_cm; // 错误\n        ++_ct; // 正确\n    }\nprivate:\n    int _cm;\n    mutable int _ct;\n};\n \nint main(void)\n{\n    test t(8,7);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这里我们在 kf() const 中通过 ++_ct; 修改 _ct 的值，但是通过 ++_cm 修改 _cm 则会报错。因为 ++_cm 没有用 mutable 修饰。\n\n\n# const修饰类常量对象\n\n常量对象所有成员默认添加了const修饰字，也就是所有的成员变量都不能进行修改。可以认为是关闭了写权限，所以const对象只能调用const成员函数，因为非const成员函数都有修改成员变量的权限。\n\n#include <iostream>\nusing namespace std;\n\nclass a\n{\npublic:\n    a(){cout << "non-const" << endl;}\n    void test() const{cout << "const" << endl;} //把这里的const去掉看看会发生什么\n};\n\nint main(int argc, char *argv[])\n{\n    const a a1;\n    a1.test();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# const和#define的区别\n\n 1. 宏定义是在预编译阶段进行文本替换，而const是在编译阶段进行代码的语义约束。\n 2. 由于二者所生效的阶段不同，所以能够起的作用也不同。const常量具有具体的类型，会在编译阶段进行类型检查，产生的代码显然会更加安全。（当然宏定义会更加灵活，可以定义代码或字符串，相对来讲如果要进行大量的宏替换，预编译时间会更长。）\n 3. 宏定义很多时候是展开给立即数，多次替换需要多次分配内存，而const可以通过全局的符号表，仅保存一份copy就完事了。\n\n\n# 使用const的一些建议\n\n 1. 要大胆的使用const，这将给你带来无尽的益处，但前提是你必须搞清楚原委；\n\n 2. 要避免最一般的赋值操作错误，如将const变量赋值；\n\n 3. 在参数中使用const应该使用引用或指针，而不是一般的对象实例，原因同上；\n\n 4. const在成员函数中的三种用法（参数、返回值、函数）要很好的使用；\n\n 5. 不要轻易的将函数的返回值类型定为const；\n\n 6. 除了重载操作符外一般不要将返回值类型定为对某个对象的const引用；',charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"typedef",frontmatter:{title:"typedef",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/ab4daf/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/02.typedef.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/02.typedef.md",key:"v-602d1c42",path:"/pages/ab4daf/",headers:[{level:2,title:"定义一种类型的别名",slug:"定义一种类型的别名",normalizedTitle:"定义一种类型的别名",charIndex:74},{level:3,title:"typedef 定义基础类型，int，  long",slug:"typedef-定义基础类型-int-long",normalizedTitle:"typedef 定义基础类型，int，  long",charIndex:null},{level:3,title:"typedef 定义复合类型，如指针和数组。",slug:"typedef-定义复合类型-如指针和数组。",normalizedTitle:"typedef 定义复合类型，如指针和数组。",charIndex:411},{level:3,title:"typedef定义struct类型",slug:"typedef定义struct类型",normalizedTitle:"typedef定义struct类型",charIndex:1163},{level:3,title:"typedef 有const的情况",slug:"typedef-有const的情况",normalizedTitle:"typedef 有const的情况",charIndex:1924},{level:3,title:"typedef 与 #define的区别",slug:"typedef-与-define的区别",normalizedTitle:"typedef 与 #define的区别",charIndex:2485},{level:2,title:"简化复杂的声明",slug:"简化复杂的声明",normalizedTitle:"简化复杂的声明",charIndex:2950},{level:2,title:"跨平台类型定义",slug:"跨平台类型定义",normalizedTitle:"跨平台类型定义",charIndex:4951},{level:2,title:"注意事项：",slug:"注意事项",normalizedTitle:"注意事项：",charIndex:5310},{level:3,title:"typedef是一个存储类的关键字",slug:"typedef是一个存储类的关键字",normalizedTitle:"typedef是一个存储类的关键字",charIndex:5320}],excerpt:"<p>一些大程序里面， 很多时候上来先用typedef定义了很多struct， enum或者union类型， 我们先看看typedef这个关键字</p>\n",headersStr:"定义一种类型的别名 typedef 定义基础类型，int，  long typedef 定义复合类型，如指针和数组。 typedef定义struct类型 typedef 有const的情况 typedef 与 #define的区别 简化复杂的声明 跨平台类型定义 注意事项： typedef是一个存储类的关键字",content:'一些大程序里面， 很多时候上来先用typedef定义了很多struct， enum或者union类型， 我们先看看typedef这个关键字\n\n\n# 定义一种类型的别名\n\n\n# typedef 定义基础类型，int， long\n\ntypedef 使用最多的地方是创建易于记忆的类型名，例如：\n\ntypedef int size;\ntypedef long byte_4;  // 给已知数据类型long起个新名字，叫byte_4。 \nvoid measure(size * psz); \nsize array[4];\nsize len = file.getlength();\nstd::vector<size> vs; \n\n\n1\n2\n3\n4\n5\n6\n\n\n这里定义了一个 int 的同义字，名为 size， typedef 并不创建新的类型。它仅为现有类型添加一个同义字。你可以在需要 int 的地方使用 size：\n\n\n# typedef 定义复合类型，如指针和数组。\n\n例如，像下面这样重复定义有 81 个字符元素的数组：\n\nchar line[81];\nchar text[81];\n\n\n1\n2\n\n\n可以使用typedef定义相同类型和大小的数组，可以这样：\n\ntypedef char Line[81]; \nLine text, secondline;\ngetline(text);\n\n\n1\n2\n3\n\n\n也可以用typedef定义一个指针类型：\n\nchar* pa, pb;         // 这是不对的，它只声明了一个指向字符变量的指针, 和一个字符变量；\ntypedef char * pstr;  // 可以这样\npstr pa, pb;\nint mystrcmp(pstr, pstr);\n\n\n1\n2\n3\n4\n\n\n但是这里也有一些陷阱。标准函数 strcmp()有两个‘const char *’类型的参数。因此，它可能会误导我们象下面这样声明 mystrcmp()：\n\nint mystrcmp(const pstr, const pstr); \n\n\n1\n\n\n这是错误的，按照顺序，‘const pstr’被解释为‘char * const’（一个指向 char 的常量指针），而不是‘const char *’（指向常量 char 的指针）。这个问题很容易解决：\n\ntypedef const char * cpstr; \nint mystrcmp(cpstr, cpstr); // 现在是正确的\n\n\n1\n2\n\n\n记住： 不管什么时候，只要为指针声明 typedef，那么都要在 typedef 名称中加一个 const，以使得该指针所指数据为常量量（常量指针），而指针本身为常量（指针常量）。\n\n\n# typedef定义struct类型\n\ntypedef struct tagMyStruct \n{ \n    int iNum; \n    long lLength; \n} MyStruct; \n\n\n1\n2\n3\n4\n5\n\n\n这语句实际上完成以下两个操作：\n\n1）定义一个新的struct\n\nstruct tagMyStruct \n{ \n    int iNum; \n    long lLength; \n}; \n\n\n1\n2\n3\n4\n5\n\n\n分析：tagMyStruct称为“tag”，即“标签”，实际上是一个临时名字，struct 关键字和tagMyStruct一起，构成了这个结构类型，不论是否有typedef，这个结构都存在。\n\n我们可以用struct tagMyStruct varName来定义变量，但要注意，使用tagMyStruct varName来定义变量是不对的，因为struct 和tagMyStruct合在一起才能表示一个结构类型。\n\n2）typedef为这个新的结构起了一个名字，叫MyStruct。\n\ntypedef struct tagMyStruct MyStruct; \n\n\n1\n\n\n因此，MyStruct实际上相当于struct tagMyStruct，我们可以使用MyStruct varName来定义变量。\n\n3）规范做法：\n\nstruct tagNode \n{ \n    char *pItem; \n    struct tagNode *pNext; \n}; \ntypedef struct tagNode *pNode; \n\n\n1\n2\n3\n4\n5\n6\n\n\n除了对struct， 在一些代码中经常看到对enum， union来进行typedef， 来形成整个程序的类型系统。\n\n\n# typedef 有const的情况\n\ntypedef char* PSTR;\nint mystrcmp(const PSTR, const PSTR);\n\n\n1\n2\n\n\nconst PSTR实际上相当于const char吗？不是的，它实际上相当于char const。\n\n原因在于const给予了整个指针本身以常量性，也就是形成了常量指针char* const。\n\n简单来说，当const和typedef一起出现时，typedef不再是简单的字符串替换。\n\n下面的代码中编译器会报一个错误\n\ntypedef char * pStr; \nchar string[4] = "abc"; \nconst char *p1 = string; \nconst pStr p2 = string; \np1++; \np2++;  // error!  const pStr p2并不等于const char * p2。\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中const pStr p2和const long x本质上没有区别，都是对变量进行只读限制，只不过此处变量p2的数据类型是我们自己定义的而不是系统固有类型而已。const pStr p2的真正含义是：限定数据类型为char *的变量p2为只读，因此p2++错误。\n\n\n# typedef 与 #define的区别\n\nchar* pa, pb;         // 这是不对的，它只声明了一个指向字符变量的指针, 和一个字符变量；\n// #define char* pstr // 如果是这样则是不对的， 因为#define只是等价替换祖父穿， 对于第二个pb则仍然为char类型\ntypedef char * pstr;  // 可以这样\npstr pa, pb;\nint mystrcmp(pstr, pstr);\n\n\n1\n2\n3\n4\n5\n\n\n#define只是在预处理的时候进行简单的字符串替换， typedef是重新在整个程序中定义一个新的类型\n\n不仅仅如此：\n\n 1. #define宏定义有一个特别的长处：可以使用 #ifdef ,#ifndef等来进行逻辑判断，还可以使用#undef来取消定义。\n 2. typedef也有一个特别的长处：它符合范围规则，使用typedef定义的变量类型其作用范围限制在所定义的函数或者文件内（取决于此变量定义的位置），而宏定义则没有这种特性。\n\n\n# 简化复杂的声明\n\n在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例：\n\n 1. 原声明：\n\nint *(*a[5])(int, char*);  // 含有5个函数指针组成的数组\n\n\n1\n\n\n变量名为a，也可以直接用一个新别名 pFun 替换a就可以了：\n\ntypedef int *(*pFun)(int, char*); \npFun a[5]; //  原声明使用pFun表示\n\n\n1\n2\n\n 2. 原声明：\n\nvoid (*b[10]) (void (*)());\n\n\n1\n\n\n变量名为b，先替换右边部分括号里的，pFunParam为别名一：\n\ntypedef void (*pFunParam)();\n\n\n1\n\n\n再替换左边的变量b，pFunx为别名二：\n\n typedef void (*pFunx)(pFunParam);\n\n\n1\n\n\n原声明的最简化版：\n\npFunx b[10];\n\n\n1\n\n 3. 原声明：\n\ndoube(*)() (*e)[9]; \n\n\n1\n\n\n变量名为e，先替换左边部分，pFuny为别名一：\n\ntypedef double(*pFuny)();\n\n\n1\n\n\n再替换右边的变量e，pFunParamy为别名二\n\ntypedef pFuny (*pFunParamy)[9];\n\n\n1\n\n\n原声明的最简化版：\n\npFunParamy e;\n\n\n1\n\n 4. 原声明：\n\n   double(* (*pa)[9] )();      // 此蓝色部分为个人理解，未找到原文出处 \n\n　typedef double(*pFun)();        //首先为上面表达式蓝色部分声明一个新类型 \n　typedef pFun (*pFunParam)[9];  //整体声明一个新类型 \n　pFunParam pa;       //使用定义的新类型来声明对象，等价于double(*(*pa)[9])(); \n\n\n1\n2\n3\n4\n5\n\n\n理解复杂声明可用的“右左法则”：\n\n从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：\n\nint (*func)(int *p);\n\n\n1\n\n\n首先找到变量名func，外面有一对圆括号，而且左边是一个*号，*这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明 (func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有int类型的形参，返回值类型是int。\n\nint (*func[5])(int *);\n\n\n1\n\n\nfunc 右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的不是修饰func，而是修饰 func[5]的，原因是[]运算符优先级比高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指 针，它指向的函数具有int*类型的形参，返回值类型为int。\n\n也可以归纳为2个固定的模式：\n\ntype (*)(....) //函数指针 \ntype (*)[]     //数组指针\n\n\n1\n2\n\n\n上面讨论的 typedef 行为有点像 #define 宏，用其实际类型替代同义字。不同点是 typedef 在编译时被解释，因此让编译器来应付超越预处理器能力的文本替换。例如：\n\ntypedef int (*PF) (const char *, const char *);\n\n\n1\n\n\n这个声明引入了 PF 类型作为函数指针的同义字，该函数有两个 const char * 类型的参数以及一个 int 类型的返回值。如果要使用下列形式的函数声明，那么上述这个 typedef 是不可或缺的：\n\nPF Register(PF pf);\n\n\n1\n\n\nRegister() 的参数是一个 PF 类型的回调函数，返回某个函数的地址，其署名与先前注册的名字相同。做一次深呼吸。下面我展示一下如果不用 typedef，我们是如何实现这个声明的：\n\nint (*Register (int (*pf)(const char *, const char *))) (const char *, const char *); \n\n\n1\n\n\n很少有程序员理解它是什么意思，更不用说这种费解的代码所带来的出错风险了。显然，这里使用 typedef 不是一种特权，而是一种必需。持怀疑态度的人可能会问：“OK，有人还会写这样的代码吗？”，快速浏览一下揭示 signal()函数的头文件 ，一个有同样接口的函数。\n\n\n# 跨平台类型定义\n\n定义一个叫 REAL 的浮点类型，为：\n\ntypedef long double REAL;  // 在目标平台一上，让它表示最高精度的类型\ntypedef double REAL; \t   // 在不支持 long double 的平台二上\ntypedef float REAL;  \t   // 在连 double 都不支持的平台三上，可以这样定义\n\n\n1\n2\n3\n\n\n当在不同的平台时，只要修改 typedef 本身就行，不用对代码其他部分作修改。这个微小的变动可以通过条件编译来自动实现。\n\n标准库广泛使用了这个技巧，比如size_t。\n\n此外，因为typedef是定义了一种类型的别名，不是简单的字符串替换（#define），所以它比宏更稳健（虽然用宏有时也可以完成以上的用途）。\n\n\n# 注意事项：\n\n\n# typedef是一个存储类的关键字\n\n同auto、extern、mutable、static、register等一样，他们在语法上是一个存储类的关键字， 虽然它并不真正影响对象的存储特性，如：\n\ntypedef static int INT2;  // error\ntypedef register int FAST_COUNTER; // error\n\n\n1\n2\n\n\n编译将失败，会提示“指定了一个以上的存储类”。。因为符号 typedef 已经占据了存储类关键字的位置，在 typedef 声明中不能用 register（或任何其它存储类关键字）。s\n\nExtra Reference： Using typedef to Curb Miscreant Code [使用 typedef 抑制劣质代码]',normalizedContent:'一些大程序里面， 很多时候上来先用typedef定义了很多struct， enum或者union类型， 我们先看看typedef这个关键字\n\n\n# 定义一种类型的别名\n\n\n# typedef 定义基础类型，int， long\n\ntypedef 使用最多的地方是创建易于记忆的类型名，例如：\n\ntypedef int size;\ntypedef long byte_4;  // 给已知数据类型long起个新名字，叫byte_4。 \nvoid measure(size * psz); \nsize array[4];\nsize len = file.getlength();\nstd::vector<size> vs; \n\n\n1\n2\n3\n4\n5\n6\n\n\n这里定义了一个 int 的同义字，名为 size， typedef 并不创建新的类型。它仅为现有类型添加一个同义字。你可以在需要 int 的地方使用 size：\n\n\n# typedef 定义复合类型，如指针和数组。\n\n例如，像下面这样重复定义有 81 个字符元素的数组：\n\nchar line[81];\nchar text[81];\n\n\n1\n2\n\n\n可以使用typedef定义相同类型和大小的数组，可以这样：\n\ntypedef char line[81]; \nline text, secondline;\ngetline(text);\n\n\n1\n2\n3\n\n\n也可以用typedef定义一个指针类型：\n\nchar* pa, pb;         // 这是不对的，它只声明了一个指向字符变量的指针, 和一个字符变量；\ntypedef char * pstr;  // 可以这样\npstr pa, pb;\nint mystrcmp(pstr, pstr);\n\n\n1\n2\n3\n4\n\n\n但是这里也有一些陷阱。标准函数 strcmp()有两个‘const char *’类型的参数。因此，它可能会误导我们象下面这样声明 mystrcmp()：\n\nint mystrcmp(const pstr, const pstr); \n\n\n1\n\n\n这是错误的，按照顺序，‘const pstr’被解释为‘char * const’（一个指向 char 的常量指针），而不是‘const char *’（指向常量 char 的指针）。这个问题很容易解决：\n\ntypedef const char * cpstr; \nint mystrcmp(cpstr, cpstr); // 现在是正确的\n\n\n1\n2\n\n\n记住： 不管什么时候，只要为指针声明 typedef，那么都要在 typedef 名称中加一个 const，以使得该指针所指数据为常量量（常量指针），而指针本身为常量（指针常量）。\n\n\n# typedef定义struct类型\n\ntypedef struct tagmystruct \n{ \n    int inum; \n    long llength; \n} mystruct; \n\n\n1\n2\n3\n4\n5\n\n\n这语句实际上完成以下两个操作：\n\n1）定义一个新的struct\n\nstruct tagmystruct \n{ \n    int inum; \n    long llength; \n}; \n\n\n1\n2\n3\n4\n5\n\n\n分析：tagmystruct称为“tag”，即“标签”，实际上是一个临时名字，struct 关键字和tagmystruct一起，构成了这个结构类型，不论是否有typedef，这个结构都存在。\n\n我们可以用struct tagmystruct varname来定义变量，但要注意，使用tagmystruct varname来定义变量是不对的，因为struct 和tagmystruct合在一起才能表示一个结构类型。\n\n2）typedef为这个新的结构起了一个名字，叫mystruct。\n\ntypedef struct tagmystruct mystruct; \n\n\n1\n\n\n因此，mystruct实际上相当于struct tagmystruct，我们可以使用mystruct varname来定义变量。\n\n3）规范做法：\n\nstruct tagnode \n{ \n    char *pitem; \n    struct tagnode *pnext; \n}; \ntypedef struct tagnode *pnode; \n\n\n1\n2\n3\n4\n5\n6\n\n\n除了对struct， 在一些代码中经常看到对enum， union来进行typedef， 来形成整个程序的类型系统。\n\n\n# typedef 有const的情况\n\ntypedef char* pstr;\nint mystrcmp(const pstr, const pstr);\n\n\n1\n2\n\n\nconst pstr实际上相当于const char吗？不是的，它实际上相当于char const。\n\n原因在于const给予了整个指针本身以常量性，也就是形成了常量指针char* const。\n\n简单来说，当const和typedef一起出现时，typedef不再是简单的字符串替换。\n\n下面的代码中编译器会报一个错误\n\ntypedef char * pstr; \nchar string[4] = "abc"; \nconst char *p1 = string; \nconst pstr p2 = string; \np1++; \np2++;  // error!  const pstr p2并不等于const char * p2。\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中const pstr p2和const long x本质上没有区别，都是对变量进行只读限制，只不过此处变量p2的数据类型是我们自己定义的而不是系统固有类型而已。const pstr p2的真正含义是：限定数据类型为char *的变量p2为只读，因此p2++错误。\n\n\n# typedef 与 #define的区别\n\nchar* pa, pb;         // 这是不对的，它只声明了一个指向字符变量的指针, 和一个字符变量；\n// #define char* pstr // 如果是这样则是不对的， 因为#define只是等价替换祖父穿， 对于第二个pb则仍然为char类型\ntypedef char * pstr;  // 可以这样\npstr pa, pb;\nint mystrcmp(pstr, pstr);\n\n\n1\n2\n3\n4\n5\n\n\n#define只是在预处理的时候进行简单的字符串替换， typedef是重新在整个程序中定义一个新的类型\n\n不仅仅如此：\n\n 1. #define宏定义有一个特别的长处：可以使用 #ifdef ,#ifndef等来进行逻辑判断，还可以使用#undef来取消定义。\n 2. typedef也有一个特别的长处：它符合范围规则，使用typedef定义的变量类型其作用范围限制在所定义的函数或者文件内（取决于此变量定义的位置），而宏定义则没有这种特性。\n\n\n# 简化复杂的声明\n\n在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例：\n\n 1. 原声明：\n\nint *(*a[5])(int, char*);  // 含有5个函数指针组成的数组\n\n\n1\n\n\n变量名为a，也可以直接用一个新别名 pfun 替换a就可以了：\n\ntypedef int *(*pfun)(int, char*); \npfun a[5]; //  原声明使用pfun表示\n\n\n1\n2\n\n 2. 原声明：\n\nvoid (*b[10]) (void (*)());\n\n\n1\n\n\n变量名为b，先替换右边部分括号里的，pfunparam为别名一：\n\ntypedef void (*pfunparam)();\n\n\n1\n\n\n再替换左边的变量b，pfunx为别名二：\n\n typedef void (*pfunx)(pfunparam);\n\n\n1\n\n\n原声明的最简化版：\n\npfunx b[10];\n\n\n1\n\n 3. 原声明：\n\ndoube(*)() (*e)[9]; \n\n\n1\n\n\n变量名为e，先替换左边部分，pfuny为别名一：\n\ntypedef double(*pfuny)();\n\n\n1\n\n\n再替换右边的变量e，pfunparamy为别名二\n\ntypedef pfuny (*pfunparamy)[9];\n\n\n1\n\n\n原声明的最简化版：\n\npfunparamy e;\n\n\n1\n\n 4. 原声明：\n\n   double(* (*pa)[9] )();      // 此蓝色部分为个人理解，未找到原文出处 \n\n　typedef double(*pfun)();        //首先为上面表达式蓝色部分声明一个新类型 \n　typedef pfun (*pfunparam)[9];  //整体声明一个新类型 \n　pfunparam pa;       //使用定义的新类型来声明对象，等价于double(*(*pa)[9])(); \n\n\n1\n2\n3\n4\n5\n\n\n理解复杂声明可用的“右左法则”：\n\n从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：\n\nint (*func)(int *p);\n\n\n1\n\n\n首先找到变量名func，外面有一对圆括号，而且左边是一个*号，*这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明 (func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有int类型的形参，返回值类型是int。\n\nint (*func[5])(int *);\n\n\n1\n\n\nfunc 右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的不是修饰func，而是修饰 func[5]的，原因是[]运算符优先级比高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指 针，它指向的函数具有int*类型的形参，返回值类型为int。\n\n也可以归纳为2个固定的模式：\n\ntype (*)(....) //函数指针 \ntype (*)[]     //数组指针\n\n\n1\n2\n\n\n上面讨论的 typedef 行为有点像 #define 宏，用其实际类型替代同义字。不同点是 typedef 在编译时被解释，因此让编译器来应付超越预处理器能力的文本替换。例如：\n\ntypedef int (*pf) (const char *, const char *);\n\n\n1\n\n\n这个声明引入了 pf 类型作为函数指针的同义字，该函数有两个 const char * 类型的参数以及一个 int 类型的返回值。如果要使用下列形式的函数声明，那么上述这个 typedef 是不可或缺的：\n\npf register(pf pf);\n\n\n1\n\n\nregister() 的参数是一个 pf 类型的回调函数，返回某个函数的地址，其署名与先前注册的名字相同。做一次深呼吸。下面我展示一下如果不用 typedef，我们是如何实现这个声明的：\n\nint (*register (int (*pf)(const char *, const char *))) (const char *, const char *); \n\n\n1\n\n\n很少有程序员理解它是什么意思，更不用说这种费解的代码所带来的出错风险了。显然，这里使用 typedef 不是一种特权，而是一种必需。持怀疑态度的人可能会问：“ok，有人还会写这样的代码吗？”，快速浏览一下揭示 signal()函数的头文件 ，一个有同样接口的函数。\n\n\n# 跨平台类型定义\n\n定义一个叫 real 的浮点类型，为：\n\ntypedef long double real;  // 在目标平台一上，让它表示最高精度的类型\ntypedef double real; \t   // 在不支持 long double 的平台二上\ntypedef float real;  \t   // 在连 double 都不支持的平台三上，可以这样定义\n\n\n1\n2\n3\n\n\n当在不同的平台时，只要修改 typedef 本身就行，不用对代码其他部分作修改。这个微小的变动可以通过条件编译来自动实现。\n\n标准库广泛使用了这个技巧，比如size_t。\n\n此外，因为typedef是定义了一种类型的别名，不是简单的字符串替换（#define），所以它比宏更稳健（虽然用宏有时也可以完成以上的用途）。\n\n\n# 注意事项：\n\n\n# typedef是一个存储类的关键字\n\n同auto、extern、mutable、static、register等一样，他们在语法上是一个存储类的关键字， 虽然它并不真正影响对象的存储特性，如：\n\ntypedef static int int2;  // error\ntypedef register int fast_counter; // error\n\n\n1\n2\n\n\n编译将失败，会提示“指定了一个以上的存储类”。。因为符号 typedef 已经占据了存储类关键字的位置，在 typedef 声明中不能用 register（或任何其它存储类关键字）。s\n\nextra reference： using typedef to curb miscreant code [使用 typedef 抑制劣质代码]',charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"extern",frontmatter:{title:"extern",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/5bac8e/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/05.extern.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/05.extern.md",key:"v-6a18abfa",path:"/pages/5bac8e/",headers:[{level:2,title:"extern  +  non-const var",slug:"extern-non-const-var",normalizedTitle:"extern  +  non-const var",charIndex:null},{level:2,title:"extern +  const var",slug:"extern-const-var",normalizedTitle:"extern +  const var",charIndex:null},{level:2,title:"extern 和 static",slug:"extern-和-static",normalizedTitle:"extern 和 static",charIndex:1197},{level:2,title:'extern "C"',slug:"extern-c",normalizedTitle:"extern &quot;c&quot;",charIndex:null},{level:2,title:"一些问题：",slug:"一些问题",normalizedTitle:"一些问题：",charIndex:4372},{level:3,title:"问题(1)：extern 变量",slug:"问题-1-extern-变量",normalizedTitle:"问题(1)：extern 变量",charIndex:4382},{level:3,title:"问题(2)：单方面修改extern函数原型",slug:"问题-2-单方面修改extern函数原型",normalizedTitle:"问题(2)：单方面修改extern函数原型",charIndex:4845},{level:3,title:"问题(3)：extern “C”",slug:"问题-3-extern-c",normalizedTitle:"问题(3)：extern “c”",charIndex:5101},{level:3,title:"问题(4)：extern 非 static 函数",slug:"问题-4-extern-非-static-函数",normalizedTitle:"问题(4)：extern 非 static 函数",charIndex:5573}],excerpt:"<p>extern关键字的含义， 用法以及在编译的时候是如何进行链接的</p>\n",headersStr:'extern  +  non-const var extern +  const var extern 和 static extern "C" 一些问题： 问题(1)：extern 变量 问题(2)：单方面修改extern函数原型 问题(3)：extern “C” 问题(4)：extern 非 static 函数',content:'extern关键字的含义， 用法以及在编译的时候是如何进行链接的\n\n 1. 置于变量或者函数前: 表明该变量或者函数定义在别的文件中\n 2. 在变量或者函数之前加上extern关键字表明这是一个声明, 其定义可能在其他文件处, 注意不能对变量进行初始化或者对函数进行定义, 否则表明这是一个定义而不是声明.\n\n\n# extern + non-const var\n\n最常见的用法，当链接器在一个全局变量声明前看到extern关键字，它会尝试在其他文件中寻找这个变量的定义。这里强调全局且非常量的原因是，全局非常量的变量默认是外部链接的。\n\n//fileA.cpp\nint i = 1;     //声明并定义全局变量i\n \n//fileB.cpp\nextern int i;  //声明i，链接全局变量\n \n//fileC.cpp\nextern int i = 2;    //错误，多重定义\nint i;               //错误，这是一个定义，导致多重定义\n\nmain() {\n  extern int i;    //正确\n  int i = 5;       //正确，新的局部变量i;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# extern + const var\n\n常量全局变量默认是内部链接的，所以想要在文件间传递常量全局变量需要在定义时指明extern，如下所示：\n\n//fileA.cpp\nextern const int i = 1;    //定义\n \n//fileB.cpp                \nextern const int i;        //声明\n\n\n1\n2\n3\n4\n5\n\n * 默认情况下, const修饰的全局常量据有跟static相同的特性， const 对象仅在本文件内有效, 但是可以通过 extern 关键字来使得 const 对象在多个文件中共享. 如在.h文件中声明 extern const char g_str[]; 在.cpp中别忘了定义: const char g_str[ ] = "123456";\n\n所以当const单独使用时它就与static相同，而当与extern一起合作的时候，它的特性就跟extern的一样了\n\n所以对const没有什么可以过多的描述，只是要注意，const char* g_str = "123456" 与 const char g_str[] ="123465"是不同的， 前面那个const 修饰的是char 而不是g_str,它的g_str并不是常量，如果让char g_str遵守const的全局常量的规则，最好这么定义const char const g_str="123456". 这个话题在 const关键字中讨论\n\n\n# extern 和 static\n\n(1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.\n\n(2) static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.\n\nstatic 作用范围是内部连接的关系, 和extern有点相反.它和对象本身是分开存储的,extern也是分开存储的,但是extern可以被其他的对象用extern 引用,而static 不可以,只允许对象本身用它. 具体差别首先，static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；最后，static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它,如:\n\n(1) test1.h:\n\n#ifndef TEST1H\n#define TEST1H\nstatic char g_str[] = "123456";\nvoid fun1();\n#endif\n\n\n1\n2\n3\n4\n5\n\n\n(2) test1.cpp:\n\n#include "test1.h"\nvoid fun1() {  cout << g_str << endl; }\n\n\n1\n2\n\n\n(3) test2.cpp\n\n#include "test1.h"\nvoid fun2() {  cout << g_str << endl; }\n\n\n1\n2\n\n\n以上两个编译单元可以连接成功, 当你打开test1.obj时，你可以在它里面找到字符串"123456", 同时你也可以在test2.obj中找到它们，它们之所以可以连接成功而没有报重复定义的错误是因为虽然它们有相同的内容，但是存储的物理地址并不一样，就像是两个不同变量赋了相同的值一样，而这两个变量分别作用于它们各自的编译单元。 也许你比较较真，自己偷偷的跟踪调试上面的代码,结果你发现两个编译单元（test1,test2）的g_str的内存地址相同，于是你下结论static修饰的变量也可以作用于其他模块，但是我要告诉你，那是你的编译器在欺骗你，大多数编译器都对代码都有优化功能，以达到生成的目标程序更节省内存，执行效率更高，当编译器在连接各个编译单元的时候，它会把相同内容的内存只拷贝一份，比如上面的"123456", 位于两个编译单元中的变量都是同样的内容，那么在连接的时候它在内存中就只会存在一份了，如果你把上面的代码改成下面的样子，你马上就可以拆穿编译器的谎言:\n\ntest1.cpp:\n\n#include "test1.h"\nvoid fun1()\n{\n    g_str[0] = \'\'a\'\';\n    cout << g_str << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\ntest2.cpp:\n\n#include "test1.h"\nvoid fun2() { cout << g_str << endl; }\n\n\n1\n2\n\n\nmain function:\n\nvoid main(){\n    fun1(); // a23456\n    fun2(); // 123456\n}\n\n\n1\n2\n3\n4\n\n\n这个时候你在跟踪代码时，就会发现两个编译单元中的g_str地址并不相同，因为你在一处修改了它，所以编译器被强行的恢复内存的原貌，在内存中存在了两份拷贝给两个模块中的变量使用。正是因为static有以上的特性，所以一般定义static全局变量时，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染.\n\n\n# extern "C"\n\n 1. extern"C": 让编译器以 C 语言的命名规则来查找函数\n 2. extern“C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。因为 C++ 重载, 而 C 不重载, 函数名编译的结果都不一样, 因此如果 C++ 直接调用 C 的函数, 因为二者编译的不同, 就会失败.\n\n在C++中，当与字符串连用时，extern指明当前声明使用了其他语言的链接规范，如extern "C"，就指明使用C语言的链接规范。原因是，C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时无法找到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。C和C++对函数的处理方式是不同的.extern "C"是使C++能够调用C写作的库文件的一个手段，如果要对编译器提示使用C的方式来处理函数的话，那么就要使用extern "C"来说明。\n\n// 声明printf函数使用C链接\nextern "C" int printf(const char *fmt, ...);\n\n//声明指定的头文件内所有的东西都使用 C 链接\nextern "C" {\n    #include <stdio.h>\n}\n\n// 声明函数ShowChar和GetChar使用 C 链接\nextern "C" {\n    char ShowChar(char ch);\n    char GetChar(void);\n}\n\n// 定义函数 ShowChar 和 GetChar 使用 C 链接\nextern "C" char ShowChar(char ch) {\n    putchar(ch);\n    return ch;\n}\n\nextern "C" char GetChar(void) {\n    char ch;\n    ch = getchar();\n    return ch;\n}\n\n// 声明全局变量 errno 为C链接\nextern "C" int errno;\n\n//又比如，在程序中常见的代码段\n#ifdef __cplusplus \nextern "C" { \n   #endif \n\n/**** some declaration or so *****/ \n#ifdef __cplusplus \n} \n#endif\n\n//这里__cplusplus是cpp中的自定义宏，定义了这个宏就表明这是一段cpp的代码，也就是说，//上面的代码的含义是:如果这是一段cpp的代码，那么加入extern "C"{和}处理其中的代码。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n * extern和static是一对矛盾的修饰符, 二者不能同时修饰一个变量, 因为static表明变量的链接性是内部的, 而extern恰好相反.\n\n注意事项：\n\n * 不要把变量定义放入.h文件，这样容易导致重复定义错误\n\n * 尽量使用static关键字把变量定义限制于该源文件作用域，除非变量被设计成全局的。\n\n * 可以在头文件中声明一个变量，在用的时候包含这个头文件就声明了这个变量。\n\n\n# 一些问题：\n\n\n# 问题(1)：extern 变量\n\n在一个源文件里定义了一个数组：char a[6];\n\n在另外一个文件里用下列语句进行了声明：extern char *a；\n\n请问，这样可以吗？\n\n答案与分析：\n\n1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char *a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。\n\n2)、例子分析如下，如果a[ ] = "abcd",则外部变量a=0x61626364 (abcd的ASCII码值)，*a显然没有意义\n\na指向的空间（0x61626364）没有意义，易出现非法内存访问。\n\n3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。\n\n4)、extern用在变量声明中常常有这样一个作用，在*.*c文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在.h中并用extern来声明。\n\n\n# 问题(2)：单方面修改extern函数原型\n\n当函数提供方单方面修改函数原型时，如果使用方不知情继续沿用原来的extern申明，这样编译时编译器不会报错。但是在运行过程中，因为少了或者多了输入参数，往往会照成系统错误，这种情况应该如何解决？\n\n答案与分析：\n\n这种情况的处理没有一个很完美的方案，通常是提供方在自己的xxx_pub.h中提供对外部接口的声明，然后调用方include该头文件，从而省去extern这一步。以避免这种错误。\n\n剑有双锋，对extern的应用，不同的场合应该选择不同的做法。\n\n\n# 问题(3)：extern “C”\n\n在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？\n\n答案与分析：\n\nC++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。\n\n下面是一个典型的用法：\n\n//在.h文件的头上\n#ifdef __cplusplus\n#if __cplusplus\nextern "C"{\n#endif\n#endif /* __cplusplus */\n\n    …\n    …\n\n//.h文件结束的地方\n#ifdef __cplusplus\n#if __cplusplus\n}\n#endif\n#endif /* __cplusplus */ \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 问题(4)：extern 非 static 函数\n\n常常见extern放在函数的前面成为函数声明的一部分，那么，C语言的关键字extern在函数的声明中起什么作用？\n\n答案与分析：\n\n如果函数的声明中带有关键字extern，仅仅是暗示这个函数可能在别的源文件里定义，没有其它作用。即extern int f(); 和 int f();两个函数声明没有明显的区别\n\n当然，用处还是有的，就是在程序中取代include “*.h”来声明函数，在一些复杂的项目中，我比较习惯在所有的函数声明前添加extern修饰。关于这样做的原因和利弊可见下面的这个例子：“用extern修饰的全局变量”\n\n(1) 在test1.h中有下列声明:\n\n#ifndef TEST1H\n#define TEST1H\n\nextern char g_str[]; // 声明全局变量g_str\nvoid fun1();\n\n#endif\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n(2) 在test1.cpp中\n\n#include "test1.h"\nchar g_str[] = "123456"; // 定义全局变量g_str\nvoid fun1() { cout << g_str << endl; }\n\n\n1\n2\n3\n\n\n(3) 以上是test1模块， 它的编译和连接都可以通过,如果我们还有test2模块也想使用g_str,只需要在原文件中引用就可以了\n\n#include "test1.h"\nvoid fun2()  { cout << g_str << endl;  }\n\n\n1\n2\n\n\n以上test1和test2可以同时编译连接通过，如果你感兴趣的话可以用ultraEdit打开test1.obj,你可以在里面找到"123456"这个字符串,但是你却不能在test2.obj里面找到，这是因为g_str是整个工程的全局变量，在内存中只存在一份,test2.obj这个编译单元不需要再有一份了，不然会在连接时报告重复定义这个错误!\n\n(4) 有些人喜欢把全局变量的声明和定义放在一起，这样可以防止忘记了定义，如把上面test1.h改为\n\nextern char g_str[] = "123456"; // 这个时候相当于没有extern\n\n\n1\n\n\n然后把test1.cpp中的g_str的定义去掉,这个时候再编译连接test1和test2两个模块时，会报连接错误，这是因为你把全局变量g_str的定义放在了头文件之后，test1.cpp这个模块包含了test1.h所以定义了一次g_str,而test2.cpp也包含了test1.h所以再一次定义了g_str,这个时候连接器在连接test1和test2时发现两个g_str。如果一定要把g_str的定义放在test1.h中的话，那么就把test2的代码中#include "test1.h"去掉 换成:\n\nextern char g_str[];\nvoid fun2()  { cout << g_str << endl;  }\n\n\n1\n2\n\n\n这个时候编译器就知道g_str是引自于外部的一个编译模块了，不会在本模块中再重复定义一个出来，但是这样做会非常不方便，因为无法再在test2.cpp中使用#include "test1.h", 所以test1.h中声明的其他函数也无法使用了，除非都用extern修饰，声明的函数就要一大串，而且头文件的作用本来就是要给外部提供接口使用的，所以，只在头文件中做声明，真理总是这么简单粗暴。',normalizedContent:'extern关键字的含义， 用法以及在编译的时候是如何进行链接的\n\n 1. 置于变量或者函数前: 表明该变量或者函数定义在别的文件中\n 2. 在变量或者函数之前加上extern关键字表明这是一个声明, 其定义可能在其他文件处, 注意不能对变量进行初始化或者对函数进行定义, 否则表明这是一个定义而不是声明.\n\n\n# extern + non-const var\n\n最常见的用法，当链接器在一个全局变量声明前看到extern关键字，它会尝试在其他文件中寻找这个变量的定义。这里强调全局且非常量的原因是，全局非常量的变量默认是外部链接的。\n\n//filea.cpp\nint i = 1;     //声明并定义全局变量i\n \n//fileb.cpp\nextern int i;  //声明i，链接全局变量\n \n//filec.cpp\nextern int i = 2;    //错误，多重定义\nint i;               //错误，这是一个定义，导致多重定义\n\nmain() {\n  extern int i;    //正确\n  int i = 5;       //正确，新的局部变量i;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# extern + const var\n\n常量全局变量默认是内部链接的，所以想要在文件间传递常量全局变量需要在定义时指明extern，如下所示：\n\n//filea.cpp\nextern const int i = 1;    //定义\n \n//fileb.cpp                \nextern const int i;        //声明\n\n\n1\n2\n3\n4\n5\n\n * 默认情况下, const修饰的全局常量据有跟static相同的特性， const 对象仅在本文件内有效, 但是可以通过 extern 关键字来使得 const 对象在多个文件中共享. 如在.h文件中声明 extern const char g_str[]; 在.cpp中别忘了定义: const char g_str[ ] = "123456";\n\n所以当const单独使用时它就与static相同，而当与extern一起合作的时候，它的特性就跟extern的一样了\n\n所以对const没有什么可以过多的描述，只是要注意，const char* g_str = "123456" 与 const char g_str[] ="123465"是不同的， 前面那个const 修饰的是char 而不是g_str,它的g_str并不是常量，如果让char g_str遵守const的全局常量的规则，最好这么定义const char const g_str="123456". 这个话题在 const关键字中讨论\n\n\n# extern 和 static\n\n(1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.\n\n(2) static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.\n\nstatic 作用范围是内部连接的关系, 和extern有点相反.它和对象本身是分开存储的,extern也是分开存储的,但是extern可以被其他的对象用extern 引用,而static 不可以,只允许对象本身用它. 具体差别首先，static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；最后，static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它,如:\n\n(1) test1.h:\n\n#ifndef test1h\n#define test1h\nstatic char g_str[] = "123456";\nvoid fun1();\n#endif\n\n\n1\n2\n3\n4\n5\n\n\n(2) test1.cpp:\n\n#include "test1.h"\nvoid fun1() {  cout << g_str << endl; }\n\n\n1\n2\n\n\n(3) test2.cpp\n\n#include "test1.h"\nvoid fun2() {  cout << g_str << endl; }\n\n\n1\n2\n\n\n以上两个编译单元可以连接成功, 当你打开test1.obj时，你可以在它里面找到字符串"123456", 同时你也可以在test2.obj中找到它们，它们之所以可以连接成功而没有报重复定义的错误是因为虽然它们有相同的内容，但是存储的物理地址并不一样，就像是两个不同变量赋了相同的值一样，而这两个变量分别作用于它们各自的编译单元。 也许你比较较真，自己偷偷的跟踪调试上面的代码,结果你发现两个编译单元（test1,test2）的g_str的内存地址相同，于是你下结论static修饰的变量也可以作用于其他模块，但是我要告诉你，那是你的编译器在欺骗你，大多数编译器都对代码都有优化功能，以达到生成的目标程序更节省内存，执行效率更高，当编译器在连接各个编译单元的时候，它会把相同内容的内存只拷贝一份，比如上面的"123456", 位于两个编译单元中的变量都是同样的内容，那么在连接的时候它在内存中就只会存在一份了，如果你把上面的代码改成下面的样子，你马上就可以拆穿编译器的谎言:\n\ntest1.cpp:\n\n#include "test1.h"\nvoid fun1()\n{\n    g_str[0] = \'\'a\'\';\n    cout << g_str << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\ntest2.cpp:\n\n#include "test1.h"\nvoid fun2() { cout << g_str << endl; }\n\n\n1\n2\n\n\nmain function:\n\nvoid main(){\n    fun1(); // a23456\n    fun2(); // 123456\n}\n\n\n1\n2\n3\n4\n\n\n这个时候你在跟踪代码时，就会发现两个编译单元中的g_str地址并不相同，因为你在一处修改了它，所以编译器被强行的恢复内存的原貌，在内存中存在了两份拷贝给两个模块中的变量使用。正是因为static有以上的特性，所以一般定义static全局变量时，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染.\n\n\n# extern "c"\n\n 1. extern"c": 让编译器以 c 语言的命名规则来查找函数\n 2. extern“c”的主要作用就是为了能够正确实现c++代码调用其他c语言代码。加上extern “c”后，会指示编译器这部分代码按c语言的进行编译，而不是c++的。由于c++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而c语言并不支持函数重载，因此编译c语言代码的函数时不会带上函数的参数类型，一般只包括函数名。因为 c++ 重载, 而 c 不重载, 函数名编译的结果都不一样, 因此如果 c++ 直接调用 c 的函数, 因为二者编译的不同, 就会失败.\n\n在c++中，当与字符串连用时，extern指明当前声明使用了其他语言的链接规范，如extern "c"，就指明使用c语言的链接规范。原因是，c++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而c语言则不会，因此会造成链接时无法找到对应函数的情况，此时c函数就需要用extern “c”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。c和c++对函数的处理方式是不同的.extern "c"是使c++能够调用c写作的库文件的一个手段，如果要对编译器提示使用c的方式来处理函数的话，那么就要使用extern "c"来说明。\n\n// 声明printf函数使用c链接\nextern "c" int printf(const char *fmt, ...);\n\n//声明指定的头文件内所有的东西都使用 c 链接\nextern "c" {\n    #include <stdio.h>\n}\n\n// 声明函数showchar和getchar使用 c 链接\nextern "c" {\n    char showchar(char ch);\n    char getchar(void);\n}\n\n// 定义函数 showchar 和 getchar 使用 c 链接\nextern "c" char showchar(char ch) {\n    putchar(ch);\n    return ch;\n}\n\nextern "c" char getchar(void) {\n    char ch;\n    ch = getchar();\n    return ch;\n}\n\n// 声明全局变量 errno 为c链接\nextern "c" int errno;\n\n//又比如，在程序中常见的代码段\n#ifdef __cplusplus \nextern "c" { \n   #endif \n\n/**** some declaration or so *****/ \n#ifdef __cplusplus \n} \n#endif\n\n//这里__cplusplus是cpp中的自定义宏，定义了这个宏就表明这是一段cpp的代码，也就是说，//上面的代码的含义是:如果这是一段cpp的代码，那么加入extern "c"{和}处理其中的代码。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n * extern和static是一对矛盾的修饰符, 二者不能同时修饰一个变量, 因为static表明变量的链接性是内部的, 而extern恰好相反.\n\n注意事项：\n\n * 不要把变量定义放入.h文件，这样容易导致重复定义错误\n\n * 尽量使用static关键字把变量定义限制于该源文件作用域，除非变量被设计成全局的。\n\n * 可以在头文件中声明一个变量，在用的时候包含这个头文件就声明了这个变量。\n\n\n# 一些问题：\n\n\n# 问题(1)：extern 变量\n\n在一个源文件里定义了一个数组：char a[6];\n\n在另外一个文件里用下列语句进行了声明：extern char *a；\n\n请问，这样可以吗？\n\n答案与分析：\n\n1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型t的指针并不等价于类型t的数组。extern char *a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。\n\n2)、例子分析如下，如果a[ ] = "abcd",则外部变量a=0x61626364 (abcd的ascii码值)，*a显然没有意义\n\na指向的空间（0x61626364）没有意义，易出现非法内存访问。\n\n3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。\n\n4)、extern用在变量声明中常常有这样一个作用，在*.*c文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在.h中并用extern来声明。\n\n\n# 问题(2)：单方面修改extern函数原型\n\n当函数提供方单方面修改函数原型时，如果使用方不知情继续沿用原来的extern申明，这样编译时编译器不会报错。但是在运行过程中，因为少了或者多了输入参数，往往会照成系统错误，这种情况应该如何解决？\n\n答案与分析：\n\n这种情况的处理没有一个很完美的方案，通常是提供方在自己的xxx_pub.h中提供对外部接口的声明，然后调用方include该头文件，从而省去extern这一步。以避免这种错误。\n\n剑有双锋，对extern的应用，不同的场合应该选择不同的做法。\n\n\n# 问题(3)：extern “c”\n\n在c++环境下使用c函数的时候，常常会出现编译器无法找到obj模块中的c函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？\n\n答案与分析：\n\nc++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而c语言则不会，因此会造成链接时找不到对应函数的情况，此时c函数就需要用extern “c”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。\n\n下面是一个典型的用法：\n\n//在.h文件的头上\n#ifdef __cplusplus\n#if __cplusplus\nextern "c"{\n#endif\n#endif /* __cplusplus */\n\n    …\n    …\n\n//.h文件结束的地方\n#ifdef __cplusplus\n#if __cplusplus\n}\n#endif\n#endif /* __cplusplus */ \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 问题(4)：extern 非 static 函数\n\n常常见extern放在函数的前面成为函数声明的一部分，那么，c语言的关键字extern在函数的声明中起什么作用？\n\n答案与分析：\n\n如果函数的声明中带有关键字extern，仅仅是暗示这个函数可能在别的源文件里定义，没有其它作用。即extern int f(); 和 int f();两个函数声明没有明显的区别\n\n当然，用处还是有的，就是在程序中取代include “*.h”来声明函数，在一些复杂的项目中，我比较习惯在所有的函数声明前添加extern修饰。关于这样做的原因和利弊可见下面的这个例子：“用extern修饰的全局变量”\n\n(1) 在test1.h中有下列声明:\n\n#ifndef test1h\n#define test1h\n\nextern char g_str[]; // 声明全局变量g_str\nvoid fun1();\n\n#endif\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n(2) 在test1.cpp中\n\n#include "test1.h"\nchar g_str[] = "123456"; // 定义全局变量g_str\nvoid fun1() { cout << g_str << endl; }\n\n\n1\n2\n3\n\n\n(3) 以上是test1模块， 它的编译和连接都可以通过,如果我们还有test2模块也想使用g_str,只需要在原文件中引用就可以了\n\n#include "test1.h"\nvoid fun2()  { cout << g_str << endl;  }\n\n\n1\n2\n\n\n以上test1和test2可以同时编译连接通过，如果你感兴趣的话可以用ultraedit打开test1.obj,你可以在里面找到"123456"这个字符串,但是你却不能在test2.obj里面找到，这是因为g_str是整个工程的全局变量，在内存中只存在一份,test2.obj这个编译单元不需要再有一份了，不然会在连接时报告重复定义这个错误!\n\n(4) 有些人喜欢把全局变量的声明和定义放在一起，这样可以防止忘记了定义，如把上面test1.h改为\n\nextern char g_str[] = "123456"; // 这个时候相当于没有extern\n\n\n1\n\n\n然后把test1.cpp中的g_str的定义去掉,这个时候再编译连接test1和test2两个模块时，会报连接错误，这是因为你把全局变量g_str的定义放在了头文件之后，test1.cpp这个模块包含了test1.h所以定义了一次g_str,而test2.cpp也包含了test1.h所以再一次定义了g_str,这个时候连接器在连接test1和test2时发现两个g_str。如果一定要把g_str的定义放在test1.h中的话，那么就把test2的代码中#include "test1.h"去掉 换成:\n\nextern char g_str[];\nvoid fun2()  { cout << g_str << endl;  }\n\n\n1\n2\n\n\n这个时候编译器就知道g_str是引自于外部的一个编译模块了，不会在本模块中再重复定义一个出来，但是这样做会非常不方便，因为无法再在test2.cpp中使用#include "test1.h", 所以test1.h中声明的其他函数也无法使用了，除非都用extern修饰，声明的函数就要一大串，而且头文件的作用本来就是要给外部提供接口使用的，所以，只在头文件中做声明，真理总是这么简单粗暴。',charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"type cast",frontmatter:{title:"type cast",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/409de3/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/01.type%20cast.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/01.type cast.md",key:"v-7d0fcd4a",path:"/pages/409de3/",headers:[{level:2,title:"隐式转换",slug:"隐式转换",normalizedTitle:"隐式转换",charIndex:86},{level:3,title:"整型提升",slug:"整型提升",normalizedTitle:"整型提升",charIndex:1876},{level:2,title:"显式转换",slug:"显式转换",normalizedTitle:"显式转换",charIndex:2332},{level:3,title:"static_cast",slug:"static-cast",normalizedTitle:"static_cast",charIndex:19},{level:3,title:"dynamic_cast",slug:"dynamic-cast",normalizedTitle:"dynamic_cast",charIndex:31},{level:3,title:"reinterpret_cast",slug:"reinterpret-cast",normalizedTitle:"reinterpret_cast",charIndex:55},{level:3,title:"const_cast",slug:"const-cast",normalizedTitle:"const_cast",charIndex:44},{level:2,title:"C语言中的强制类型转换",slug:"c语言中的强制类型转换",normalizedTitle:"c语言中的强制类型转换",charIndex:664},{level:2,title:"Summary",slug:"summary",normalizedTitle:"summary",charIndex:6505},{level:2,title:"static_cast 一些将会导致错误的情况。",slug:"static-cast-一些将会导致错误的情况。",normalizedTitle:"static_cast 一些将会导致错误的情况。",charIndex:7589},{level:4,title:"泛型(Generic Types)",slug:"泛型-generic-types",normalizedTitle:"泛型(generic types)",charIndex:7617},{level:4,title:"指针类型(Pointer Types)``",slug:"指针类型-pointer-types",normalizedTitle:"指针类型(pointer types)``",charIndex:8225},{level:5,title:"情况1：两个无关的类之间的转换",slug:"情况1-两个无关的类之间的转换",normalizedTitle:"情况1：两个无关的类之间的转换",charIndex:8719},{level:5,title:"情况2：转换到相关的类",slug:"情况2-转换到相关的类",normalizedTitle:"情况2：转换到相关的类",charIndex:9184},{level:5,title:"情况3：void之间的向前和向后转换",slug:"情况3-void之间的向前和向后转换",normalizedTitle:"情况3：void之间的向前和向后转换",charIndex:10482}],excerpt:"<p>C++中的类型转换， 四种cast: static_cast、dynamic_cast、const_cast和reinterpret_cast, 以及其他转换方法</p>\n",headersStr:"隐式转换 整型提升 显式转换 static_cast dynamic_cast reinterpret_cast const_cast C语言中的强制类型转换 Summary static_cast 一些将会导致错误的情况。 泛型(Generic Types) 指针类型(Pointer Types)`` 情况1：两个无关的类之间的转换 情况2：转换到相关的类 情况3：void之间的向前和向后转换",content:'C++中的类型转换， 四种cast: static_cast、dynamic_cast、const_cast和reinterpret_cast, 以及其他转换方法\n\n\n# 隐式转换\n\n在不同类型之间进行赋值，其根据类型不同得到不同的结果，如下为基本的转换规则:\n\n 1.  非布尔->布尔：0->false; 非0->true\n\n 2.  布尔->非布尔：false->0; true->1\n\n 3.  浮点->整数：近似处理，保留浮点数小数点之前的部分\n\n 4.  整数->浮点数：小数部分记为0，如果整数所占空间超过浮点类型容量，精度会产生损失\n\n 5.  给无符号类型一个超过其表示范围的值时，结果是初始值对无符号类型表示数值的总数取模以后的余数。例如unsigned char(8 bit) 可以表示0-255，如果赋一个区间以外的值，则实际结果为该值对256取模所得的余数。unsigned char x = -1; // x = 255\n\n 6.  当赋给带符号类型一个超过其表示范围的值时，结果是未定义的。此时程序可能继续工作、可能崩溃，也可能产生垃圾数据（未定义）\n\n 7.  无符号数转换为更大的数据类型时, 只需简单地在开头添加0，这种运算称为0扩展\n\n 8.  将有符号数转换为更大的数据类型需要执行符号扩展，规则是将当前数符号位扩展至所需要的位数\n\n 9.  当数据类型转换时，同时需要在不同数据大小，以及无符号和有符号之间转换时，C语言标准要求先进行数据大小的转换，之后再进行无符号和有符号之间的转换。C语言中的强制类型转换保持二进制位值不变，只是改变解释位的方式。\n\n 10. 将一个大的数据类型转换为小的数据类型时，不管是无符号数还是有符号数都是简单地进行位截断\n\n 11. 进行整数的算术运算时，当结果变量的位数不足以存放实际实际结果的位数时，运算的结果就会因截断而产生溢出\n     \n     #include <iostream>\n     #include <limits>\n     using namespace std;\n     \n     int main()\n     {\n         bool bValue = true;\n         char cValue = numeric_limits<char>::max();\n         short sValue = numeric_limits<short>::max();\n         int iValue = numeric_limits<int>::max();\n         long lValue = numeric_limits<long>::max();\n         long long llValue = numeric_limits<long long>::max();\n         float fValue = numeric_limits<float>::max();\n         double dValue = numeric_limits<double>::max();\n         long double ldValue = numeric_limits<long double>::max();\n     \n         //测试开始\n         cout << (bValue=cValue) << " " << (bValue=sValue) << " " << (bValue=iValue) <<endl;\n         cout << (bValue=lValue) << " " << (bValue=llValue) << " " << (bValue=fValue) <<endl;\n         cout << (bValue=dValue) << " " << (bValue=ldValue) << endl;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     \n     \n     以上输出为全1。\n\n\n# 整型提升\n\n负责把小整数装换成较大的整数类型，\n\n对于bool、char、signed char、unsigned char、short、unisned short等类型，只要他们所有可能的值都能存在int类型中，就会提升为int，否则提升为unsigned int。\n\nwchar_t、char16_t、char32_6提升成int、unsigned int、long、unsigned long、long long、unsigned long long中最小的一种，前提是能容纳原始类型所有可能的值\n\n无符号与有符号之间的转换有几种情况：\n\n 1. 如果无符号类型不小于带符号类型，则有符号类型转换成无符号类型，如int需要转换成unsigned int。如果有符号是负数，则取模运算\n 2. 如果带符号大于无符号且带符号类型可以容纳所有无符号值，则转换成带符号，否则转换成无符号。比如long和unsigned int，如果int和long大小相同，则long类型转换成unsigned int。\n\n\n# 显式转换\n\n\n# static_cast\n\nstatic_cast< new_type >(expression)\n\n\n1\n\n\n相当于传统的C语言里的强制转换: 把expression转换为new_type类型\n\ncompile time检查，用于非多态的转换，可以转换指针及其他\n\n没有运行时类型检查来保证转换的安全性\n\n用法\n\n 1. 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。\n    1. 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；\n    2. 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。\n 2. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。\n 3. 把空指针转换成目标类型的空指针。\n 4. 把任何类型的表达式转换成void类型。\n\nstatic_cast不能转换掉expression的const、volatile、或者__unaligned属性\n\nchar a = \'a\';\nint b = static_cast<int>(a);//正确，将char型数据转换成int型数据\ndouble *c = new double;\nvoid *d = static_cast<void*>(c);//正确，将double指针转换成void指针\nint e = 10;\nconst int f = static_cast<const int>(e);//正确，将int型数据转换成const int型数据\nconst int g = 20;\nint *h = static_cast<int*>(&g);//编译错误，static_cast不能转换掉g的const属性\nclass Base\n{};\nclass Derived : public Base\n{}\nBase* pB = new Base();\nif(Derived* pD = static_cast<Derived*>(pB))\n{} //下行转换是不安全的(坚决抵制这种方法)\nDerived* pD = new Derived();\nif(Base* pB = static_cast<Base*>(pD))\n{} //上行转换是安全的\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。\n\n\n# dynamic_cast\n\ndynamic_cast 是C++对多态支持的强制类型转换。 所以class 里面必须有 virtual function； 通过运行时类型识别(RTTI)，程序能够使用基类的指针或引用来检索这些指针或引用所指对象的实际派生类型。\n\n与其他强制类型转换不同，dynamic_cast涉及运行时类型检查(RTTI)。 如果绑定到引用或指针的对象不是目标类型的对象，则 dynamic_cast 失败。有两种情况:\n\n 1. to pointer : 如果转换到指针类型的dynamic_cast失败，则dynamic_cast的结果是 0 值；\n 2. to reference : 如果转换到引用类型的dynamic_cast失败，则抛出一个bad_cast类型的异常。\n\ndynamic_cast<type*>(expr) \t//type必须是一个类类型且必须是一个有效的指针\ndynamic_cast<type&>(expr) \t//type必须是一个类类型且必须是一个左值\ndynamic_cast<type&&>(expr) \t//type必须是一个类类型且必须是一个右值\n\n\n1\n2\n3\n\n\nexpr的类型必须符合以下三个条件中的任何一个：\n\n 1. expr的类型是目标类型type的公有派生类\n 2. expr的类型是目标type的共有基类\n 3. expr的类型就是目标type的类型。\n\n用法\n\n * dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换（cross cast）。\n * 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；\n * 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。\n * dynamic_cast是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。\n\nif(Derived *dp = dynamic_cast<Derived *>(bp)){\n    //使用dp指向的Derived对象 \n}\nelse{\n    //使用bp指向的Base对象 \n}\nvoid f(const Base &b){\n    try{\n        const Derived &d = dynamic_cast<const Base &>(b); \n        //使用b引用的Derived对象\n    }\n    catch(std::bad_cast){\n        //处理类型转换失败的情况\n    }\n}\n \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# reinterpret_cast\n\n仅仅重新解释类型，但没有进行二进制的转换：\n\n转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。\n\n在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。\n\n最普通的用途就是在函数指针类型之间进行转换。\n\n很难保证移植性。\n\n用法可以总结如下：\n\n 1. 去const属性用const_cast。\n 2. 基本类型转换用static_cast。\n 3. 多态类之间的类型转换用daynamic_cast。\n 4. 不同类型的指针类型转换用reinterpret_cast。\n\n通常为运算对象的位模式提供较低层次上的重新解释。即要求编译器将两种无关联的类型作转换。\n\n * reinterpret_cast本质上依赖于机器。要想安全地使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。\n * 较危险， 慎用\n\n\n# const_cast\n\n这个操作符可以暂时去掉变量const属性或者volatile属性的转换符，这样就可以更改const变量了。比如下面代码\n\nstring str = "hello";\nchar *_const = str.substr(0,3).c_str();//c_str()返回const char*类型，直接赋值给char *显然出错，这句话编译不能通过\nchar *_non_const = const_cast<char *> (str.substr(0,3).c_str());  //将const属性移除，可以通过编译了\n\n\n1\n2\n3\n\n * const_cast， const_cast 只能改变运算对象的low_level const\n * 一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了。\n * 如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。\n\n\n# C语言中的强制类型转换\n\n在引入命名的强制类型转换操作符之前，显式强制转换用圆括号将类型括起来实现：\n\nchar *pc = (char*) ip;\n\n\n1\n\n\n效果与使用 reinterpret_cast 符号相同，但这种强制转换的可视性比较差，难以跟踪错误的转换。\n\n标准 C++ 为了加强类型转换的可视性，引入命名的强制转换操作符，为程序员在必须使用强制转换时提供了更好的工具。例如，非指针的 static_cast 和const_cast 要比 reinterpret_cast 更安全。 结果使程序员（以及读者和操纵程序的工具）可清楚地辨别代码中每个显式的强制转换潜在的风险级别。\n\n虽然标准 C++ 仍然支持旧式强制转换符号，但是我们建议，只有在 C 语言或标准 C++ 之前的编译器上编写代码时，才使用这种语法。 旧式强制转换符号有下列两种形式：\n\ntype (expr); // Function-style cast notation\n(type) expr; // C-language-style cast notation\n\n\n1\n2\n\n\n旧式强制转换依赖于所涉及的数据类型，具有与 const_cast、 static_cast 和 reinterpret_cast 一样的行为。 在合法使用 static_cast 或 const_cast 的地方，旧式强制转换提供了与各自对应的命名强制转换一样的功能。 如果这两种强制转换均不合法，则旧式强制转换执行 reinterpret_cast 功能。 例如，我们可用旧式符号重写上一节的强制转换:\n\nint ival; double dval;      \nival += int (dval);         // static_cast: converts double to int\nconst char* pc_str;     \nstring_copy((char*)pc_str); // const_cast: casts away const\nint *ip;     \nchar *pc = (char*)ip;       // reinterpret_cast: treats int as char\n\n\n1\n2\n3\n4\n5\n6\n\n\n支持旧式强制转换符号是为了对“在标准 C++ 之前编写的程序”保持向后兼容性，并保持与 C 语言的兼容性。\n\n\n# Summary\n\nreinterpret_cast可以转换任意一个32bit整数，包括所有的指针和整数。可以把任何整数转成指针，也可以把任何指针转成整数，以及把指针转化为任意类型的指针，威力最为强大！但不能将非32bit的实例转成指针。总之，只要是32bit的东东，怎么转都行！\n\nstatic_cast和dynamic_cast可以执行指针到指针的转换，或实例本身到实例本身的转换，但不能在实例和指针之间转换。\n\nstatic_cast只能提供编译时的类型安全， 而dynamic_cast可以提供运行时类型安全。举个例子：\n\nclass a；\nclass b:a；\nclass c;\n\n\n1\n2\n3\n\n\n上面三个类a是基类，b继承a，c和ab没有关系。\n\n有一个函数\n\nvoid function(a &a); \n\n\n1\n\n\n现在有一个对象是b的实例b，一个c的实例c。\n\nfunction(static_cast<a&>(b)可以通过而 function(static_cast<a&>(c))不能通过编译，因为在编译的时候编译器已经知道c和a的类型不符，因此static_cast可以保证安全。\n\n下面我们骗一下编译器，先把c转成类型a\n\nb& ref_b = reinterpret_cast<b&>c; \n\n\n1\n\n\n然后function(static_cast<a&>(ref_b))就通过了！因为从编译器的角度来看，在编译时并不能知道ref_b实际上是c！\n\nfunction(dynamic_cast<a&>(ref_b))编译时也能过，但在运行时失败了，因为dynamic_cast在运行时会检查ref_b的实际类型，这样就骗不过去了。\n\n在应用多态编程时，当我们无法确定传过来的对象的实际类型时使用dynamic_cast，如果能保证对象的实际类型，用 static_cast 就可以了。\n\n 1. dynamic_cast:动态类型转换\n 2. static_cast:静态类型转换\n 3. reinterpret_cast:重新解释类型转换\n 4. const_cast:常量类型转换\n\n一些常规操作:\n\n 1. dynamic_cast 一般用在父类和子类指针或应用的互相转化;\n 2. static_cast 一般是普通数据类型(如int m =static_cast(3.14));\n 3. reinterpret_cast 很像c的一般暴力类型转换操作\n 4. const_cast 是把cosnt或volatile属性去掉\n\n\n# static_cast 一些将会导致错误的情况。\n\n# 泛型(Generic Types)\n\nfloat f = 12.3;\nfloat *pf = &f;\n// static cast<>\n// 成功编译, n = 12\nint n = static_cast<int>(f);\n\n// 错误,指向的类型是无关的(译注：即指针变量pf是float类型，现在要被转换为int类型)\nint* pn = static_cast<int*>(pf);\n\n//成功编译\nvoid* pv = static_cast<void*>(pf);\n\nint* pn2 = static_cast<int*>(pv); //成功编译, 但是 *pn2是无意义的内存(rubbish)\n// reinterpret_cast<>\n\nint i = reinterpret_cast<int>(f);     //错误,编译器知道你应该调用static_cast<>\nint* pi = reinterpret_cast<int*>(pf); //成功编译, 但是 *pi 实际上是无意义的内存,和 *pn2一样\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n简而言之，static_cast<> 将尝试转换，举例来说，如float-到-integer，而reinterpret_cast<>将改变编译器的意图重新将对象作为另一类型来处理\n\n# 指针类型(Pointer Types)``\n\n指针转换有点复杂，后面其情况都会使用下面的类：\n\nclass CBaseX\n{\n    public:\n        int x;\n        CBaseX() { x = 10; }\n        void foo() { printf("CBaseX::foo() x =%d/n", x); }\n};\n\nclass CBaseY\n{\n    public:\n        int y;\n        int* py;\n        CBaseY() { y = 20; py = &y; }\n        void bar() { printf("CBaseY::bar() y =%d, *py =%d/n", y, *py); }\n};\n\nclass CDerived : public CBaseX, public CBaseY\n{\n    public:\n    \tint z;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 情况1：两个无关的类之间的转换\n\n// Convert between CBaseX* and CBaseY*\n// CBaseX* 和 CBaseY*之间的转换\nCBaseX* pX = new CBaseX(); // Error, types pointed to are unrelated\nCBaseY* pY1 = static_cast<CBaseY*>(pX); // Compile OK, but pY2 is not CBaseX\n\nCBaseY* pY2 = reinterpret_cast<CBaseY*>(pX); // System crash!!!\n// pY2->bar();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n正如我们在泛型例子中所认识到的，如果你尝试转换一个对象到另一个无关的类static_cast<>将失败，而reinterpret_cast<>就总是成功“欺骗”编译器：那个对象就是那个无关类。但是在运行的时候由于编译器对被转换的对象会发生错误的解释, 程序会crash掉.\n\n# 情况2：转换到相关的类\n\nCDerived* pD = new CDerived();\nprintf("CDerived* pD = %x/n", (int)pD);\n// static_cast<> CDerived* -> CBaseY* -> CDerived*\nCBaseY* pY1 = pD; //成功编译，隐式static_cast<>转换\nprintf("CBaseY* pY1 = %x/n", (int)pY1);\n\nCDerived* pD1 = static_cast<CDerived*>(pY1);// 成功编译, 现在 pD1 = pD\nprintf("CDerived* pD1 = %x/n", (int)pD1);\n// reinterpret_cast\nCBaseY* pY2 = reinterpret_cast<CBaseY*>(pD);// 成功编译, 但是 pY2 不是 CBaseY*\nprintf("CBaseY* pY2 = %x/n", (int)pY2);\n\n// 无关的 static_cast<>\nCBaseY* pY3 = new CBaseY();\nprintf("CBaseY* pY3 = %x/n", (int)pY3);\n\nCDerived* pD3 = static_cast<CDerived*>(pY3);// 成功编译,尽管 pY3 只是一个 "新 CBaseY()"\nprintf("CDerived* pD3 = %x/n", (int)pD3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n---------------------- output ---------------------------\n\nCDerived* pD = 392fb8\n\nCBaseY* pY1 = 392fbc\n\nCDerived* pD1 = 392fb8\n\nCBaseY* pY2 = 392fb8\n\nCBaseY* pY3 = 390ff0\n\nCDerived* pD3 = 390fec\n\n注意：在将CDerived用隐式 static_cast<>转换到CBaseY(第5行)时，结果是(指向)CDerived*(的指针向后) 偏移了4(个字节)(译注：4为int类型在内存中所占字节数)。为了知道static_cast<> 实际如何，我们不得不要来看一下CDerived的内存布局。\n\nCDerived的内存布局包括两个对象，CBaseX 和 CBaseY，编译器也知道这一点。因此，当将CDerived* 转换到 CBaseY时，它给指针添加4个字节，同时当你将CBaseY转换到CDerived*时，它给指针减去4。然而，甚至它即便不是一个CDerived你也可以这样做。\n\n当然，这个问题只在如果你做了多继承时发生。在你将CDerived转换 到 CBaseX时static_cast<> 和 reinterpret_cast<>是没有区别的。\n\n# 情况3：void之间的向前和向后转换\n\n因为任何指针可以被转换到void，而void*可以被向后转换到任何指针(对于static_cast<> 和 reinterpret_cast<>转换都可以这样做)，如果没有小心处理的话错误可能发生。\n\nCDerived* pD = new CDerived();\nprintf("CDerived* pD = %x/n", (int)pD);\nCBaseY* pY = pD; // 成功编译, pY = pD + 4\nprintf("CBaseY* pY = %x/n", (int)pY);\nvoid* pV1 = pY; //成功编译, pV1 = pY\nprintf("void* pV1 = %x/n", (int)pV1);\n// pD2 = pY, 但是我们预期 pD2 = pY - 4\nCDerived* pD2 = static_cast<CDerived*>(pV1);\nprintf("CDerived* pD2 = %x/n", (int)pD2);\n// pD2->bar();// 系统崩溃\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n---------------------- 输出 ---------------------------\n\nCDerived* pD = 392fb8\n\nCBaseY* pY = 392fbc\n\nvoid* pV1 = 392fbcd\n\nCDerived* pD2 = 392fbc\n\n一旦我们已经转换指针为void，我们就不能轻易将其转换回原类。在上面的例子中，从一个void 返回CDerived的唯一方法是将其转换为CBaseY然后再转换为CDerived。 但是如果我们不能确定它是CBaseY* 还是 CDerived*，这时我们不得不用dynamic_cast<> 或typeid[2]。\n\n注释：\n\n 1. dynamic_cast<>, 从另一方面来说，可以防止一个泛型CBaseY* 被转换到CDerived*。\n\n 2. dynamic_cast<>, 需要类成为多态，即包括“虚”函数，并因此而不能成为void*。',normalizedContent:'c++中的类型转换， 四种cast: static_cast、dynamic_cast、const_cast和reinterpret_cast, 以及其他转换方法\n\n\n# 隐式转换\n\n在不同类型之间进行赋值，其根据类型不同得到不同的结果，如下为基本的转换规则:\n\n 1.  非布尔->布尔：0->false; 非0->true\n\n 2.  布尔->非布尔：false->0; true->1\n\n 3.  浮点->整数：近似处理，保留浮点数小数点之前的部分\n\n 4.  整数->浮点数：小数部分记为0，如果整数所占空间超过浮点类型容量，精度会产生损失\n\n 5.  给无符号类型一个超过其表示范围的值时，结果是初始值对无符号类型表示数值的总数取模以后的余数。例如unsigned char(8 bit) 可以表示0-255，如果赋一个区间以外的值，则实际结果为该值对256取模所得的余数。unsigned char x = -1; // x = 255\n\n 6.  当赋给带符号类型一个超过其表示范围的值时，结果是未定义的。此时程序可能继续工作、可能崩溃，也可能产生垃圾数据（未定义）\n\n 7.  无符号数转换为更大的数据类型时, 只需简单地在开头添加0，这种运算称为0扩展\n\n 8.  将有符号数转换为更大的数据类型需要执行符号扩展，规则是将当前数符号位扩展至所需要的位数\n\n 9.  当数据类型转换时，同时需要在不同数据大小，以及无符号和有符号之间转换时，c语言标准要求先进行数据大小的转换，之后再进行无符号和有符号之间的转换。c语言中的强制类型转换保持二进制位值不变，只是改变解释位的方式。\n\n 10. 将一个大的数据类型转换为小的数据类型时，不管是无符号数还是有符号数都是简单地进行位截断\n\n 11. 进行整数的算术运算时，当结果变量的位数不足以存放实际实际结果的位数时，运算的结果就会因截断而产生溢出\n     \n     #include <iostream>\n     #include <limits>\n     using namespace std;\n     \n     int main()\n     {\n         bool bvalue = true;\n         char cvalue = numeric_limits<char>::max();\n         short svalue = numeric_limits<short>::max();\n         int ivalue = numeric_limits<int>::max();\n         long lvalue = numeric_limits<long>::max();\n         long long llvalue = numeric_limits<long long>::max();\n         float fvalue = numeric_limits<float>::max();\n         double dvalue = numeric_limits<double>::max();\n         long double ldvalue = numeric_limits<long double>::max();\n     \n         //测试开始\n         cout << (bvalue=cvalue) << " " << (bvalue=svalue) << " " << (bvalue=ivalue) <<endl;\n         cout << (bvalue=lvalue) << " " << (bvalue=llvalue) << " " << (bvalue=fvalue) <<endl;\n         cout << (bvalue=dvalue) << " " << (bvalue=ldvalue) << endl;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     \n     \n     以上输出为全1。\n\n\n# 整型提升\n\n负责把小整数装换成较大的整数类型，\n\n对于bool、char、signed char、unsigned char、short、unisned short等类型，只要他们所有可能的值都能存在int类型中，就会提升为int，否则提升为unsigned int。\n\nwchar_t、char16_t、char32_6提升成int、unsigned int、long、unsigned long、long long、unsigned long long中最小的一种，前提是能容纳原始类型所有可能的值\n\n无符号与有符号之间的转换有几种情况：\n\n 1. 如果无符号类型不小于带符号类型，则有符号类型转换成无符号类型，如int需要转换成unsigned int。如果有符号是负数，则取模运算\n 2. 如果带符号大于无符号且带符号类型可以容纳所有无符号值，则转换成带符号，否则转换成无符号。比如long和unsigned int，如果int和long大小相同，则long类型转换成unsigned int。\n\n\n# 显式转换\n\n\n# static_cast\n\nstatic_cast< new_type >(expression)\n\n\n1\n\n\n相当于传统的c语言里的强制转换: 把expression转换为new_type类型\n\ncompile time检查，用于非多态的转换，可以转换指针及其他\n\n没有运行时类型检查来保证转换的安全性\n\n用法\n\n 1. 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。\n    1. 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；\n    2. 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。\n 2. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。\n 3. 把空指针转换成目标类型的空指针。\n 4. 把任何类型的表达式转换成void类型。\n\nstatic_cast不能转换掉expression的const、volatile、或者__unaligned属性\n\nchar a = \'a\';\nint b = static_cast<int>(a);//正确，将char型数据转换成int型数据\ndouble *c = new double;\nvoid *d = static_cast<void*>(c);//正确，将double指针转换成void指针\nint e = 10;\nconst int f = static_cast<const int>(e);//正确，将int型数据转换成const int型数据\nconst int g = 20;\nint *h = static_cast<int*>(&g);//编译错误，static_cast不能转换掉g的const属性\nclass base\n{};\nclass derived : public base\n{}\nbase* pb = new base();\nif(derived* pd = static_cast<derived*>(pb))\n{} //下行转换是不安全的(坚决抵制这种方法)\nderived* pd = new derived();\nif(base* pb = static_cast<base*>(pd))\n{} //上行转换是安全的\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。\n\n\n# dynamic_cast\n\ndynamic_cast 是c++对多态支持的强制类型转换。 所以class 里面必须有 virtual function； 通过运行时类型识别(rtti)，程序能够使用基类的指针或引用来检索这些指针或引用所指对象的实际派生类型。\n\n与其他强制类型转换不同，dynamic_cast涉及运行时类型检查(rtti)。 如果绑定到引用或指针的对象不是目标类型的对象，则 dynamic_cast 失败。有两种情况:\n\n 1. to pointer : 如果转换到指针类型的dynamic_cast失败，则dynamic_cast的结果是 0 值；\n 2. to reference : 如果转换到引用类型的dynamic_cast失败，则抛出一个bad_cast类型的异常。\n\ndynamic_cast<type*>(expr) \t//type必须是一个类类型且必须是一个有效的指针\ndynamic_cast<type&>(expr) \t//type必须是一个类类型且必须是一个左值\ndynamic_cast<type&&>(expr) \t//type必须是一个类类型且必须是一个右值\n\n\n1\n2\n3\n\n\nexpr的类型必须符合以下三个条件中的任何一个：\n\n 1. expr的类型是目标类型type的公有派生类\n 2. expr的类型是目标type的共有基类\n 3. expr的类型就是目标type的类型。\n\n用法\n\n * dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换（cross cast）。\n * 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；\n * 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。\n * dynamic_cast是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。\n\nif(derived *dp = dynamic_cast<derived *>(bp)){\n    //使用dp指向的derived对象 \n}\nelse{\n    //使用bp指向的base对象 \n}\nvoid f(const base &b){\n    try{\n        const derived &d = dynamic_cast<const base &>(b); \n        //使用b引用的derived对象\n    }\n    catch(std::bad_cast){\n        //处理类型转换失败的情况\n    }\n}\n \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# reinterpret_cast\n\n仅仅重新解释类型，但没有进行二进制的转换：\n\n转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。\n\n在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。\n\n最普通的用途就是在函数指针类型之间进行转换。\n\n很难保证移植性。\n\n用法可以总结如下：\n\n 1. 去const属性用const_cast。\n 2. 基本类型转换用static_cast。\n 3. 多态类之间的类型转换用daynamic_cast。\n 4. 不同类型的指针类型转换用reinterpret_cast。\n\n通常为运算对象的位模式提供较低层次上的重新解释。即要求编译器将两种无关联的类型作转换。\n\n * reinterpret_cast本质上依赖于机器。要想安全地使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。\n * 较危险， 慎用\n\n\n# const_cast\n\n这个操作符可以暂时去掉变量const属性或者volatile属性的转换符，这样就可以更改const变量了。比如下面代码\n\nstring str = "hello";\nchar *_const = str.substr(0,3).c_str();//c_str()返回const char*类型，直接赋值给char *显然出错，这句话编译不能通过\nchar *_non_const = const_cast<char *> (str.substr(0,3).c_str());  //将const属性移除，可以通过编译了\n\n\n1\n2\n3\n\n * const_cast， const_cast 只能改变运算对象的low_level const\n * 一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了。\n * 如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。\n\n\n# c语言中的强制类型转换\n\n在引入命名的强制类型转换操作符之前，显式强制转换用圆括号将类型括起来实现：\n\nchar *pc = (char*) ip;\n\n\n1\n\n\n效果与使用 reinterpret_cast 符号相同，但这种强制转换的可视性比较差，难以跟踪错误的转换。\n\n标准 c++ 为了加强类型转换的可视性，引入命名的强制转换操作符，为程序员在必须使用强制转换时提供了更好的工具。例如，非指针的 static_cast 和const_cast 要比 reinterpret_cast 更安全。 结果使程序员（以及读者和操纵程序的工具）可清楚地辨别代码中每个显式的强制转换潜在的风险级别。\n\n虽然标准 c++ 仍然支持旧式强制转换符号，但是我们建议，只有在 c 语言或标准 c++ 之前的编译器上编写代码时，才使用这种语法。 旧式强制转换符号有下列两种形式：\n\ntype (expr); // function-style cast notation\n(type) expr; // c-language-style cast notation\n\n\n1\n2\n\n\n旧式强制转换依赖于所涉及的数据类型，具有与 const_cast、 static_cast 和 reinterpret_cast 一样的行为。 在合法使用 static_cast 或 const_cast 的地方，旧式强制转换提供了与各自对应的命名强制转换一样的功能。 如果这两种强制转换均不合法，则旧式强制转换执行 reinterpret_cast 功能。 例如，我们可用旧式符号重写上一节的强制转换:\n\nint ival; double dval;      \nival += int (dval);         // static_cast: converts double to int\nconst char* pc_str;     \nstring_copy((char*)pc_str); // const_cast: casts away const\nint *ip;     \nchar *pc = (char*)ip;       // reinterpret_cast: treats int as char\n\n\n1\n2\n3\n4\n5\n6\n\n\n支持旧式强制转换符号是为了对“在标准 c++ 之前编写的程序”保持向后兼容性，并保持与 c 语言的兼容性。\n\n\n# summary\n\nreinterpret_cast可以转换任意一个32bit整数，包括所有的指针和整数。可以把任何整数转成指针，也可以把任何指针转成整数，以及把指针转化为任意类型的指针，威力最为强大！但不能将非32bit的实例转成指针。总之，只要是32bit的东东，怎么转都行！\n\nstatic_cast和dynamic_cast可以执行指针到指针的转换，或实例本身到实例本身的转换，但不能在实例和指针之间转换。\n\nstatic_cast只能提供编译时的类型安全， 而dynamic_cast可以提供运行时类型安全。举个例子：\n\nclass a；\nclass b:a；\nclass c;\n\n\n1\n2\n3\n\n\n上面三个类a是基类，b继承a，c和ab没有关系。\n\n有一个函数\n\nvoid function(a &a); \n\n\n1\n\n\n现在有一个对象是b的实例b，一个c的实例c。\n\nfunction(static_cast<a&>(b)可以通过而 function(static_cast<a&>(c))不能通过编译，因为在编译的时候编译器已经知道c和a的类型不符，因此static_cast可以保证安全。\n\n下面我们骗一下编译器，先把c转成类型a\n\nb& ref_b = reinterpret_cast<b&>c; \n\n\n1\n\n\n然后function(static_cast<a&>(ref_b))就通过了！因为从编译器的角度来看，在编译时并不能知道ref_b实际上是c！\n\nfunction(dynamic_cast<a&>(ref_b))编译时也能过，但在运行时失败了，因为dynamic_cast在运行时会检查ref_b的实际类型，这样就骗不过去了。\n\n在应用多态编程时，当我们无法确定传过来的对象的实际类型时使用dynamic_cast，如果能保证对象的实际类型，用 static_cast 就可以了。\n\n 1. dynamic_cast:动态类型转换\n 2. static_cast:静态类型转换\n 3. reinterpret_cast:重新解释类型转换\n 4. const_cast:常量类型转换\n\n一些常规操作:\n\n 1. dynamic_cast 一般用在父类和子类指针或应用的互相转化;\n 2. static_cast 一般是普通数据类型(如int m =static_cast(3.14));\n 3. reinterpret_cast 很像c的一般暴力类型转换操作\n 4. const_cast 是把cosnt或volatile属性去掉\n\n\n# static_cast 一些将会导致错误的情况。\n\n# 泛型(generic types)\n\nfloat f = 12.3;\nfloat *pf = &f;\n// static cast<>\n// 成功编译, n = 12\nint n = static_cast<int>(f);\n\n// 错误,指向的类型是无关的(译注：即指针变量pf是float类型，现在要被转换为int类型)\nint* pn = static_cast<int*>(pf);\n\n//成功编译\nvoid* pv = static_cast<void*>(pf);\n\nint* pn2 = static_cast<int*>(pv); //成功编译, 但是 *pn2是无意义的内存(rubbish)\n// reinterpret_cast<>\n\nint i = reinterpret_cast<int>(f);     //错误,编译器知道你应该调用static_cast<>\nint* pi = reinterpret_cast<int*>(pf); //成功编译, 但是 *pi 实际上是无意义的内存,和 *pn2一样\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n简而言之，static_cast<> 将尝试转换，举例来说，如float-到-integer，而reinterpret_cast<>将改变编译器的意图重新将对象作为另一类型来处理\n\n# 指针类型(pointer types)``\n\n指针转换有点复杂，后面其情况都会使用下面的类：\n\nclass cbasex\n{\n    public:\n        int x;\n        cbasex() { x = 10; }\n        void foo() { printf("cbasex::foo() x =%d/n", x); }\n};\n\nclass cbasey\n{\n    public:\n        int y;\n        int* py;\n        cbasey() { y = 20; py = &y; }\n        void bar() { printf("cbasey::bar() y =%d, *py =%d/n", y, *py); }\n};\n\nclass cderived : public cbasex, public cbasey\n{\n    public:\n    \tint z;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 情况1：两个无关的类之间的转换\n\n// convert between cbasex* and cbasey*\n// cbasex* 和 cbasey*之间的转换\ncbasex* px = new cbasex(); // error, types pointed to are unrelated\ncbasey* py1 = static_cast<cbasey*>(px); // compile ok, but py2 is not cbasex\n\ncbasey* py2 = reinterpret_cast<cbasey*>(px); // system crash!!!\n// py2->bar();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n正如我们在泛型例子中所认识到的，如果你尝试转换一个对象到另一个无关的类static_cast<>将失败，而reinterpret_cast<>就总是成功“欺骗”编译器：那个对象就是那个无关类。但是在运行的时候由于编译器对被转换的对象会发生错误的解释, 程序会crash掉.\n\n# 情况2：转换到相关的类\n\ncderived* pd = new cderived();\nprintf("cderived* pd = %x/n", (int)pd);\n// static_cast<> cderived* -> cbasey* -> cderived*\ncbasey* py1 = pd; //成功编译，隐式static_cast<>转换\nprintf("cbasey* py1 = %x/n", (int)py1);\n\ncderived* pd1 = static_cast<cderived*>(py1);// 成功编译, 现在 pd1 = pd\nprintf("cderived* pd1 = %x/n", (int)pd1);\n// reinterpret_cast\ncbasey* py2 = reinterpret_cast<cbasey*>(pd);// 成功编译, 但是 py2 不是 cbasey*\nprintf("cbasey* py2 = %x/n", (int)py2);\n\n// 无关的 static_cast<>\ncbasey* py3 = new cbasey();\nprintf("cbasey* py3 = %x/n", (int)py3);\n\ncderived* pd3 = static_cast<cderived*>(py3);// 成功编译,尽管 py3 只是一个 "新 cbasey()"\nprintf("cderived* pd3 = %x/n", (int)pd3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n---------------------- output ---------------------------\n\ncderived* pd = 392fb8\n\ncbasey* py1 = 392fbc\n\ncderived* pd1 = 392fb8\n\ncbasey* py2 = 392fb8\n\ncbasey* py3 = 390ff0\n\ncderived* pd3 = 390fec\n\n注意：在将cderived用隐式 static_cast<>转换到cbasey(第5行)时，结果是(指向)cderived*(的指针向后) 偏移了4(个字节)(译注：4为int类型在内存中所占字节数)。为了知道static_cast<> 实际如何，我们不得不要来看一下cderived的内存布局。\n\ncderived的内存布局包括两个对象，cbasex 和 cbasey，编译器也知道这一点。因此，当将cderived* 转换到 cbasey时，它给指针添加4个字节，同时当你将cbasey转换到cderived*时，它给指针减去4。然而，甚至它即便不是一个cderived你也可以这样做。\n\n当然，这个问题只在如果你做了多继承时发生。在你将cderived转换 到 cbasex时static_cast<> 和 reinterpret_cast<>是没有区别的。\n\n# 情况3：void之间的向前和向后转换\n\n因为任何指针可以被转换到void，而void*可以被向后转换到任何指针(对于static_cast<> 和 reinterpret_cast<>转换都可以这样做)，如果没有小心处理的话错误可能发生。\n\ncderived* pd = new cderived();\nprintf("cderived* pd = %x/n", (int)pd);\ncbasey* py = pd; // 成功编译, py = pd + 4\nprintf("cbasey* py = %x/n", (int)py);\nvoid* pv1 = py; //成功编译, pv1 = py\nprintf("void* pv1 = %x/n", (int)pv1);\n// pd2 = py, 但是我们预期 pd2 = py - 4\ncderived* pd2 = static_cast<cderived*>(pv1);\nprintf("cderived* pd2 = %x/n", (int)pd2);\n// pd2->bar();// 系统崩溃\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n---------------------- 输出 ---------------------------\n\ncderived* pd = 392fb8\n\ncbasey* py = 392fbc\n\nvoid* pv1 = 392fbcd\n\ncderived* pd2 = 392fbc\n\n一旦我们已经转换指针为void，我们就不能轻易将其转换回原类。在上面的例子中，从一个void 返回cderived的唯一方法是将其转换为cbasey然后再转换为cderived。 但是如果我们不能确定它是cbasey* 还是 cderived*，这时我们不得不用dynamic_cast<> 或typeid[2]。\n\n注释：\n\n 1. dynamic_cast<>, 从另一方面来说，可以防止一个泛型cbasey* 被转换到cderived*。\n\n 2. dynamic_cast<>, 需要类成为多态，即包括“虚”函数，并因此而不能成为void*。',charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"pointer",frontmatter:{title:"pointer",date:"2022-06-27T08:07:28.000Z",categories:["C++"],tags:[null],permalink:"/pages/c08a6e/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/06.pointer.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/06.pointer.md",key:"v-9b512a1a",path:"/pages/c08a6e/",headers:[{level:2,title:"引用与指针那些事",slug:"引用与指针那些事",normalizedTitle:"引用与指针那些事",charIndex:2},{level:2,title:"函数指针和指针函数",slug:"函数指针和指针函数",normalizedTitle:"函数指针和指针函数",charIndex:15}],headersStr:"引用与指针那些事 函数指针和指针函数",content:'# 引用与指针那些事\n\n\n# 函数指针和指针函数\n\n#include <iostream>\nusing namespace std;\n/*! \\brief Possible kinds of TypeVars. */\nenum TypeKind {\n\n kType = 0,\n /*! \\brief Template variable in shape expression. */\n kShapeVar = 1,\n kBaseType = 2,\n kConstraint = 4,\n kAdtHandle = 5,\n kTypeData = 6\n};\n\nunion TypeValue {\n char c;\n unsigned char uc;\n long l;\n};\n\nconst double* f1(const double arr[], int n) { return arr; }\nconst double* f2(const double arr[], int n) { return arr + 1; }\nconst double* f3(const double* arr, int n) { return arr + 2; }\n\nint main(int argc, char* argv[]) {\n TypeKind a = kShapeVar;\n TypeValue b;\n b.c = \'L\';\n cout << "test for union:b.c " << b.c << endl;\n\n b.l = 1234;\n cout << "test for union:b.l " << b.l << endl;\n cout << "test for union:b.c " << b.c << endl;\n\n double at[3] = {12.1, 3.4, 4.5};\n const double* (*pfunc)(const double*, int) = f1;\n cout << "test for function pointer: Point1: " << *pfunc(at, 3) << endl;\n\n const double* (*pfunc1[3])(const double*, int) = {f1, f2, f3};\n cout << "test for function pointer: Point1: " << *pfunc1[2](at, 3) << endl;\n cout << "test for function pointer: Point12: " << *pfunc1[0](at, 3) << endl;\n cout << "test for function pointer: Point1: " << *((*pfunc1[2])(at, 3)) << endl;\n cout << "test for enum: " << a << endl;\n\n cout << "hello word" << endl;\n\n\n\n cout << "test for singleton";\n\n return 0;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n',normalizedContent:'# 引用与指针那些事\n\n\n# 函数指针和指针函数\n\n#include <iostream>\nusing namespace std;\n/*! \\brief possible kinds of typevars. */\nenum typekind {\n\n ktype = 0,\n /*! \\brief template variable in shape expression. */\n kshapevar = 1,\n kbasetype = 2,\n kconstraint = 4,\n kadthandle = 5,\n ktypedata = 6\n};\n\nunion typevalue {\n char c;\n unsigned char uc;\n long l;\n};\n\nconst double* f1(const double arr[], int n) { return arr; }\nconst double* f2(const double arr[], int n) { return arr + 1; }\nconst double* f3(const double* arr, int n) { return arr + 2; }\n\nint main(int argc, char* argv[]) {\n typekind a = kshapevar;\n typevalue b;\n b.c = \'l\';\n cout << "test for union:b.c " << b.c << endl;\n\n b.l = 1234;\n cout << "test for union:b.l " << b.l << endl;\n cout << "test for union:b.c " << b.c << endl;\n\n double at[3] = {12.1, 3.4, 4.5};\n const double* (*pfunc)(const double*, int) = f1;\n cout << "test for function pointer: point1: " << *pfunc(at, 3) << endl;\n\n const double* (*pfunc1[3])(const double*, int) = {f1, f2, f3};\n cout << "test for function pointer: point1: " << *pfunc1[2](at, 3) << endl;\n cout << "test for function pointer: point12: " << *pfunc1[0](at, 3) << endl;\n cout << "test for function pointer: point1: " << *((*pfunc1[2])(at, 3)) << endl;\n cout << "test for enum: " << a << endl;\n\n cout << "hello word" << endl;\n\n\n\n cout << "test for singleton";\n\n return 0;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n',charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"static",frontmatter:{title:"static",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/9b131d/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/07.static.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/07.static.md",key:"v-a31e7cfa",path:"/pages/9b131d/",headers:[{level:2,title:"C 语言中的 static:",slug:"c-语言中的-static",normalizedTitle:"c 语言中的 static:",charIndex:184},{level:3,title:"static 全局变量",slug:"static-全局变量",normalizedTitle:"static 全局变量",charIndex:396},{level:3,title:"static 局部变量",slug:"static-局部变量",normalizedTitle:"static 局部变量",charIndex:2056},{level:3,title:"static 函数",slug:"static-函数",normalizedTitle:"static 函数",charIndex:2739},{level:2,title:"C++类的static成员变量:",slug:"c-类的static成员变量",normalizedTitle:"c++类的static成员变量:",charIndex:3080},{level:3,title:"成员变量的几种情况:",slug:"成员变量的几种情况",normalizedTitle:"成员变量的几种情况:",charIndex:4866},{level:4,title:"静态变量",slug:"静态变量",normalizedTitle:"静态变量",charIndex:214},{level:4,title:"常量",slug:"常量",normalizedTitle:"常量",charIndex:4454},{level:4,title:"引用变量",slug:"引用变量",normalizedTitle:"引用变量",charIndex:5155},{level:4,title:"静态常量",slug:"静态常量",normalizedTitle:"静态常量",charIndex:5231},{level:4,title:"static member var.：",slug:"static-member-var",normalizedTitle:"static member var.：",charIndex:5397},{level:4,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:6579},{level:2,title:"C++ 类的Static成员函数",slug:"c-类的static成员函数",normalizedTitle:"c++ 类的static成员函数",charIndex:6718},{level:2,title:"拷贝构造函数的问题",slug:"拷贝构造函数的问题",normalizedTitle:"拷贝构造函数的问题",charIndex:8970}],excerpt:"<p>static关键字的含义， example以及程序底层的数据划分</p>\n",headersStr:"C 语言中的 static: static 全局变量 static 局部变量 static 函数 C++类的static成员变量: 成员变量的几种情况: 静态变量 常量 引用变量 静态常量 static member var.： 优点 C++ 类的Static成员函数 拷贝构造函数的问题",content:'static关键字的含义， example以及程序底层的数据划分\n\n这里是cpp reference上面static关键字的链接： https://en.cppreference.com/w/cpp/keyword/static\n\n从汇编层面， 解释static变量是存在于什么地方， 存在于什么样代码段或者数据段上面？ (这涉及到汇编和编译的更细节的知识)\n\n\n# C 语言中的 static:\n\n修饰函数内部变量，即函数内的静态变量。这种变量的生存期长于该函数，使得函数具有一定的“状态”。使用静态变量的函数一般是不可重入的，也不是线程安全的，比如strtok(3)。\n\n在函数体之外，修饰全局变量或函数，表示该变量或函数只在本文件可见，其他文件看不到也访问不到该变量或函数。专业的说法叫“具有internal linkage”（不暴露给别的translation unit）。\n\n\n# static 全局变量\n\n//Example 1\n#include <iostream.h> \n\nvoid fn();\nstatic int n=5;    // 静态全局变量 \nint j = 3;  // 默认为extern， 全局变量\nvoid main()\n{\n\tn=20;\n\tcout<<n<<endl;\n\tfn();\n} \n\nvoid fn()\n{\n\tn++;\n\tcout<<n<<endl;\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nstatic 修饰全局变量，限制该变量的作用域为当前文件，就是说这个变量能在当前文件中作为全局变量被访问，但不能再其他文件中被访问\n\n全局变量 j 和静态变量 i 都存放于程序的全局数据区域，它们的生存周期都是程序的整个运行期，但是 j 在函数外定义， 是一个全局变量，可以通过extern在其他文件中使用，而 i 的使用的static修饰，只能在file A中使用，例如在file B中：\n\nextern int j; //OK\nextern int i; // error: i在文件B中不可见， 只在 file A 中可见\nint a = j; // OK\nint b = i; // error\n\n\n1\n2\n3\n4\n\n\n也就是说，在声明全局的static变量时，static没有改变它的生存周期，也即存储位置（因为全局变量本来就存储在全局数据域），而是将变量的作用域限制在当前文件中。\n\n静态全局变量有以下特点：\n\n 1. 该变量在全局数据区分配内存；\n    \n    \n\n 2. 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；\n\n 3. 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；\n\n 4. 静态变量都在全局数据区分配内存，包括静态局部/全局变量。对于一个完整的程序，在内存中的分布情况如上图，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区。**自动变量一般会随着函数的退出而释放空间，**而全局数据区的数据并不会因为函数的退出而释放空间。\n\nExample 1中的代码中将\n\nstatic int n=5; // 定义静态全局变量\n\n\n1\n\n\n改为\n\nint n=; // 定义全局变量\n\n\n1\n\n\n程序照样正常运行。 定义全局变量就可以实现变量在文件中的共享，但静态全局变量还有以下好处：\n\n 1. 静态全局变量不能被其它文件所用；\n 2. 其它文件中可以定义相同名字的变量，不会发生冲突；\n\n将上述示例代码改为如下：\n\n//Example 2\n//File A\n#include <iostream.h> \n\nvoid fn();\nstatic int n; //定义静态全局变量 \n\nvoid main()\n{\n\tn=20;\n\tcout<<n<<endl;\n\tfn();\n} \n\n//File B\n#include <iostream.h> \nextern int n;\nvoid fn()\n{\n\tn++;\n\tcout<<n<<endl;\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n编译并运行Example 2，会发现上述代码可以分别通过编译，但运行时出现错误。 这就是因为静态全局变量不能被其它文件所用，即使在其它文件中使用extern 进行声明也不行。\n\n我们将\n\nstatic int n; //定义静态全局变量\n\n\n1\n\n\n改为\n\nint n; //定义全局变量\n\n\n1\n\n\n再次编译运行程序，程序可正常运行。\n\n因此，在一个文件中，静态全局变量和全局变量功能相同；而在两个文件中，要使用同一个变量，则只能使用全局变量而不能使用静态全局变量。\n\n\n# static 局部变量\n\n//Example 3\n#include <iostream.h>\nvoid fn();  // forward declaration\nvoid main()\n{\n\tfn(); //10\n\tfn(); //11\n\tfn(); //12\n}\n\nvoid fn()\n{\n\tstatic n=10; // 函数体内部的变量叫局部变量，加上关键字static，就成为一个静态局部变量。\n\tcout<<n<<endl;\n\tn++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n在函数体内的变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。\n\n但有时候我们需要在两次调用同一个函数的时候对变量的值进行保存和处理。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制。\n\n静态局部变量可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。\n\nstatic 局部变量特点：\n\n 1. 静态局部变量在全局数据区分配内存；\n 2. 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；\n 3. 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；\n 4. 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；\n\n\n# static 函数\n\n在函数的返回类型前加上static关键字, 函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。\n\n//Example 4\n#include <iostream.h>\nstatic void fn();//声明静态函数\n\nvoid main()\n{\n    fn();\n}\n\nvoid fn()//定义静态函数\n{\n    int n=10;\n    cout<<n<<endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nstatic 函数特点：（类似于静态全局变量）\n\n 1. 静态函数不能被其它文件所用；\n 2. 其它文件中可以定义相同名字的函数，不会发生冲突；\n\n\n# C++类的static成员变量:\n\n在类内成员变量的声明前加上关键字static，该数据成员就成为类内的静态数据成员。\n\n//Example 5\n#include <iostream.h>\nclass Myclass\n{\npublic:\n\tMyclass(int a,int b,int c);\n\tvoid GetSum();\nprivate:\n\tint a,b,c;\n\tstatic int Sum;   //声明静态数据成员\n};\n\nint Myclass::Sum=0;    //定义并初始化静态数据成员\n\nMyclass::Myclass(int a,int b,int c)\n{\n\tthis->a=a;\n\tthis->b=b;\n\tthis->c=c;\n\tSum+=a+b+c;\n}\n\nvoid Myclass::GetSum()\n{\n\tcout<<"Sum="<<Sum<<endl;\n}\n\nvoid main()\n{\n\tMyclass M(1,2,3);\n\tM.GetSum();\n\tMyclass N(4,5,6);\n\tN.GetSum();\n\tM.GetSum();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n何时采用静态数据成员？\n\n设置静态成员（变量和函数）这种机制的目的是将某些和类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于理解和维护。**如果想在同类的多个对象之间实现数据共享，又不要用全局变量，那么就可以使用静态成员变量。**也即，静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处：\n\n 1. 不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，节省存储空间。\n 2. 一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。\n\n你也许会问，用全局变量不是也可以达到这个效果吗？\n\n同全局变量相比，使用静态数据成员有两个优势：\n\n 1. 静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。\n 2. 可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。\n\n用于修饰类的数据成员，即所谓“静态成员”。这种数据成员的生存期大于class的对象（实例/instance）。静态数据成员是每个class有一份，普通数据成员是每个instance 有一份。\n\nclass CTypeInit{\n    public:\n    \tCTypeInit(int c) : m_c(c),m_ra(c) { }\n    private:\n        int m_a;          //通过初始化列表初始化，或者构造函数初始化\n        /*引用*/\n        int &m_ra;        //只能通过初始化列表初始化\n        /*静态变量*/\n        static int m_b;            \n        /*常量*/\n        const int m_c;            \n\n        /*静态整型常量*/\n        static const int m_d;    \n        /*静态非整型常量*/\n        static const double m_e;\n};\n\n//静态成员变量，必须在类外初始化,且要去掉static关键字\nint CTypeInit::m_b = 6;\nconst int CTypeInit::m_d = 6;\nconst double CTypeInit::m_e = 3.1415926;\n\nint main()\n{\n    CTypeInit obT(2);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 成员变量的几种情况:\n\n# 静态变量\n\nstatic int m_b;\n\n\n1\n\n\nstatic成员变量需要在类定义体外进行初始化与定义，因为static数据成员独立该类的任意对象存在，它是与类关联的对象，不与类对象关联。例如：上述程序中的c变量的初始化。\n\n 1. 只能在类外初始化\n 2. 不能通过初始化列表初始化，\n 3. 不能在类内进行初始化，\n 4. 不能在构造函数中初始化，\n\n# 常量\n\nconst int m_c;\n\n\n1\n\n\n 1. 只能通过初始化列表初始化\n\n 2. 不能在类内进行初始化\n\n 3. 不能在构造函数中初始化\n\n 4. 不能在类外初始化\n\n# 引用变量\n\nint &m_ra;\n\n\n1\n\n\n只能通过初始化列表初始化且必须用变量初始化，不能在类的定义外（内）初始化，不能通过构造函数初始化。\n\n# 静态常量\n\nstatic const int m_d;\n\n\n1\n\n 1. 能否在类中初始化，取决于编译器\n 2. 能在在类外初始化，但不能带static\n\n类的静态成员属于类作用域，但不属于类对象，它的生命周期和普通的全局静态变量一样，程序运行时进行分配内存和初始化，程序结束时则被释放。所以不能在类的构造函数中进行初始化。\n\n# static member var.：\n\n 1.  静态成员变量是该类的所有对象所共有的。对于普通成员变量，每个类对象都有自己的一份拷贝。而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；\n\n 2.  因为静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它；\n\n 3.  静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。在Example 5中，语句int Myclass::Sum=0;是定义并初始化静态成员变量。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。\n\n 4.  static 成员变量和普通 static 变量一样，编译时在静态数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。\n\n 5.  静态数据成员初始化与一般数据成员初始化不同。初始化时可以不加 static，但必须要有数据类型。被 private、protected、public 修饰的 static 成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞\n\n 6.  类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名＞\n\n 7.  类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问。\n\n 8.  静态数据成员和普通数据成员一样遵从public,protected,private访问规则；\n\n 9.  如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；\n\n 10. sizeof 运算符不会计算 静态成员变量。\n     \n     class CMyclass{\n         int n;\n         static int s;\n     };    //则sizeof（CMyclass）等于4\n     \n     \n     1\n     2\n     3\n     4\n     \n\n# 优点\n\n 1. static成员的名字是在类的作用域中，因此可以避免与其它类成员或全局对象名字冲突。\n 2. 可以实施封装，static成员可以是私有的，而全局对象不可以。\n 3. 阅读程序容易看出static成员与某个类相关联，这种可见性可以清晰地反映程序员的意图。\n\n\n# C++ 类的Static成员函数\n\n静态成员函数为类服务而不是为某一个类的具体对象服务。静态成员函数与静态成员变量一样，都是类的内部实现，属于类定义的一部分。普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。\n\n普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体地属于类的某个具体对象的。当函数被调用时，系统会把当前对象的起始地址赋给 this 指针。通常情况下，this是缺省的。如函数fn()实际上是this->fn()。\n\n与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。从另一个角度来看，由于静态成员函数和静态成员变量在类实例化之前就已经存在可以访问，而此时非静态成员还是不存在的，因此静态成员不能访问非静态成员。\n\n//Example 6\n#include <iostream>\nusing namespace std;\n\nclass Student{\nprivate:\n   char *name;\n   int age;\n   float score;\n   static int num;  \t//学生人数\n   static float total;  //总分\npublic:\n   Student(char *, int, float);\n   void say();\n   static float getAverage();  //静态成员函数，用来获得平均成绩\n};\n\nint Student::num = 0;\nfloat Student::total = 0;\n\nStudent::Student(char *name, int age, float score)\n{\n   this->name = name;\n   this->age = age;\n   this->score = score;\n   num++;\n   total += score;\n}\n\nvoid Student::say()\n{\n   cout<<name<<"的年龄是 "<<age<<"，成绩是 "<<score<<"（当前共"<<num<<"名学生）"<<endl;\n}\n\nfloat Student::getAverage()\n{\n   return total / num;\n}\n\nint main()\n{\n   (new Student("小明", 15, 90))->say();\n   (new Student("李磊", 16, 80))->say();\n   (new Student("张华", 16, 99))->say();\n   (new Student("王康", 14, 60))->say();\n   cout<<"平均成绩为 "<<Student::getAverage()<<endl;\n   return 0;\n}\n\n运行结果：\n小明的年龄是 15，成绩是 90（当前共1名学生）\n李磊的年龄是 16，成绩是 80（当前共2名学生）\n张华的年龄是 16，成绩是 99（当前共3名学生）\n王康的年龄是 14，成绩是 60（当前共4名学生）\n平均成绩为 82.25\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n静态成员函数的特点：\n\n 1. 出现在类外的函数定义不能指定关键字static；\n 2. 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而静态成员函数（仅）可以访问static成员变量、static成员函数。\n 3. 因为static成员函数没有this指针，所以静态成员函数不可以访问非静态成员。\n 4. 静态数据成员与类的大小无关，因为静态成员只是作用在类的范围而已。\n 5. 非静态成员函数可以任意地访问静态成员函数和静态数据成员；\n 6. 由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；\n 7. 调用静态成员函数，两种方式：\n\n * 通过成员访问操作符(.)和(->)，也即通过类对象或指向类对象的指针调用静态成员函数。\n * 直接通过类来调用静态成员函数。＜类名＞::＜静态成员函数名＞（＜参数表＞）。也即，静态成员不需要通过对象就能访问。\n\n成员函数特点：\n\n 1. 函数体内作用范围为该函数体，该变量内存只被分配一次，具有记忆能力（内存分配在静态区，在第一次调用的时候分配内存，函数调用结束内存并不释放）\n 2. 在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；（模块，{}括起来的语句块都是，不同的文件也是不同的模块）\n 3. 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；\n 4. 在类中的static成员变量属于整个类所拥有，对类的所有实例只有一份拷贝；\n\n\n# 拷贝构造函数的问题\n\n在使用包含静态成员的类时，有时候会调用拷贝构造函数生成临时的隐藏的类对象，而这个临时对象在消亡时会调用析构函数有可能会对静态变量做操作（例如total_num--），可是这些对象在生成时却没有执行构造函数中的total_num++的操作。解决方案是为这个类写一个拷贝构造函数，在该拷贝构造函数中完成total_num++的操作。\n\n#include <iostream>\nusing namespace std;\nclass test2\n{\n    public:\n        test2(int num) : y(num){}\n        ~test2(){}\n\n        static void testStaticFun()\n        {\n            cout << "y = " << y << endl;     // Error:静态成员函数不能访问非静态成员， static成员函数没有this指针\n        }\n\n        void testFun()\n        {\n            cout << "x = " << x << endl; \n        }\n    private:\n        static int x;   // 静态成员变量的引用性说明\n        int y;\n};\n\nint test2::x = 10;      // 静态成员变量的定义性说明\nint main(void)\n{\n    test2 t(100);\n    t.testFun();\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n静态整型常量和静态非整形常量在类定义内部初始化时，在VC6.0中都不能编译通过，而在GCC中都可以编译通过，在不同编译器下有不同的结果，但前三个是确定的。当然，如果不习惯类内初始化，可以将静态常量和静态变量的初始化统一起来，将静态常量和静态变量的初始化全部都移动类定义之外初始化（推荐使用这种方式）。另外，如果编译器不支持类内初始化，而此时类在编译期又恰恰需要定义的成员常量的值，身出如此左右为难的境地，我们应该考虑使用enum！因为enum 本质也是一个整型常量。',normalizedContent:'static关键字的含义， example以及程序底层的数据划分\n\n这里是cpp reference上面static关键字的链接： https://en.cppreference.com/w/cpp/keyword/static\n\n从汇编层面， 解释static变量是存在于什么地方， 存在于什么样代码段或者数据段上面？ (这涉及到汇编和编译的更细节的知识)\n\n\n# c 语言中的 static:\n\n修饰函数内部变量，即函数内的静态变量。这种变量的生存期长于该函数，使得函数具有一定的“状态”。使用静态变量的函数一般是不可重入的，也不是线程安全的，比如strtok(3)。\n\n在函数体之外，修饰全局变量或函数，表示该变量或函数只在本文件可见，其他文件看不到也访问不到该变量或函数。专业的说法叫“具有internal linkage”（不暴露给别的translation unit）。\n\n\n# static 全局变量\n\n//example 1\n#include <iostream.h> \n\nvoid fn();\nstatic int n=5;    // 静态全局变量 \nint j = 3;  // 默认为extern， 全局变量\nvoid main()\n{\n\tn=20;\n\tcout<<n<<endl;\n\tfn();\n} \n\nvoid fn()\n{\n\tn++;\n\tcout<<n<<endl;\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nstatic 修饰全局变量，限制该变量的作用域为当前文件，就是说这个变量能在当前文件中作为全局变量被访问，但不能再其他文件中被访问\n\n全局变量 j 和静态变量 i 都存放于程序的全局数据区域，它们的生存周期都是程序的整个运行期，但是 j 在函数外定义， 是一个全局变量，可以通过extern在其他文件中使用，而 i 的使用的static修饰，只能在file a中使用，例如在file b中：\n\nextern int j; //ok\nextern int i; // error: i在文件b中不可见， 只在 file a 中可见\nint a = j; // ok\nint b = i; // error\n\n\n1\n2\n3\n4\n\n\n也就是说，在声明全局的static变量时，static没有改变它的生存周期，也即存储位置（因为全局变量本来就存储在全局数据域），而是将变量的作用域限制在当前文件中。\n\n静态全局变量有以下特点：\n\n 1. 该变量在全局数据区分配内存；\n    \n    \n\n 2. 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；\n\n 3. 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；\n\n 4. 静态变量都在全局数据区分配内存，包括静态局部/全局变量。对于一个完整的程序，在内存中的分布情况如上图，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区。**自动变量一般会随着函数的退出而释放空间，**而全局数据区的数据并不会因为函数的退出而释放空间。\n\nexample 1中的代码中将\n\nstatic int n=5; // 定义静态全局变量\n\n\n1\n\n\n改为\n\nint n=; // 定义全局变量\n\n\n1\n\n\n程序照样正常运行。 定义全局变量就可以实现变量在文件中的共享，但静态全局变量还有以下好处：\n\n 1. 静态全局变量不能被其它文件所用；\n 2. 其它文件中可以定义相同名字的变量，不会发生冲突；\n\n将上述示例代码改为如下：\n\n//example 2\n//file a\n#include <iostream.h> \n\nvoid fn();\nstatic int n; //定义静态全局变量 \n\nvoid main()\n{\n\tn=20;\n\tcout<<n<<endl;\n\tfn();\n} \n\n//file b\n#include <iostream.h> \nextern int n;\nvoid fn()\n{\n\tn++;\n\tcout<<n<<endl;\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n编译并运行example 2，会发现上述代码可以分别通过编译，但运行时出现错误。 这就是因为静态全局变量不能被其它文件所用，即使在其它文件中使用extern 进行声明也不行。\n\n我们将\n\nstatic int n; //定义静态全局变量\n\n\n1\n\n\n改为\n\nint n; //定义全局变量\n\n\n1\n\n\n再次编译运行程序，程序可正常运行。\n\n因此，在一个文件中，静态全局变量和全局变量功能相同；而在两个文件中，要使用同一个变量，则只能使用全局变量而不能使用静态全局变量。\n\n\n# static 局部变量\n\n//example 3\n#include <iostream.h>\nvoid fn();  // forward declaration\nvoid main()\n{\n\tfn(); //10\n\tfn(); //11\n\tfn(); //12\n}\n\nvoid fn()\n{\n\tstatic n=10; // 函数体内部的变量叫局部变量，加上关键字static，就成为一个静态局部变量。\n\tcout<<n<<endl;\n\tn++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n在函数体内的变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。\n\n但有时候我们需要在两次调用同一个函数的时候对变量的值进行保存和处理。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制。\n\n静态局部变量可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。\n\nstatic 局部变量特点：\n\n 1. 静态局部变量在全局数据区分配内存；\n 2. 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；\n 3. 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；\n 4. 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；\n\n\n# static 函数\n\n在函数的返回类型前加上static关键字, 函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。\n\n//example 4\n#include <iostream.h>\nstatic void fn();//声明静态函数\n\nvoid main()\n{\n    fn();\n}\n\nvoid fn()//定义静态函数\n{\n    int n=10;\n    cout<<n<<endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nstatic 函数特点：（类似于静态全局变量）\n\n 1. 静态函数不能被其它文件所用；\n 2. 其它文件中可以定义相同名字的函数，不会发生冲突；\n\n\n# c++类的static成员变量:\n\n在类内成员变量的声明前加上关键字static，该数据成员就成为类内的静态数据成员。\n\n//example 5\n#include <iostream.h>\nclass myclass\n{\npublic:\n\tmyclass(int a,int b,int c);\n\tvoid getsum();\nprivate:\n\tint a,b,c;\n\tstatic int sum;   //声明静态数据成员\n};\n\nint myclass::sum=0;    //定义并初始化静态数据成员\n\nmyclass::myclass(int a,int b,int c)\n{\n\tthis->a=a;\n\tthis->b=b;\n\tthis->c=c;\n\tsum+=a+b+c;\n}\n\nvoid myclass::getsum()\n{\n\tcout<<"sum="<<sum<<endl;\n}\n\nvoid main()\n{\n\tmyclass m(1,2,3);\n\tm.getsum();\n\tmyclass n(4,5,6);\n\tn.getsum();\n\tm.getsum();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n何时采用静态数据成员？\n\n设置静态成员（变量和函数）这种机制的目的是将某些和类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于理解和维护。**如果想在同类的多个对象之间实现数据共享，又不要用全局变量，那么就可以使用静态成员变量。**也即，静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处：\n\n 1. 不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，节省存储空间。\n 2. 一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。\n\n你也许会问，用全局变量不是也可以达到这个效果吗？\n\n同全局变量相比，使用静态数据成员有两个优势：\n\n 1. 静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。\n 2. 可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。\n\n用于修饰类的数据成员，即所谓“静态成员”。这种数据成员的生存期大于class的对象（实例/instance）。静态数据成员是每个class有一份，普通数据成员是每个instance 有一份。\n\nclass ctypeinit{\n    public:\n    \tctypeinit(int c) : m_c(c),m_ra(c) { }\n    private:\n        int m_a;          //通过初始化列表初始化，或者构造函数初始化\n        /*引用*/\n        int &m_ra;        //只能通过初始化列表初始化\n        /*静态变量*/\n        static int m_b;            \n        /*常量*/\n        const int m_c;            \n\n        /*静态整型常量*/\n        static const int m_d;    \n        /*静态非整型常量*/\n        static const double m_e;\n};\n\n//静态成员变量，必须在类外初始化,且要去掉static关键字\nint ctypeinit::m_b = 6;\nconst int ctypeinit::m_d = 6;\nconst double ctypeinit::m_e = 3.1415926;\n\nint main()\n{\n    ctypeinit obt(2);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 成员变量的几种情况:\n\n# 静态变量\n\nstatic int m_b;\n\n\n1\n\n\nstatic成员变量需要在类定义体外进行初始化与定义，因为static数据成员独立该类的任意对象存在，它是与类关联的对象，不与类对象关联。例如：上述程序中的c变量的初始化。\n\n 1. 只能在类外初始化\n 2. 不能通过初始化列表初始化，\n 3. 不能在类内进行初始化，\n 4. 不能在构造函数中初始化，\n\n# 常量\n\nconst int m_c;\n\n\n1\n\n\n 1. 只能通过初始化列表初始化\n\n 2. 不能在类内进行初始化\n\n 3. 不能在构造函数中初始化\n\n 4. 不能在类外初始化\n\n# 引用变量\n\nint &m_ra;\n\n\n1\n\n\n只能通过初始化列表初始化且必须用变量初始化，不能在类的定义外（内）初始化，不能通过构造函数初始化。\n\n# 静态常量\n\nstatic const int m_d;\n\n\n1\n\n 1. 能否在类中初始化，取决于编译器\n 2. 能在在类外初始化，但不能带static\n\n类的静态成员属于类作用域，但不属于类对象，它的生命周期和普通的全局静态变量一样，程序运行时进行分配内存和初始化，程序结束时则被释放。所以不能在类的构造函数中进行初始化。\n\n# static member var.：\n\n 1.  静态成员变量是该类的所有对象所共有的。对于普通成员变量，每个类对象都有自己的一份拷贝。而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；\n\n 2.  因为静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它；\n\n 3.  静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。在example 5中，语句int myclass::sum=0;是定义并初始化静态成员变量。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。\n\n 4.  static 成员变量和普通 static 变量一样，编译时在静态数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。\n\n 5.  静态数据成员初始化与一般数据成员初始化不同。初始化时可以不加 static，但必须要有数据类型。被 private、protected、public 修饰的 static 成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞\n\n 6.  类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名＞\n\n 7.  类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问。\n\n 8.  静态数据成员和普通数据成员一样遵从public,protected,private访问规则；\n\n 9.  如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；\n\n 10. sizeof 运算符不会计算 静态成员变量。\n     \n     class cmyclass{\n         int n;\n         static int s;\n     };    //则sizeof（cmyclass）等于4\n     \n     \n     1\n     2\n     3\n     4\n     \n\n# 优点\n\n 1. static成员的名字是在类的作用域中，因此可以避免与其它类成员或全局对象名字冲突。\n 2. 可以实施封装，static成员可以是私有的，而全局对象不可以。\n 3. 阅读程序容易看出static成员与某个类相关联，这种可见性可以清晰地反映程序员的意图。\n\n\n# c++ 类的static成员函数\n\n静态成员函数为类服务而不是为某一个类的具体对象服务。静态成员函数与静态成员变量一样，都是类的内部实现，属于类定义的一部分。普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。\n\n普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体地属于类的某个具体对象的。当函数被调用时，系统会把当前对象的起始地址赋给 this 指针。通常情况下，this是缺省的。如函数fn()实际上是this->fn()。\n\n与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。从另一个角度来看，由于静态成员函数和静态成员变量在类实例化之前就已经存在可以访问，而此时非静态成员还是不存在的，因此静态成员不能访问非静态成员。\n\n//example 6\n#include <iostream>\nusing namespace std;\n\nclass student{\nprivate:\n   char *name;\n   int age;\n   float score;\n   static int num;  \t//学生人数\n   static float total;  //总分\npublic:\n   student(char *, int, float);\n   void say();\n   static float getaverage();  //静态成员函数，用来获得平均成绩\n};\n\nint student::num = 0;\nfloat student::total = 0;\n\nstudent::student(char *name, int age, float score)\n{\n   this->name = name;\n   this->age = age;\n   this->score = score;\n   num++;\n   total += score;\n}\n\nvoid student::say()\n{\n   cout<<name<<"的年龄是 "<<age<<"，成绩是 "<<score<<"（当前共"<<num<<"名学生）"<<endl;\n}\n\nfloat student::getaverage()\n{\n   return total / num;\n}\n\nint main()\n{\n   (new student("小明", 15, 90))->say();\n   (new student("李磊", 16, 80))->say();\n   (new student("张华", 16, 99))->say();\n   (new student("王康", 14, 60))->say();\n   cout<<"平均成绩为 "<<student::getaverage()<<endl;\n   return 0;\n}\n\n运行结果：\n小明的年龄是 15，成绩是 90（当前共1名学生）\n李磊的年龄是 16，成绩是 80（当前共2名学生）\n张华的年龄是 16，成绩是 99（当前共3名学生）\n王康的年龄是 14，成绩是 60（当前共4名学生）\n平均成绩为 82.25\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n静态成员函数的特点：\n\n 1. 出现在类外的函数定义不能指定关键字static；\n 2. 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而静态成员函数（仅）可以访问static成员变量、static成员函数。\n 3. 因为static成员函数没有this指针，所以静态成员函数不可以访问非静态成员。\n 4. 静态数据成员与类的大小无关，因为静态成员只是作用在类的范围而已。\n 5. 非静态成员函数可以任意地访问静态成员函数和静态数据成员；\n 6. 由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；\n 7. 调用静态成员函数，两种方式：\n\n * 通过成员访问操作符(.)和(->)，也即通过类对象或指向类对象的指针调用静态成员函数。\n * 直接通过类来调用静态成员函数。＜类名＞::＜静态成员函数名＞（＜参数表＞）。也即，静态成员不需要通过对象就能访问。\n\n成员函数特点：\n\n 1. 函数体内作用范围为该函数体，该变量内存只被分配一次，具有记忆能力（内存分配在静态区，在第一次调用的时候分配内存，函数调用结束内存并不释放）\n 2. 在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；（模块，{}括起来的语句块都是，不同的文件也是不同的模块）\n 3. 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；\n 4. 在类中的static成员变量属于整个类所拥有，对类的所有实例只有一份拷贝；\n\n\n# 拷贝构造函数的问题\n\n在使用包含静态成员的类时，有时候会调用拷贝构造函数生成临时的隐藏的类对象，而这个临时对象在消亡时会调用析构函数有可能会对静态变量做操作（例如total_num--），可是这些对象在生成时却没有执行构造函数中的total_num++的操作。解决方案是为这个类写一个拷贝构造函数，在该拷贝构造函数中完成total_num++的操作。\n\n#include <iostream>\nusing namespace std;\nclass test2\n{\n    public:\n        test2(int num) : y(num){}\n        ~test2(){}\n\n        static void teststaticfun()\n        {\n            cout << "y = " << y << endl;     // error:静态成员函数不能访问非静态成员， static成员函数没有this指针\n        }\n\n        void testfun()\n        {\n            cout << "x = " << x << endl; \n        }\n    private:\n        static int x;   // 静态成员变量的引用性说明\n        int y;\n};\n\nint test2::x = 10;      // 静态成员变量的定义性说明\nint main(void)\n{\n    test2 t(100);\n    t.testfun();\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n静态整型常量和静态非整形常量在类定义内部初始化时，在vc6.0中都不能编译通过，而在gcc中都可以编译通过，在不同编译器下有不同的结果，但前三个是确定的。当然，如果不习惯类内初始化，可以将静态常量和静态变量的初始化统一起来，将静态常量和静态变量的初始化全部都移动类定义之外初始化（推荐使用这种方式）。另外，如果编译器不支持类内初始化，而此时类在编译期又恰恰需要定义的成员常量的值，身出如此左右为难的境地，我们应该考虑使用enum！因为enum 本质也是一个整型常量。',charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"volatile",frontmatter:{title:"volatile",date:"2021-08-06T00:00:00.000Z",categories:["coding"],tags:["C++"],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/598385/"},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/08.volatile.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/08.volatile.md",key:"v-adaed63a",path:"/pages/598385/",headers:[{level:2,title:"volatile应用",slug:"volatile应用",normalizedTitle:"volatile应用",charIndex:70},{level:2,title:"3.volatile常见问题",slug:"_3-volatile常见问题",normalizedTitle:"3.volatile常见问题",charIndex:1715},{level:2,title:"4.volatile使用",slug:"_4-volatile使用",normalizedTitle:"4.volatile使用",charIndex:2338}],headersStr:"volatile应用 3.volatile常见问题 4.volatile使用",content:"被 volatile 修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。而这些可观测的副作用，是由程序之外的因素决定的。\n\n\n# volatile应用\n\n（1）并行设备的硬件寄存器（如状态寄存器）。 假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。\n\nint  *output = (unsigned  int *)0xff800000; //定义一个IO端口；  \nint   init(void)  \n{  \n    int i;  \n    for(i=0;i< 10;i++)\n    {  \n       *output = i;  \n    } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为 9，所以编译器最后给你编译编译的代码结果相当于：\n\nint  init(void)  \n{  \n    *output = 9;  \n}\n\n\n1\n2\n3\n4\n\n\n如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。\n\n（2）一个中断服务子程序中访问到的变量；\n\nstatic int i=0;\n\nint main()\n{\n    while(1)\n    {\n    \tif(i) do_something();\n    }\n}\n\n/* Interrupt service routine */\nvoid IRS()\n{\n\ti=1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面示例程序的本意是产生中断时，由中断服务子程序IRS响应中断，变更程序变量i，使在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远不会被调用。如果将变量i加上volatile修饰，则编译器保证对变量i的读写操作都不会被优化，从而保证了变量i被外部程序更改后能及时在原程序中得到感知。\n\n（3）多线程应用中被多个任务共享的变量。 当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。作用是防止编译器优化把变量从内存装入CPU寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。volatile的意思是**让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。**示例如下：\n\nvolatile  bool bStop=false;  //bStop 为共享全局变量  \n//第一个线程\nvoid threadFunc1()\n{\n    ...\n    while(!bStop){...}\n}\n//第二个线程终止上面的线程循环\nvoid threadFunc2()\n{\n    ...\n    bStop = true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n要想通过第二个线程终止第一个线程循环，如果bStop不使用volatile定义，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。\n\n是否了解volatile的应用场景是区分C/C++程序员和嵌入式开发程序员的有效办法，搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，这些都要求用到volatile变量，不懂得volatile将会带来程序设计的灾难。\n\n\n# 3.volatile常见问题\n\n下面的问题可以看一下面试者是不是直正了解volatile。\n\n（1）一个参数既可以是const还可以是volatile吗？为什么？ 可以。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。\n\n（2）一个指针可以是volatile吗？为什么？ 可以。尽管这并不常见。一个例子是当一个中断服务子程序修该一个指向一个buffer的指针时。\n\n（3）下面的函数有什么错误？\n\nint square(volatile int *ptr) \n{ \n\treturn *ptr * *ptr; \n} \n\n\n1\n2\n3\n4\n\n\n这段代码有点变态，其目的是用来返回指针ptr指向值的平方，但是，由于ptr指向一个volatile型参数，编译器将产生类似下面的代码：\n\nint square(volatile int *ptr) \n{ \nint a,b; \na = *ptr; \nb = *ptr; \nreturn a * b; \n} \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于*ptr的值可能被意想不到地改变，因此a和b可能是不同的。结果，这段代码可能返回的不是你所期望的平方值！正确的代码如下：\n\nlong square(volatile int *ptr) \n{ \nint a=*ptr; \nreturn a * a; \n} \n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.volatile使用\n\n * volatile 关键字是一种类型修饰，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。\n * volatile 关键字声明的变量，每次访问时都必须从memory中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU register中取值）\n * const 可以是 volatile （如只读的状态寄存器）\n * 指针也可以是 volatile",normalizedContent:"被 volatile 修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。而这些可观测的副作用，是由程序之外的因素决定的。\n\n\n# volatile应用\n\n（1）并行设备的硬件寄存器（如状态寄存器）。 假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。\n\nint  *output = (unsigned  int *)0xff800000; //定义一个io端口；  \nint   init(void)  \n{  \n    int i;  \n    for(i=0;i< 10;i++)\n    {  \n       *output = i;  \n    } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为 9，所以编译器最后给你编译编译的代码结果相当于：\n\nint  init(void)  \n{  \n    *output = 9;  \n}\n\n\n1\n2\n3\n4\n\n\n如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。\n\n（2）一个中断服务子程序中访问到的变量；\n\nstatic int i=0;\n\nint main()\n{\n    while(1)\n    {\n    \tif(i) do_something();\n    }\n}\n\n/* interrupt service routine */\nvoid irs()\n{\n\ti=1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面示例程序的本意是产生中断时，由中断服务子程序irs响应中断，变更程序变量i，使在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远不会被调用。如果将变量i加上volatile修饰，则编译器保证对变量i的读写操作都不会被优化，从而保证了变量i被外部程序更改后能及时在原程序中得到感知。\n\n（3）多线程应用中被多个任务共享的变量。 当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。作用是防止编译器优化把变量从内存装入cpu寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。volatile的意思是**让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。**示例如下：\n\nvolatile  bool bstop=false;  //bstop 为共享全局变量  \n//第一个线程\nvoid threadfunc1()\n{\n    ...\n    while(!bstop){...}\n}\n//第二个线程终止上面的线程循环\nvoid threadfunc2()\n{\n    ...\n    bstop = true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n要想通过第二个线程终止第一个线程循环，如果bstop不使用volatile定义，那么这个循环将是一个死循环，因为bstop已经读取到了寄存器中，寄存器中bstop的值永远不会变成false，加上volatile，程序在执行时，每次均从内存中读出bstop的值，就不会死循环了。\n\n是否了解volatile的应用场景是区分c/c++程序员和嵌入式开发程序员的有效办法，搞嵌入式的家伙们经常同硬件、中断、rtos等等打交道，这些都要求用到volatile变量，不懂得volatile将会带来程序设计的灾难。\n\n\n# 3.volatile常见问题\n\n下面的问题可以看一下面试者是不是直正了解volatile。\n\n（1）一个参数既可以是const还可以是volatile吗？为什么？ 可以。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。\n\n（2）一个指针可以是volatile吗？为什么？ 可以。尽管这并不常见。一个例子是当一个中断服务子程序修该一个指向一个buffer的指针时。\n\n（3）下面的函数有什么错误？\n\nint square(volatile int *ptr) \n{ \n\treturn *ptr * *ptr; \n} \n\n\n1\n2\n3\n4\n\n\n这段代码有点变态，其目的是用来返回指针ptr指向值的平方，但是，由于ptr指向一个volatile型参数，编译器将产生类似下面的代码：\n\nint square(volatile int *ptr) \n{ \nint a,b; \na = *ptr; \nb = *ptr; \nreturn a * b; \n} \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于*ptr的值可能被意想不到地改变，因此a和b可能是不同的。结果，这段代码可能返回的不是你所期望的平方值！正确的代码如下：\n\nlong square(volatile int *ptr) \n{ \nint a=*ptr; \nreturn a * a; \n} \n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.volatile使用\n\n * volatile 关键字是一种类型修饰，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。\n * volatile 关键字声明的变量，每次访问时都必须从memory中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 cpu register中取值）\n * const 可以是 volatile （如只读的状态寄存器）\n * 指针也可以是 volatile",charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"inline",frontmatter:{title:"inline",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/91242f/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/09.inline.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/09.inline.md",key:"v-0eba4323",path:"/pages/91242f/",headers:[{level:2,title:"Why?",slug:"why",normalizedTitle:"why?",charIndex:41},{level:2,title:"What?",slug:"what",normalizedTitle:"what?",charIndex:623},{level:2,title:"How?",slug:"how",normalizedTitle:"how?",charIndex:678},{level:3,title:"类中内联",slug:"类中内联",normalizedTitle:"类中内联",charIndex:687},{level:3,title:"函数内联",slug:"函数内联",normalizedTitle:"函数内联",charIndex:1065},{level:3,title:"虚函数内联",slug:"虚函数内联",normalizedTitle:"虚函数内联",charIndex:1677},{level:2,title:"Tips:",slug:"tips",normalizedTitle:"tips:",charIndex:2716}],headersStr:"Why? What? How? 类中内联 函数内联 虚函数内联 Tips:",content:'inline关键字的含义， 用法以及compiler对inline的处理\n\n\n# Why?\n\n在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。\n\n栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。\n\n在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。\n\n#include <stdio.h>\n \ninline const char *num_check(int v)\n{\n    return (v % 2 > 0) ? "奇" : "偶";\n}\n \nint main(void)\n{\n    int i;\n    for (i = 0; i < 100; i++)\n        printf("%02d   %s\\n", i, num_check(i));\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面的例子就是标准的内联函数的用法，使用 inline 修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个 for 循环的内部任何调用 *dbtest(i)* 的地方都换成了 *(i%2>0)?"奇":"偶"*，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。\n\n\n# What?\n\n使用场景： 函数非常短小而且在很多地方都被调用的时候， 但是会使得可执行体的体积增大。\n\n\n# How?\n\n\n# 类中内联\n\n写在类中的函数自动内联\n\nclass A\n{\n    public:\n    \tvoid f1(int x); \n\n        /**\n       * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。\n       *\n       * @param x\n       * @param y\n       */\n        void Foo(int x,int y) ///< 定义即隐式内联函数！\n        {\n\n        };\n        void f1(int x); ///< 声明后，要想成为内联函数，必须在定义处加inline关键字。 \n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 函数内联\n\n类外的函数需要加inline关键字\n\n#include <iostream>\n#include "inline.h"\nusing namespace std;\n/**\n * @brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字”\n */\nint Foo(int x,int y); // 函数声明\ninline int Foo(int x,int y) // 函数定义\n{\n  return x+y;\n}\n \n// 定义处加inline关键字，推荐这种写法！\ninline void A::f1(int x) { }\n \nint main()\n{\n\tcout<<Foo(1,2)<<endl;\n}\n/**\n * 编译器对 inline 函数的处理步骤\n * 将 inline 函数体复制到 inline 函数调用点处；\n * 为所用 inline 函数中的局部变量分配内存空间；\n * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；\n * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 虚函数内联\n\n虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。\n\n内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。\n\ninline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。\n\n#include <iostream> \nusing namespace std;\nclass Base\n{\n    public:\n        inline virtual void who()\n        {\n            cout << "I am Base\\n";\n        }\n        virtual ~Base() {}\n};\nclass Derived : public Base\n{\n    public:\n        inline void who() // 不写inline时隐式内联\n        {\n            cout << "I am Derived\\n";\n        }\n};\n\nint main()\n{\n    // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 \n    Base b;\n    b.who();\n\n    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。 \n    Base *ptr = new Derived();\n    ptr->who();\n\n    // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。\n    delete ptr;\n    ptr = nullptr;\n\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# Tips:\n\n 1. inline 的使用是有所限制的，inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。\n\n 2. inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。\n\n 3. 因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。所以，这要求每个调用了内联函数的文件都出现了该内联函数的定义。因此，将内联函数的定义放在头文件里实现是合适的，省却你为每个文件实现一次的麻烦。\n\n 4. 声明跟定义要一致：如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为。如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。\n\n 5. 定义在类中的成员函数默认都是内联的，如果在类定义~时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline，否则就认为不是内联的。\n\n 6. inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前不起任何作用， 声明的时候不加inline， 定义的时候才加\n\ninline void Foo(int x, int y); // inline 仅与函数声明放在一起\nvoid Foo(int x, int y){}\nvoid Foo(int x, int y);\ninline void Foo(int x, int y) {} // inline 与函数定义体放在一起\n\n\n1\n2\n3\n4\n\n 7. 内联是以**代码膨胀（复制）**为代价，省去了函数调用的开销，从而提高函数的执行效率。 但如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，会消耗更多的内存空间。',normalizedContent:'inline关键字的含义， 用法以及compiler对inline的处理\n\n\n# why?\n\n在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。\n\n栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。\n\n在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。\n\n#include <stdio.h>\n \ninline const char *num_check(int v)\n{\n    return (v % 2 > 0) ? "奇" : "偶";\n}\n \nint main(void)\n{\n    int i;\n    for (i = 0; i < 100; i++)\n        printf("%02d   %s\\n", i, num_check(i));\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面的例子就是标准的内联函数的用法，使用 inline 修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个 for 循环的内部任何调用 *dbtest(i)* 的地方都换成了 *(i%2>0)?"奇":"偶"*，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。\n\n\n# what?\n\n使用场景： 函数非常短小而且在很多地方都被调用的时候， 但是会使得可执行体的体积增大。\n\n\n# how?\n\n\n# 类中内联\n\n写在类中的函数自动内联\n\nclass a\n{\n    public:\n    \tvoid f1(int x); \n\n        /**\n       * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。\n       *\n       * @param x\n       * @param y\n       */\n        void foo(int x,int y) ///< 定义即隐式内联函数！\n        {\n\n        };\n        void f1(int x); ///< 声明后，要想成为内联函数，必须在定义处加inline关键字。 \n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 函数内联\n\n类外的函数需要加inline关键字\n\n#include <iostream>\n#include "inline.h"\nusing namespace std;\n/**\n * @brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字”\n */\nint foo(int x,int y); // 函数声明\ninline int foo(int x,int y) // 函数定义\n{\n  return x+y;\n}\n \n// 定义处加inline关键字，推荐这种写法！\ninline void a::f1(int x) { }\n \nint main()\n{\n\tcout<<foo(1,2)<<endl;\n}\n/**\n * 编译器对 inline 函数的处理步骤\n * 将 inline 函数体复制到 inline 函数调用点处；\n * 为所用 inline 函数中的局部变量分配内存空间；\n * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；\n * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 goto）。\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 虚函数内联\n\n虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。\n\n内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。\n\ninline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。\n\n#include <iostream> \nusing namespace std;\nclass base\n{\n    public:\n        inline virtual void who()\n        {\n            cout << "i am base\\n";\n        }\n        virtual ~base() {}\n};\nclass derived : public base\n{\n    public:\n        inline void who() // 不写inline时隐式内联\n        {\n            cout << "i am derived\\n";\n        }\n};\n\nint main()\n{\n    // 此处的虚函数 who()，是通过类（base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 \n    base b;\n    b.who();\n\n    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。 \n    base *ptr = new derived();\n    ptr->who();\n\n    // 因为base有虚析构函数（virtual ~base() {}），所以 delete 时，会先调用派生类（derived）析构函数，再调用基类（base）析构函数，防止内存泄漏。\n    delete ptr;\n    ptr = nullptr;\n\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# tips:\n\n 1. inline 的使用是有所限制的，inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。\n\n 2. inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。\n\n 3. 因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。所以，这要求每个调用了内联函数的文件都出现了该内联函数的定义。因此，将内联函数的定义放在头文件里实现是合适的，省却你为每个文件实现一次的麻烦。\n\n 4. 声明跟定义要一致：如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为。如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。\n\n 5. 定义在类中的成员函数默认都是内联的，如果在类定义~时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline，否则就认为不是内联的。\n\n 6. inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前不起任何作用， 声明的时候不加inline， 定义的时候才加\n\ninline void foo(int x, int y); // inline 仅与函数声明放在一起\nvoid foo(int x, int y){}\nvoid foo(int x, int y);\ninline void foo(int x, int y) {} // inline 与函数定义体放在一起\n\n\n1\n2\n3\n4\n\n 7. 内联是以**代码膨胀（复制）**为代价，省去了函数调用的开销，从而提高函数的执行效率。 但如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，会消耗更多的内存空间。',charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"assert",frontmatter:{title:"assert",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/efbaf4/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/10.assert.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/10.assert.md",key:"v-38c4d983",path:"/pages/efbaf4/",headers:[{level:2,title:"2.assert与正常错误处理",slug:"_2-assert与正常错误处理",normalizedTitle:"2.assert与正常错误处理",charIndex:609}],headersStr:"2.assert与正常错误处理",content:"断言，是宏，而非函数。\n\nassert 宏的原型定义在 <assert.h>（C）（C++）中。其作用是如果它的条件返回错误，则终止程序执行。\n\nvoid assert(int expression);\n\n\n1\n\n\n可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include <assert.h> 之前。\n\n#include <stdio.h> \n#include <assert.h> \n\nint main() \n{ \n    int x = 7; \n\n    /*  Some big code in between and let's say x  \n    is accidentally changed to 9  */\n    x = 9; \n\n    // Programmer assumes x to be 7 in rest of the code \n    assert(x==7); \n\n    /* Rest of the code */\n\n    return 0; \n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n输出：\n\nassert: assert.c:13: main: Assertion 'x==7' failed.\n\n\n1\n\n\n可以看到输出会把源码文件，行号错误位置，提示出来！\n\n\n# 2.assert与正常错误处理\n\n * assert主要用于检查逻辑上不可能的情况。\n\n> 例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。与正常的错误处理不同，断言通常在运行时被禁用。\n\n * 忽略断言，在代码开头加上：\n\n#define NDEBUG          // 加上这行，则 assert 不可用\n\n\n1\n",normalizedContent:"断言，是宏，而非函数。\n\nassert 宏的原型定义在 <assert.h>（c）（c++）中。其作用是如果它的条件返回错误，则终止程序执行。\n\nvoid assert(int expression);\n\n\n1\n\n\n可以通过定义 ndebug 来关闭 assert，但是需要在源代码的开头，include <assert.h> 之前。\n\n#include <stdio.h> \n#include <assert.h> \n\nint main() \n{ \n    int x = 7; \n\n    /*  some big code in between and let's say x  \n    is accidentally changed to 9  */\n    x = 9; \n\n    // programmer assumes x to be 7 in rest of the code \n    assert(x==7); \n\n    /* rest of the code */\n\n    return 0; \n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n输出：\n\nassert: assert.c:13: main: assertion 'x==7' failed.\n\n\n1\n\n\n可以看到输出会把源码文件，行号错误位置，提示出来！\n\n\n# 2.assert与正常错误处理\n\n * assert主要用于检查逻辑上不可能的情况。\n\n> 例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。与正常的错误处理不同，断言通常在运行时被禁用。\n\n * 忽略断言，在代码开头加上：\n\n#define ndebug          // 加上这行，则 assert 不可用\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"void",frontmatter:{title:"void",date:"2021-08-06T00:00:00.000Z",categories:["coding"],tags:["C++"],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/b4d0b6/"},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/11.void.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/11.void.md",key:"v-808e1b3a",path:"/pages/b4d0b6/",headers:[{level:2,title:"Functions that do not return a value  : void add ( int a, int b )",slug:"functions-that-do-not-return-a-value-void-add-int-a-int-b",normalizedTitle:"functions that do not return a value  : void add ( int a, int b )",charIndex:null},{level:2,title:"Functions that do not take parameters : void add ( void )",slug:"functions-that-do-not-take-parameters-void-add-void",normalizedTitle:"functions that do not take parameters : void add ( void )",charIndex:636},{level:2,title:"void pointer (generic pointer)： void *",slug:"void-pointer-generic-pointer-void",normalizedTitle:"void pointer (generic pointer)： void *",charIndex:938},{level:2,title:"void不是一个真实的变量",slug:"void不是一个真实的变量",normalizedTitle:"void不是一个真实的变量",charIndex:2910},{level:2,title:"Extra：",slug:"extra",normalizedTitle:"extra：",charIndex:3426}],excerpt:"<p>void关键字的三个use case， 和一个注意的tips</p>\n",headersStr:"Functions that do not return a value  : void add ( int a, int b ) Functions that do not take parameters : void add ( void ) void pointer (generic pointer)： void * void不是一个真实的变量 Extra：",content:"void关键字的三个use case， 和一个注意的tips\n\n\n# **Functions that do not return a value ** : void add ( int a, int b )\n\n在C语言中，不加返回值类型限定的函数，就会被编译器作为返回整型值处理。但是很多人却误以为其为void类型。例如：\n\nadd ( int a, int b )\n{\n    return a + b;\n}\n\nint main(int argc, char* argv[])\n{\n    printf ( \"2 + 3 = %d\", add ( 2, 3) );\n}\n\nvoid noReturn(int x) // void here means no return value\n{\n    return 5; // error\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n程序运行的结果为输出：2 + 3 = 5， 这说明在C语言中不加返回值说明的函数的确为int函数。\n\nC++ 会有严格的类型检查， 对于任何函数都要指定其类型。如果函数没有返回值，一定要声明为void类型。另外，加上void类型声明后，也可以发挥代码的“自注释”作用。代码的“自注释”即代码能自己注释自己。\n\nvoid add ( int a, int b )\n{\n    int c;\n    c = a + b;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# Functions that do not take parameters : void add ( void )\n\n如果函数不接受任何参数， 可以在函数声明时候的参数列表里面写上void\n\nvoid add ( void )\n{\n    // some system configuration  ...\n}\n\n// or : \nint getValue(void) // void here means no parameters\n{\n    int x{};\n    std::cin >> x;\n    return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# void pointer (generic pointer)： void *\n\n如果函数的参数可以是任意类型指针，那么应声明其参数为void *， 注意两点：\n\n 1. void＊是一种特殊的指针类型，可存放任意对象的地址，但我们对该地址中到底是什么类型的对象并不了解。\n 2. 不能直接操作void＊指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。\n\n// void* 可以存放任意对象的地址， \nint nValue;\nfloat fValue;\n\nstruct Something\n{\n    int n;\n    float f;\n};\n\nSomething sValue;\n\nvoid* ptr;\nptr = &nValue; // valid\nptr = &fValue; // valid\nptr = &sValue; // valid\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n// 但是void*必须进行强制转换之后才能够对齐进行操作\nint value{ 5 };\nvoid* voidPtr{ &value };\n\n// std::cout << *voidPtr << '\\n'; // illegal: dereference of void pointer\n\nint* intPtr{ static_cast<int*>(voidPtr) }; // however, if we cast our void pointer to an int pointer...\n\nstd::cout << *intPtr << '\\n'; // then we can dereference the result\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如内存操作函数memcpy和memset的函数原型分别为：\n\nvoid * memcpy(void *dest, const void *src, size_t len);\n\nvoid * memset ( void * buffer, int c, size_t num );\n\n\n1\n2\n3\n\n\n这样，任何类型的指针都可以传入memcpy和memset中，也体现了内存操作函数的意义，因为它操作的对象是一片内存，而不在乎这片内存是什么类型\n\n下面的代码执行正确：\n\n//示例：memset接受任意类型指针\nint intarray[100];\nmemset(intarray, 0, 100*sizeof(int)); //将intarray清0\n\n//示例：memcpy接受任意类型指针\nint intarray1[100], intarray2[100];\nmemcpy(intarray1, intarray2, 100*sizeof(int)); //将intarray2拷贝给intarray1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n并且memcpy和memset函数返回的也是void *类型， 代表一个任意类型的指针\n\n----------------------------------------\n\n按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即下列操作都是不合法的：\n\nvoid* pvoid;\npvoid++; //ANSI：错误\npvoid += 1; //ANSI：错误\n//ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。\n\n//例如：\nint *pint;\npint++; //ANSI：正确     pint++的结果是使其增大sizeof(int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n但是GNU(GNU's Not Unix的缩写)则指定void *的算法操作与char *一致。因此下列语句在GNU编译器中也是正确的：\n\npvoid++;    //GNU：正确\npvoid += 1; //GNU：正确void++的执行结果是其增大了1\n\n// 在实际的程序设计中，为迎合ANSI标准，并提高程序的可移植性，我们可以这样实现：\nvoid * pvoid;\n(char *)pvoid++;    //ANSI：正确；GNU：正确\n(char *)pvoid += 1; //ANSI：错误；GNU：正确\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nGNU和ANSI还有一些区别，总体而言，GNU较ANSI更“开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地匹配ANSI标准。\n\n\n# void不是一个真实的变量\n\n下面代码都企图让void代表一个真实的变量，因此都是错误的代码：\n\nvoid a; //错误\nfunction(void a); //错误\n\n\n1\n2\n\n\n如果指针p1和p2的类型相同，那么我们可以直接在p1和p2间互相赋值；如果p1和p2指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。 例如：\n\nfloat *p1;\nint *p2;\np1 = p2; // error! cannot convert from 'int *' to 'float *'”\n\n\n1\n2\n3\n\n\n必须改为：\n\np1 = (float *)p2;\n\n\n1\n\n\n但是任何类型的指针都可以直接赋值给void *，无需进行类型转换（反之不成立）：\n\nvoid *p1;\nint *p2;\np1 = p2;\n\n\n1\n2\n3\n\n\nvoid *则必须进行类型转换， 然后再赋给其它类型的指针。下面这样则会出错：\n\nvoid *p1;\nint *p2;\np2 = p1; // cannot convert from 'void *' to 'int *'\n\n\n1\n2\n3\n\n\n\n# Extra：\n\n对于好的编程习惯来说，declare一个指针，则初始化为NULL，如果是类成员 则在构造函数中initialize，当对指针使用delete时候，则置它为NULL.",normalizedContent:"void关键字的三个use case， 和一个注意的tips\n\n\n# **functions that do not return a value ** : void add ( int a, int b )\n\n在c语言中，不加返回值类型限定的函数，就会被编译器作为返回整型值处理。但是很多人却误以为其为void类型。例如：\n\nadd ( int a, int b )\n{\n    return a + b;\n}\n\nint main(int argc, char* argv[])\n{\n    printf ( \"2 + 3 = %d\", add ( 2, 3) );\n}\n\nvoid noreturn(int x) // void here means no return value\n{\n    return 5; // error\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n程序运行的结果为输出：2 + 3 = 5， 这说明在c语言中不加返回值说明的函数的确为int函数。\n\nc++ 会有严格的类型检查， 对于任何函数都要指定其类型。如果函数没有返回值，一定要声明为void类型。另外，加上void类型声明后，也可以发挥代码的“自注释”作用。代码的“自注释”即代码能自己注释自己。\n\nvoid add ( int a, int b )\n{\n    int c;\n    c = a + b;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# functions that do not take parameters : void add ( void )\n\n如果函数不接受任何参数， 可以在函数声明时候的参数列表里面写上void\n\nvoid add ( void )\n{\n    // some system configuration  ...\n}\n\n// or : \nint getvalue(void) // void here means no parameters\n{\n    int x{};\n    std::cin >> x;\n    return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# void pointer (generic pointer)： void *\n\n如果函数的参数可以是任意类型指针，那么应声明其参数为void *， 注意两点：\n\n 1. void＊是一种特殊的指针类型，可存放任意对象的地址，但我们对该地址中到底是什么类型的对象并不了解。\n 2. 不能直接操作void＊指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。\n\n// void* 可以存放任意对象的地址， \nint nvalue;\nfloat fvalue;\n\nstruct something\n{\n    int n;\n    float f;\n};\n\nsomething svalue;\n\nvoid* ptr;\nptr = &nvalue; // valid\nptr = &fvalue; // valid\nptr = &svalue; // valid\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n// 但是void*必须进行强制转换之后才能够对齐进行操作\nint value{ 5 };\nvoid* voidptr{ &value };\n\n// std::cout << *voidptr << '\\n'; // illegal: dereference of void pointer\n\nint* intptr{ static_cast<int*>(voidptr) }; // however, if we cast our void pointer to an int pointer...\n\nstd::cout << *intptr << '\\n'; // then we can dereference the result\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如内存操作函数memcpy和memset的函数原型分别为：\n\nvoid * memcpy(void *dest, const void *src, size_t len);\n\nvoid * memset ( void * buffer, int c, size_t num );\n\n\n1\n2\n3\n\n\n这样，任何类型的指针都可以传入memcpy和memset中，也体现了内存操作函数的意义，因为它操作的对象是一片内存，而不在乎这片内存是什么类型\n\n下面的代码执行正确：\n\n//示例：memset接受任意类型指针\nint intarray[100];\nmemset(intarray, 0, 100*sizeof(int)); //将intarray清0\n\n//示例：memcpy接受任意类型指针\nint intarray1[100], intarray2[100];\nmemcpy(intarray1, intarray2, 100*sizeof(int)); //将intarray2拷贝给intarray1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n并且memcpy和memset函数返回的也是void *类型， 代表一个任意类型的指针\n\n----------------------------------------\n\n按照ansi(american national standards institute)标准，不能对void指针进行算法操作，即下列操作都是不合法的：\n\nvoid* pvoid;\npvoid++; //ansi：错误\npvoid += 1; //ansi：错误\n//ansi标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。\n\n//例如：\nint *pint;\npint++; //ansi：正确     pint++的结果是使其增大sizeof(int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n但是gnu(gnu's not unix的缩写)则指定void *的算法操作与char *一致。因此下列语句在gnu编译器中也是正确的：\n\npvoid++;    //gnu：正确\npvoid += 1; //gnu：正确void++的执行结果是其增大了1\n\n// 在实际的程序设计中，为迎合ansi标准，并提高程序的可移植性，我们可以这样实现：\nvoid * pvoid;\n(char *)pvoid++;    //ansi：正确；gnu：正确\n(char *)pvoid += 1; //ansi：错误；gnu：正确\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ngnu和ansi还有一些区别，总体而言，gnu较ansi更“开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地匹配ansi标准。\n\n\n# void不是一个真实的变量\n\n下面代码都企图让void代表一个真实的变量，因此都是错误的代码：\n\nvoid a; //错误\nfunction(void a); //错误\n\n\n1\n2\n\n\n如果指针p1和p2的类型相同，那么我们可以直接在p1和p2间互相赋值；如果p1和p2指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。 例如：\n\nfloat *p1;\nint *p2;\np1 = p2; // error! cannot convert from 'int *' to 'float *'”\n\n\n1\n2\n3\n\n\n必须改为：\n\np1 = (float *)p2;\n\n\n1\n\n\n但是任何类型的指针都可以直接赋值给void *，无需进行类型转换（反之不成立）：\n\nvoid *p1;\nint *p2;\np1 = p2;\n\n\n1\n2\n3\n\n\nvoid *则必须进行类型转换， 然后再赋给其它类型的指针。下面这样则会出错：\n\nvoid *p1;\nint *p2;\np2 = p1; // cannot convert from 'void *' to 'int *'\n\n\n1\n2\n3\n\n\n\n# extra：\n\n对于好的编程习惯来说，declare一个指针，则初始化为null，如果是类成员 则在构造函数中initialize，当对指针使用delete时候，则置它为null.",charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"_global_",frontmatter:{title:"__global__",date:"2021-08-05T00:00:00.000Z",categories:["coding"],tags:["C++"],permalink:"/pages/fc5419/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/01.Lean%20in%20c++/01.Phase_0:Glimpse/12.__global__.html",relativePath:"01.Wiki/01.Lean in c++/01.Phase_0:Glimpse/12.__global__.md",key:"v-19e58c3a",path:"/pages/fc5419/",excerpt:"<p>_<em>global_</em> 关键字的含义， 用法以及在编译的时候是如何进行链接的</p>\n",headersStr:null,content:"_global_ 关键字的含义， 用法以及在编译的时候是如何进行链接的\n\n\n\n\n1\n",normalizedContent:"_global_ 关键字的含义， 用法以及在编译的时候是如何进行链接的\n\n\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"Comming soon",frontmatter:{pageClass:"diary",title:"Comming soon",date:"2022-06-27T07:53:54.000Z",categories:["Wiki","Performance"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/wiki/Performance_Engineering/"},regularPath:"/01.Wiki/02.Performance%20Engineering/01.Perf.html",relativePath:"01.Wiki/02.Performance Engineering/01.Perf.md",key:"v-448f6e72",path:"/wiki/Performance_Engineering/",headers:[{level:3,title:"Ongoing",slug:"ongoing",normalizedTitle:"ongoing",charIndex:2}],headersStr:"Ongoing",content:"# Ongoing",normalizedContent:"# ongoing",charsets:{},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"Chrome 非常规操作",frontmatter:{pageClass:"diary",title:"Chrome 非常规操作",date:"2022-06-27T07:53:54.000Z",permalink:"/pages/41a6c9/",categories:["Wiki","misc"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/10.Misc/01.Chrome.html",relativePath:"01.Wiki/10.Misc/01.Chrome.md",key:"v-acc65afa",path:"/pages/41a6c9/",headers:[{level:3,title:"长页面截图",slug:"长页面截图",normalizedTitle:"长页面截图",charIndex:2},{level:3,title:"常用插件",slug:"常用插件",normalizedTitle:"常用插件",charIndex:91},{level:3,title:"调试动画",slug:"调试动画",normalizedTitle:"调试动画",charIndex:277},{level:3,title:"编辑页面上的任意文本",slug:"编辑页面上的任意文本",normalizedTitle:"编辑页面上的任意文本",charIndex:364}],headersStr:"长页面截图 常用插件 调试动画 编辑页面上的任意文本",content:"# 长页面截图\n\n1.打开F12\n2.按Ctrl + Shift + P\n3.输入full size screenshot\n4.回车\n5.保存截图\n\n\n1\n2\n3\n4\n5\n\n\n\n# 常用插件\n\nVue.js devtools\nWEB前端助手(FeHelper)\nReact Developer Tools\nAdblock Plus\nColorPick Eyedropper\nPage Ruler\nImagus(页面放大图片查看)\nproject-naptha(图片提取文字)\nOctotree(在线资源管理器的方式阅读GitHub仓库的代码)\n\n\n\n# 调试动画\n\n1.打开F12\n2.找Animations选项卡\n3.若没有，则点击右上角三点 -> More Tools -> Animations\n\n\n1\n2\n3\n\n\n\n# 编辑页面上的任意文本\n\n1.打开F12\n2.在控制台输入 document.body.contentEditable=\"true\" 或 document.designMode = 'on'\n3.实现对网页的编辑\n\n\n1\n2\n3\n",normalizedContent:"# 长页面截图\n\n1.打开f12\n2.按ctrl + shift + p\n3.输入full size screenshot\n4.回车\n5.保存截图\n\n\n1\n2\n3\n4\n5\n\n\n\n# 常用插件\n\nvue.js devtools\nweb前端助手(fehelper)\nreact developer tools\nadblock plus\ncolorpick eyedropper\npage ruler\nimagus(页面放大图片查看)\nproject-naptha(图片提取文字)\noctotree(在线资源管理器的方式阅读github仓库的代码)\n\n\n\n# 调试动画\n\n1.打开f12\n2.找animations选项卡\n3.若没有，则点击右上角三点 -> more tools -> animations\n\n\n1\n2\n3\n\n\n\n# 编辑页面上的任意文本\n\n1.打开f12\n2.在控制台输入 document.body.contenteditable=\"true\" 或 document.designmode = 'on'\n3.实现对网页的编辑\n\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"VsCode 常用插件",frontmatter:{pageClass:"diary",title:"VsCode 常用插件",date:"2022-06-27T07:53:54.000Z",permalink:"/pages/6f0fa2/",categories:["Wiki","misc"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/01.Wiki/10.Misc/02.VsCode.html",relativePath:"01.Wiki/10.Misc/02.VsCode.md",key:"v-3cdd7c23",path:"/pages/6f0fa2/",headers:[{level:3,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:3,title:"前端",slug:"前端",normalizedTitle:"前端",charIndex:192},{level:3,title:"Git",slug:"git",normalizedTitle:"git",charIndex:345}],headersStr:" 前端 Git",content:"#\n\nChinese (Simplified) Language Pack for Visual Studio Code - 中文（简体）语言包\nImport Cost - 导入文件大小\nvscode-fileheader - 自动记录文件修改时间 - CTRL+ALT+I\nvscode-icons - vscode风格文件icon\nBeautify - 自动格式化代码\n\n\n\n# 前端\n\nVetur\njavascript console utils - 快速console - CTRL+SHIFT+L\nLive Server - 静态网页开启服务\nopen in browser - 快速开启浏览器浏览网页 - ALT+B\nBetter Comments - 不同风格注释\n\n\n\n# Git\n\nGit History\n",normalizedContent:"#\n\nchinese (simplified) language pack for visual studio code - 中文（简体）语言包\nimport cost - 导入文件大小\nvscode-fileheader - 自动记录文件修改时间 - ctrl+alt+i\nvscode-icons - vscode风格文件icon\nbeautify - 自动格式化代码\n\n\n\n# 前端\n\nvetur\njavascript console utils - 快速console - ctrl+shift+l\nlive server - 静态网页开启服务\nopen in browser - 快速开启浏览器浏览网页 - alt+b\nbetter comments - 不同风格注释\n\n\n\n# git\n\ngit history\n",charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"习惯C++",frontmatter:{title:"习惯C++",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/f9e729/"},regularPath:"/01.Wiki/19.Reading%20Notes/01.Effective%20C++/01.%E4%B9%A0%E6%83%AFC++.html",relativePath:"01.Wiki/19.Reading Notes/01.Effective C++/01.习惯C++.md",key:"v-28c8daa4",path:"/pages/f9e729/",headers:[{level:2,title:"习惯C++",slug:"习惯c",normalizedTitle:"习惯c++",charIndex:2},{level:3,title:"Item 01：视C++为一个语言联邦,  View C++as a federation of languages.",slug:"item-01-视c-为一个语言联邦-view-c-as-a-federation-of-languages",normalizedTitle:"item 01：视c++为一个语言联邦,  view c++as a federation of languages.",charIndex:null},{level:3,title:"Item 02：尽量以const，enum，inline替换＃define, Prefer consts，enums，and inlines to＃defines.",slug:"item-02-尽量以const-enum-inline替换-define-prefer-consts-enums-and-inlines-to-defines",normalizedTitle:"item 02：尽量以const，enum，inline替换＃define, prefer consts，enums，and inlines to＃defines.",charIndex:469},{level:3,title:"Item 03：尽可能使用const， Use const whenever possible.",slug:"item-03-尽可能使用const-use-const-whenever-possible",normalizedTitle:"item 03：尽可能使用const， use const whenever possible.",charIndex:1299},{level:3,title:"Item 04：Make sure that objects are initialized before they're used.      对象在使用前已先被初始化",slug:"item-04-make-sure-that-objects-are-initialized-before-they-re-used-对象在使用前已先被初始化",normalizedTitle:"item 04：make sure that objects are initialized before they're used.      对象在使用前已先被初始化",charIndex:null}],headersStr:"习惯C++ Item 01：视C++为一个语言联邦,  View C++as a federation of languages. Item 02：尽量以const，enum，inline替换＃define, Prefer consts，enums，and inlines to＃defines. Item 03：尽可能使用const， Use const whenever possible. Item 04：Make sure that objects are initialized before they're used.      对象在使用前已先被初始化",content:'# 习惯C++\n\n\n# Item 01：视C++为一个语言联邦, View C++as a federation of languages.\n\nC++是一个语言联邦， 有多种编程范式: procedural （面向过程）, OOP（面向对象）， GP（泛型编程）, Functional Programming（函数式编程），metaprograming(元编程），但差不多有四个主要的部分：\n\n 1. C：数组， 指针， 预处理， 程序员的自我修养\n 2. Object oriented C++： classs, encapsulation, ingeritance, polymorphism, virtual function的动态绑定；（模板， 异常， 重载）\n 3. Template C++ (template metaprogramming, 模板元编程)\n 4. STL： 容器（containers）、迭代器（iterators）、算法（algorithms）以及函数对象（function objects）\n\n\n# Item 02：尽量以const，enum，inline替换＃define, Prefer consts，enums，and inlines to＃defines.\n\n用const， enum， inline代替 #define\n\n 1. const 能够更好地控制指针和指针所指变量的const属性， 并且#define对作用域不敏感，const可以定义某个类专属的常量；\n    \n    const int GamePlayer::NumTurns;\n    \n    \n    1\n    \n\n 2. class专属常量。为确保此常量至多只有一份实体，你必须让它成为一个static成员：\n    \n    class GamePlayer{\n    \tprivate:\n    \t\tstatic const int NumTurns = 5; // 常量声明\n    \t\tint scores[NumTurns]; // 使用该常量\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. enum是不可以取地址的，enum hack是模板原编程的基础技术，见Item 48\n\n 4. #define带来的安全性可以使用模板inline函数实现， 见Item 30\n    \n    template<typename T> // 暂时用模板的typename代替\n    inline void callWithMax(const T& a, const T& b){\n        f(a > b ? a : b);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 5. 对于单纯常量，最好以const对象或enums替换＃defines。\n\n 6. 对于形似函数的宏（macros），最好改用inline函数替换＃defines。\n\n\n# Item 03：尽可能使用const， Use const whenever possible.\n\n该用const的地方，尽可能使用const\n\n 1. 类内的变量是否为const?\n\n 2. 指针的双重const， 在什么之前就修饰什么， 指针为const， 还是指针指向的值为const, 常量指针\n    \n    const char* const authorName = "Quincy"\n    \n    \n    1\n    \n\n 3. 函数的参数是否传const引用？ 使用const修饰， 会明示参数是否被改变（引用不改变， 要加const表示出来）；\n\n 4. 成员函数后是加const， 代表这个成员函数不会修改类内的值；\n\n 5. 返回值是否要成为const（为什么？）， 看返回值类型是否是需要const不允许变动(防止用户自身的村务使用， 不放弃高效性)， 其次是避免成为左值被修改；\n\na.get_data()=3;  // 返回一个const， 这种操作就是不合法的；\n\n\n1\n\n\n 6. mutable可以释放掉non-static成员变量的bitwise constness约束；\n    \n    class CTextBlock{\n        public:\n        \tstd::size_t length() const;\n        private:\n        \tchar* pText;\n        \tmutable std::size_t textLength; //这些变量可能总是会被改变\n    \t    mutable bool lengthIsValis;\n    // 在length()中， 会频繁改变上述的两个变量；  \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    \n    Key:\n    \n    * 将某些东西声明为const可帮助编译器提示出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。\n    \n    * 编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”（conceptual constness）。\n    \n    * 当const和non-const成员函数有着实质等价的实现时(确实是要有两个版本)，令non-const版本调用const版本可避免代码重复。因为const可以兼容non-const的输入， 但是non-const不可以兼容const的输入\n      \n      class TextBlock {\n      public:\n          ...\n          const char& operator[](std::size_t position) const // 表示不改变类成员\n          {\n              ... // do bounds checking\n              ... // log access data\n              ... // verify data integrity\n              return text[position];\n          }\n          char& operator[](std::size_t position)\n          {\n              ... // do bounds checking\n              ... // log access data\n              ... // verify data integrity\n              return text[position];\n          }\n      private:\n          std::string text;\n      };\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      \n\n\n# Item 04：Make sure that objects are initialized before they\'re used. 对象在使用前已先被初始化\n\n 1. 没有初始化的值，在读它的时候会导致不明确的行为， 变量里面包含的内容都是半随机状态；\n\n 2. 在初始化列表里面， 列出所有的成员变量， 免得遗漏， 除非记得住哪些不用初始值；\n    \n    1. 实在太多的话， 用一个private函数包一下能够赋值处理的， 也可以；\n    2. 初始化的顺序总是按照声明顺序来， 不是按照初始化列表的顺序\n\n 3. 成员变量是const或者reference， 就一定要初始化， 因为后面不能再被赋值了；\n\n 4. 如果有一个non-local static对象， 没有办法保证是否使用的时候已经初始化， 那就在本地搞一个static函数（处理static对象的函数叫做static的函数）把这个对象包起来，返回一个指向这个对象的reference， 这样， 外部的static对象就变成了本地的static对象， 这也是singleton模式的一个常见实现手法（这种手法叫做reference returning）\n    \n    Directory& tempDir(){\n    \tstatic Directory& td; // more effective c++里面， 限制对象数目的方式， 好像是一样的\n    \treturn td; // 还是把non-loca的static的对象，改变成local static的对象比较好；\n    }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 5. 任何一种non const static 对象，在多线程环境下， 都会有线程安全的问题；non const代表了可以被改变， 多线程可以同时改变它；',normalizedContent:'# 习惯c++\n\n\n# item 01：视c++为一个语言联邦, view c++as a federation of languages.\n\nc++是一个语言联邦， 有多种编程范式: procedural （面向过程）, oop（面向对象）， gp（泛型编程）, functional programming（函数式编程），metaprograming(元编程），但差不多有四个主要的部分：\n\n 1. c：数组， 指针， 预处理， 程序员的自我修养\n 2. object oriented c++： classs, encapsulation, ingeritance, polymorphism, virtual function的动态绑定；（模板， 异常， 重载）\n 3. template c++ (template metaprogramming, 模板元编程)\n 4. stl： 容器（containers）、迭代器（iterators）、算法（algorithms）以及函数对象（function objects）\n\n\n# item 02：尽量以const，enum，inline替换＃define, prefer consts，enums，and inlines to＃defines.\n\n用const， enum， inline代替 #define\n\n 1. const 能够更好地控制指针和指针所指变量的const属性， 并且#define对作用域不敏感，const可以定义某个类专属的常量；\n    \n    const int gameplayer::numturns;\n    \n    \n    1\n    \n\n 2. class专属常量。为确保此常量至多只有一份实体，你必须让它成为一个static成员：\n    \n    class gameplayer{\n    \tprivate:\n    \t\tstatic const int numturns = 5; // 常量声明\n    \t\tint scores[numturns]; // 使用该常量\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. enum是不可以取地址的，enum hack是模板原编程的基础技术，见item 48\n\n 4. #define带来的安全性可以使用模板inline函数实现， 见item 30\n    \n    template<typename t> // 暂时用模板的typename代替\n    inline void callwithmax(const t& a, const t& b){\n        f(a > b ? a : b);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 5. 对于单纯常量，最好以const对象或enums替换＃defines。\n\n 6. 对于形似函数的宏（macros），最好改用inline函数替换＃defines。\n\n\n# item 03：尽可能使用const， use const whenever possible.\n\n该用const的地方，尽可能使用const\n\n 1. 类内的变量是否为const?\n\n 2. 指针的双重const， 在什么之前就修饰什么， 指针为const， 还是指针指向的值为const, 常量指针\n    \n    const char* const authorname = "quincy"\n    \n    \n    1\n    \n\n 3. 函数的参数是否传const引用？ 使用const修饰， 会明示参数是否被改变（引用不改变， 要加const表示出来）；\n\n 4. 成员函数后是加const， 代表这个成员函数不会修改类内的值；\n\n 5. 返回值是否要成为const（为什么？）， 看返回值类型是否是需要const不允许变动(防止用户自身的村务使用， 不放弃高效性)， 其次是避免成为左值被修改；\n\na.get_data()=3;  // 返回一个const， 这种操作就是不合法的；\n\n\n1\n\n\n 6. mutable可以释放掉non-static成员变量的bitwise constness约束；\n    \n    class ctextblock{\n        public:\n        \tstd::size_t length() const;\n        private:\n        \tchar* ptext;\n        \tmutable std::size_t textlength; //这些变量可能总是会被改变\n    \t    mutable bool lengthisvalis;\n    // 在length()中， 会频繁改变上述的两个变量；  \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    \n    key:\n    \n    * 将某些东西声明为const可帮助编译器提示出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。\n    \n    * 编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”（conceptual constness）。\n    \n    * 当const和non-const成员函数有着实质等价的实现时(确实是要有两个版本)，令non-const版本调用const版本可避免代码重复。因为const可以兼容non-const的输入， 但是non-const不可以兼容const的输入\n      \n      class textblock {\n      public:\n          ...\n          const char& operator[](std::size_t position) const // 表示不改变类成员\n          {\n              ... // do bounds checking\n              ... // log access data\n              ... // verify data integrity\n              return text[position];\n          }\n          char& operator[](std::size_t position)\n          {\n              ... // do bounds checking\n              ... // log access data\n              ... // verify data integrity\n              return text[position];\n          }\n      private:\n          std::string text;\n      };\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      \n\n\n# item 04：make sure that objects are initialized before they\'re used. 对象在使用前已先被初始化\n\n 1. 没有初始化的值，在读它的时候会导致不明确的行为， 变量里面包含的内容都是半随机状态；\n\n 2. 在初始化列表里面， 列出所有的成员变量， 免得遗漏， 除非记得住哪些不用初始值；\n    \n    1. 实在太多的话， 用一个private函数包一下能够赋值处理的， 也可以；\n    2. 初始化的顺序总是按照声明顺序来， 不是按照初始化列表的顺序\n\n 3. 成员变量是const或者reference， 就一定要初始化， 因为后面不能再被赋值了；\n\n 4. 如果有一个non-local static对象， 没有办法保证是否使用的时候已经初始化， 那就在本地搞一个static函数（处理static对象的函数叫做static的函数）把这个对象包起来，返回一个指向这个对象的reference， 这样， 外部的static对象就变成了本地的static对象， 这也是singleton模式的一个常见实现手法（这种手法叫做reference returning）\n    \n    directory& tempdir(){\n    \tstatic directory& td; // more effective c++里面， 限制对象数目的方式， 好像是一样的\n    \treturn td; // 还是把non-loca的static的对象，改变成local static的对象比较好；\n    }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 5. 任何一种non const static 对象，在多线程环境下， 都会有线程安全的问题；non const代表了可以被改变， 多线程可以同时改变它；',charsets:{cjk:!0}},{title:"构造，析构， 和重载赋值运算符",frontmatter:{title:"构造，析构， 和重载赋值运算符",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/0d9870/"},regularPath:"/01.Wiki/19.Reading%20Notes/01.Effective%20C++/02.%E6%9E%84%E9%80%A0_%E6%9E%90%E6%9E%84_%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD.html",relativePath:"01.Wiki/19.Reading Notes/01.Effective C++/02.构造_析构_运算符重载.md",key:"v-1497abd7",path:"/pages/0d9870/",headers:[{level:3,title:"Item 05：Know what  functions C++silently writes and calls. 了解C++默默编写并调用哪些函数",slug:"item-05-know-what-functions-c-silently-writes-and-calls-了解c-默默编写并调用哪些函数",normalizedTitle:"item 05：know what  functions c++silently writes and calls. 了解c++默默编写并调用哪些函数",charIndex:null},{level:3,title:"Item 06：Explicitly     disallow the use of compiler-generated functions you do not want. 若不想使用编译器自动生成的函数，就该明确拒绝",slug:"item-06-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want-若不想使用编译器自动生成的函数-就该明确拒绝",normalizedTitle:"item 06：explicitly     disallow the use of compiler-generated functions you do not want. 若不想使用编译器自动生成的函数，就该明确拒绝",charIndex:null},{level:3,title:"Item 07：Declare destructors virtual in polymorphic base classes. 为多态基类声明virtual析构函数",slug:"item-07-declare-destructors-virtual-in-polymorphic-base-classes-为多态基类声明virtual析构函数",normalizedTitle:"item 07：declare destructors virtual in polymorphic base classes. 为多态基类声明virtual析构函数",charIndex:1619},{level:3,title:"Item 08：Prevent     exceptions from leaving destructors. 别让异常逃离析构函数",slug:"item-08-prevent-exceptions-from-leaving-destructors-别让异常逃离析构函数",normalizedTitle:"item 08：prevent     exceptions from leaving destructors. 别让异常逃离析构函数",charIndex:null},{level:3,title:"Item 09：Never call virtual functions during construction or destruction. 绝不在构造和析构过程中调用virtual函数",slug:"item-09-never-call-virtual-functions-during-construction-or-destruction-绝不在构造和析构过程中调用virtual函数",normalizedTitle:"item 09：never call virtual functions during construction or destruction. 绝不在构造和析构过程中调用virtual函数",charIndex:2271},{level:3,title:"Item 10：Have assignment     operators return a reference tothis. 令operator=返回一个     reference to this",slug:"item-10-have-assignment-operators-return-a-reference-to-this-令operator-返回一个-reference-to-this",normalizedTitle:"item 10：have assignment     operators return a reference tothis. 令operator=返回一个     reference to this",charIndex:null},{level:3,title:"Item 11：Handle assignment to self in operator=. 在operator=中判断“自我赋值”",slug:"item-11-handle-assignment-to-self-in-operator-在operator-中判断-自我赋值",normalizedTitle:"item 11：handle assignment to self in operator=. 在operator=中判断“自我赋值”",charIndex:2950},{level:3,title:"Item 12：Copy all parts of an object. 复制对象时勿忘其每一个成分",slug:"item-12-copy-all-parts-of-an-object-复制对象时勿忘其每一个成分",normalizedTitle:"item 12：copy all parts of an object. 复制对象时勿忘其每一个成分",charIndex:3181}],headersStr:"Item 05：Know what  functions C++silently writes and calls. 了解C++默默编写并调用哪些函数 Item 06：Explicitly     disallow the use of compiler-generated functions you do not want. 若不想使用编译器自动生成的函数，就该明确拒绝 Item 07：Declare destructors virtual in polymorphic base classes. 为多态基类声明virtual析构函数 Item 08：Prevent     exceptions from leaving destructors. 别让异常逃离析构函数 Item 09：Never call virtual functions during construction or destruction. 绝不在构造和析构过程中调用virtual函数 Item 10：Have assignment     operators return a reference tothis. 令operator=返回一个     reference to this Item 11：Handle assignment to self in operator=. 在operator=中判断“自我赋值” Item 12：Copy all parts of an object. 复制对象时勿忘其每一个成分",content:'# Item 05：Know what functions C++silently writes and calls. 了解C++默默编写并调用哪些函数\n\n 5. C++ 自动生成的ctor，dtor， copy assignment（op=重载），(big three, 除此之外还有移动构造， 移动赋值， 不过这需要自己的写）\n    \n    class Empty{\n        public:\n        \tEmpty() { ... }\n        \tEmpty(const Empty& rhs){ ... }\n        \t~Empty() { ... }\n    \n    \t    Empty& operator=(const Empty& rhs) { ... }\n    }\n    \n    int main(){\n        Empty e1;\n        Empty e2(e1);\n    \n        e2 = e1;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n    \n    1. 默认的构造， 析构函数， 只能是浅复制， 值的复制， 如果有指针， 只能指向同一个地址， 而不能有两份内存出来；\n    \n    2. 对const成员变量， reference变量， 自动生成的copy assignment是不能对这些东西进行赋值和拷贝操作的\n       \n       class Timekeeper{\n       public:\n       \tTimekeeper();\n       \tvirtual ~TimeKeeper();\n       }\n       \n       \n       1\n       2\n       3\n       4\n       5\n       \n    \n    3. 经验： class里面如果有一个virtual的函数， 就为这个类弄一个virtual的析构函数；\n    \n    4. 纯虚函数？纯虚函数会带来一个抽象基类， 抽象基类不能实例化；但是抽象基类要有一个纯虚的析构函数，需要在H文件里面单独提供一份定义；这样在析构的时候就不会显式运行到在这个纯虚函数；\n       \n       让其他的子类在析构的时候， 会使用到子类自己的析构函数， 而不是默认的析构， 或者是纯虚基类的析构（纯虚基类的纯虚析构函数， 是空的）\n       \n       class AWOV(){\n       public:\n       \tvirtual ~AWOV() = 0;\n       }\n       \n       AMOV::~AMOV() { } // 在.h文件里面单独提供一份定义， 因为虽然是纯虚函数， 但是子类在析构的时候，还是会调用到这个\n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       \n    \n    \n    # Item 06：Explicitly disallow the use of compiler-generated functions you do not want. 若不想使用编译器自动生成的函数，就该明确拒绝\n\n 6. 如何拒绝使用这些自动生成的函数，\n    \n    1. 使用=delete来禁止使用拷贝构造， 拷贝赋值，\n    2. 以前在没有=delete关键字的时候， 可以把这些函数放在private里面\n    \n    \n    # Item 07：Declare destructors virtual in polymorphic base classes. 为多态基类声明virtual析构函数\n\n 7. 多态基类的析构函数最好弄成virtual的， 如果是non-virtual的，那么借由基类指针传进来的对象， 析构的时候， 派生出来的部分会被漏掉\n    \n    1. 如果析构函数不是virtual的， 那么delete基类指针来进行析构的话。derived部分偶尔会被遗漏掉；\n    2. 为什么不是virtual的构造函数？因为我们构造的时候， 基本上都是用derived类来进行构造的；\n    \n    问题： 对于virtual function， 如何进行派生使用， 如何借由virtual函数来进行多态？\n\n\n# Item 08：Prevent exceptions from leaving destructors. 别让异常逃离析构函数\n\n 5. 析构函数不要吐出异常（别让异常逃离析构函数）, 为什么?\n    \n    1. 如果不处理异常， 会带来一些不明确的行为， 或者程序半路断掉\n    2. 所以要好好善后；怎么办，如果析构函数真的抛出异常， 就在析构函数里面进行try{} catch{} , 要么记录下来，立即停止程序，不重要的异常可以不停下来， 让程序继续进行；也可以用单独的函数来处理异常， 但总之就是在类内部， 处理好异常， 不要让异常逃出析构， 这样可以封装得更完整\n\n\n# Item 09：Never call virtual functions during construction or destruction. 绝不在构造和析构过程中调用virtual函数\n\n 9. 构造和析构函数中， 不要调用virtual函数， 为什么?， static函数相关的使用场景和效果？\n    \n    1. 构造的时候， derived对象还没有生成， 所以这个时候还用不到自身特化的virtual function， 只能用base class里面的版本；\n    2. 析构的时候， 只要一开始析构， 对象内的derived class成员变量就是未定义值， 所以这个时候virtual function还是会跑到父类里面去；\n    3. 父类里面的static函数， 有什么作用？ 是在函数编译的时候， 放在什么段里面？（很大程度和python的static method类似， 能通过类名调用） static函数里面不能调用non-static成员变量， 也不能调用non-static成员函数; static函数没有this指针\n\n\n# Item 10：Have assignment operators return a reference to*this. 令operator=返回一个 reference to *this\n\n 10. operator= 最好是返回一个 reference to *this,\n     \n     1. 因为这样可以拥有连续赋值的特性， 例如： x = y = z = 15\n\n\n# Item 11：Handle assignment to self in operator=. 在operator=中判断“自我赋值”\n\nWidget& Widget::operator=(const Widget& rhs){\n\tif(this == &rhs)\n        return *this;\n\tdelete pb;\n\tpb = new Bitmap(*rhs.pb);\n\treturn *rhs;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Item 12：Copy all parts of an object. 复制对象时勿忘其每一个成分\n\n 12. 自定义拷贝构造函数的时候， 要复制所有local的变量， 可以使用基类的一些拷贝构造函数对一些成员拷贝；\n     \n     因为有一些基类对象的拷贝， 必须要通过基类的拷贝构造函数来进行深度拷贝；\n     \n     PriorityCustomer::operator=(const PriorityCustomer &rhs){\n         logCall("......");\n         Customer::operator=(rhs); // 这里直接调用了base class的拷贝构造函数来进行；\n         priority = rhs.priority;\n         return *this;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n     \n     不要使用copy assignment 来调用copy constructor; 反过来也不建议， 因为这就像对一个构造好的对象进行操作， 先有鸡还是先有蛋？\n     \n     最终还是要将他么共同的一些实际操作放到函数里面， 因为只要使用上面两种函数， 都会要实现构造一个临时的对象， 但对象在这些函数运行过程中都是没有构造好的；',normalizedContent:'# item 05：know what functions c++silently writes and calls. 了解c++默默编写并调用哪些函数\n\n 5. c++ 自动生成的ctor，dtor， copy assignment（op=重载），(big three, 除此之外还有移动构造， 移动赋值， 不过这需要自己的写）\n    \n    class empty{\n        public:\n        \tempty() { ... }\n        \tempty(const empty& rhs){ ... }\n        \t~empty() { ... }\n    \n    \t    empty& operator=(const empty& rhs) { ... }\n    }\n    \n    int main(){\n        empty e1;\n        empty e2(e1);\n    \n        e2 = e1;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n    \n    1. 默认的构造， 析构函数， 只能是浅复制， 值的复制， 如果有指针， 只能指向同一个地址， 而不能有两份内存出来；\n    \n    2. 对const成员变量， reference变量， 自动生成的copy assignment是不能对这些东西进行赋值和拷贝操作的\n       \n       class timekeeper{\n       public:\n       \ttimekeeper();\n       \tvirtual ~timekeeper();\n       }\n       \n       \n       1\n       2\n       3\n       4\n       5\n       \n    \n    3. 经验： class里面如果有一个virtual的函数， 就为这个类弄一个virtual的析构函数；\n    \n    4. 纯虚函数？纯虚函数会带来一个抽象基类， 抽象基类不能实例化；但是抽象基类要有一个纯虚的析构函数，需要在h文件里面单独提供一份定义；这样在析构的时候就不会显式运行到在这个纯虚函数；\n       \n       让其他的子类在析构的时候， 会使用到子类自己的析构函数， 而不是默认的析构， 或者是纯虚基类的析构（纯虚基类的纯虚析构函数， 是空的）\n       \n       class awov(){\n       public:\n       \tvirtual ~awov() = 0;\n       }\n       \n       amov::~amov() { } // 在.h文件里面单独提供一份定义， 因为虽然是纯虚函数， 但是子类在析构的时候，还是会调用到这个\n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       \n    \n    \n    # item 06：explicitly disallow the use of compiler-generated functions you do not want. 若不想使用编译器自动生成的函数，就该明确拒绝\n\n 6. 如何拒绝使用这些自动生成的函数，\n    \n    1. 使用=delete来禁止使用拷贝构造， 拷贝赋值，\n    2. 以前在没有=delete关键字的时候， 可以把这些函数放在private里面\n    \n    \n    # item 07：declare destructors virtual in polymorphic base classes. 为多态基类声明virtual析构函数\n\n 7. 多态基类的析构函数最好弄成virtual的， 如果是non-virtual的，那么借由基类指针传进来的对象， 析构的时候， 派生出来的部分会被漏掉\n    \n    1. 如果析构函数不是virtual的， 那么delete基类指针来进行析构的话。derived部分偶尔会被遗漏掉；\n    2. 为什么不是virtual的构造函数？因为我们构造的时候， 基本上都是用derived类来进行构造的；\n    \n    问题： 对于virtual function， 如何进行派生使用， 如何借由virtual函数来进行多态？\n\n\n# item 08：prevent exceptions from leaving destructors. 别让异常逃离析构函数\n\n 5. 析构函数不要吐出异常（别让异常逃离析构函数）, 为什么?\n    \n    1. 如果不处理异常， 会带来一些不明确的行为， 或者程序半路断掉\n    2. 所以要好好善后；怎么办，如果析构函数真的抛出异常， 就在析构函数里面进行try{} catch{} , 要么记录下来，立即停止程序，不重要的异常可以不停下来， 让程序继续进行；也可以用单独的函数来处理异常， 但总之就是在类内部， 处理好异常， 不要让异常逃出析构， 这样可以封装得更完整\n\n\n# item 09：never call virtual functions during construction or destruction. 绝不在构造和析构过程中调用virtual函数\n\n 9. 构造和析构函数中， 不要调用virtual函数， 为什么?， static函数相关的使用场景和效果？\n    \n    1. 构造的时候， derived对象还没有生成， 所以这个时候还用不到自身特化的virtual function， 只能用base class里面的版本；\n    2. 析构的时候， 只要一开始析构， 对象内的derived class成员变量就是未定义值， 所以这个时候virtual function还是会跑到父类里面去；\n    3. 父类里面的static函数， 有什么作用？ 是在函数编译的时候， 放在什么段里面？（很大程度和python的static method类似， 能通过类名调用） static函数里面不能调用non-static成员变量， 也不能调用non-static成员函数; static函数没有this指针\n\n\n# item 10：have assignment operators return a reference to*this. 令operator=返回一个 reference to *this\n\n 10. operator= 最好是返回一个 reference to *this,\n     \n     1. 因为这样可以拥有连续赋值的特性， 例如： x = y = z = 15\n\n\n# item 11：handle assignment to self in operator=. 在operator=中判断“自我赋值”\n\nwidget& widget::operator=(const widget& rhs){\n\tif(this == &rhs)\n        return *this;\n\tdelete pb;\n\tpb = new bitmap(*rhs.pb);\n\treturn *rhs;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# item 12：copy all parts of an object. 复制对象时勿忘其每一个成分\n\n 12. 自定义拷贝构造函数的时候， 要复制所有local的变量， 可以使用基类的一些拷贝构造函数对一些成员拷贝；\n     \n     因为有一些基类对象的拷贝， 必须要通过基类的拷贝构造函数来进行深度拷贝；\n     \n     prioritycustomer::operator=(const prioritycustomer &rhs){\n         logcall("......");\n         customer::operator=(rhs); // 这里直接调用了base class的拷贝构造函数来进行；\n         priority = rhs.priority;\n         return *this;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n     \n     不要使用copy assignment 来调用copy constructor; 反过来也不建议， 因为这就像对一个构造好的对象进行操作， 先有鸡还是先有蛋？\n     \n     最终还是要将他么共同的一些实际操作放到函数里面， 因为只要使用上面两种函数， 都会要实现构造一个临时的对象， 但对象在这些函数运行过程中都是没有构造好的；',charsets:{cjk:!0}},{title:"资源管理",frontmatter:{title:"资源管理",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/ad8b8b/"},regularPath:"/01.Wiki/19.Reading%20Notes/01.Effective%20C++/03.%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.html",relativePath:"01.Wiki/19.Reading Notes/01.Effective C++/03.资源管理.md",key:"v-e027eb68",path:"/pages/ad8b8b/",headers:[{level:3,title:"资源管理, Resource Management",slug:"资源管理-resource-management",normalizedTitle:"资源管理, resource management",charIndex:2},{level:3,title:"Item 13：以对象管理资源 Use objects to   manage resources.",slug:"item-13-以对象管理资源-use-objects-to-manage-resources",normalizedTitle:"item 13：以对象管理资源 use objects to   manage resources.",charIndex:null},{level:3,title:"Item 14：在资源管理类中小心copying行为 Think     carefully about copyingbehavior in resource-managing classes.",slug:"item-14-在资源管理类中小心copying行为-think-carefully-about-copyingbehavior-in-resource-managing-classes",normalizedTitle:"item 14：在资源管理类中小心copying行为 think     carefully about copyingbehavior in resource-managing classes.",charIndex:null},{level:3,title:"Item 15：在资源管理类中提供对原始资源的访问 Provide access to raw resources in resource-managing classes.",slug:"item-15-在资源管理类中提供对原始资源的访问-provide-access-to-raw-resources-in-resource-managing-classes",normalizedTitle:"item 15：在资源管理类中提供对原始资源的访问 provide access to raw resources in resource-managing classes.",charIndex:1046},{level:3,title:"Item 16：成对使用new和delete时要采取相同形式 Use the same form in corresponding uses of new and delete.",slug:"item-16-成对使用new和delete时要采取相同形式-use-the-same-form-in-corresponding-uses-of-new-and-delete",normalizedTitle:"item 16：成对使用new和delete时要采取相同形式 use the same form in corresponding uses of new and delete.",charIndex:1627},{level:3,title:"Item 17：以独立语句将newed对象置入智能指针 Store newed objects in smart pointers in standalone statements.",slug:"item-17-以独立语句将newed对象置入智能指针-store-newed-objects-in-smart-pointers-in-standalone-statements",normalizedTitle:"item 17：以独立语句将newed对象置入智能指针 store newed objects in smart pointers in standalone statements.",charIndex:2127},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"资源管理, Resource Management Item 13：以对象管理资源 Use objects to   manage resources. Item 14：在资源管理类中小心copying行为 Think     carefully about copyingbehavior in resource-managing classes. Item 15：在资源管理类中提供对原始资源的访问 Provide access to raw resources in resource-managing classes. Item 16：成对使用new和delete时要采取相同形式 Use the same form in corresponding uses of new and delete. Item 17：以独立语句将newed对象置入智能指针 Store newed objects in smart pointers in standalone statements. ",content:"# 资源管理, Resource Management\n\n\n# Item 13：以对象管理资源 Use objects to manage resources.\n\n 13. 用对象的形式管理资源 (RAII， Resource Acquisition Is Initialization)，所以要特别注意构造和析构函数，在使用对象的时候可以使用shared_ptr之类的智能指针来管理每个对象的实例；\n     \n     1. 返回没有加工的指针， 容易造成资源泄露， 忘记delete\n     2. 手动释放资源， 可能会跑不到释放的那个地方， 也有可能造成double release；\n     3. 不要多个auto_ptr()指向同一个对象， 不然对象可能会被多次删除， 程序就会有未定义行为；\n     4. 使用factory设计模式来供给需要的Invest对象\n     5. copy assignment要让原来的指针变成null\n     6. 使用reference counting smart pointer, 使用shared_ptr() 相关的实现；\n\n\n# Item 14：在资源管理类中小心copying行为 Think carefully about copyingbehavior in resource-managing classes.\n\n 14. 虽然都是RAII原则， 但是要特别注意拷贝构造的行为，\n     \n     1. 一些复制行为明显是没有意义， 不合理的， 书里面用linux中的mutex的lock和unlock函数来举例子， 这个时候要禁止复制的行为；--\x3e uncopyable(陈硕muduo库里面， 好像也有类似的指定操作)， 或者把这些copy assignment设为private或者=delete\n     2. 底层资源使用reference-count的方式；\n     3. 要清楚自己做的是深拷贝还是浅拷贝，要确保自己是在做深拷贝， 不仅拷贝指针， 也拷贝指针所指的内存块；\n     4. 有时候拷贝其实是一种转移， 要确保系统中给目前只有这一个对象， 从一个地方转移到另外一个地方--\x3e auto_ptr， shared_ptr(), 对这些指针的内部构造要很熟悉。【rebuild the auto ptr code demo】\n     5. 自动生成的拷贝函数不一定能够满足需求；\n\n\n# Item 15：在资源管理类中提供对原始资源的访问 Provide access to raw resources in resource-managing classes.\n\n 15. 资源管理类中， 提供对原始资源的访问接口， 例如x.get， get_instance这种接口, 让类有接口返回内部资源\n     \n     1. 返回数字，\n     \n     2. 返回一个instance\n     \n     3. singleton的设计模式是怎么做的?\n     \n     4. factory模式是怎么做的？\n     \n     5. 操作符重载, 这是一种隐式转换的方法， 客户使用起来比较方便，但是显示转换会比较安全（使用xxxx.get()的模式）\n        \n        class Font{\n        public:\n            operator FontHandle() const { //也可以重载类型转换函数；\n            \treturn f;\n            }\n        }\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        \n\n\n# Item 16：成对使用new和delete时要采取相同形式 Use the same form in corresponding uses of new and delete.\n\n 16. new和delete使用的时候要成对使用， 并且注意区别数组和对象的delete\n     \n     std::string* stringPtr1 = new std::string;\n     std::string* stringPtr2 = new std::string[100];\n     \n     delete stringPtr1; // 删除一个对象， 一个指针；\n     delete [] stringPtr2; // 删除一个数组， 一块内存\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n     * operator new, new operator的区别？\n     * placement new / new placement区别？[Item 49之后有一些解释]\n     \n     \n     # Item 17：以独立语句将newed对象置入智能指针 Store newed objects in smart pointers in standalone statements.\n\n 17. 要保证new这个语句是单独执行的， 先于智能指针的赋值操作；\n     \n     processWidget(std::tr1::shared_ptr<Widget>(new Widget), priority()); // 万一priority()这个函数抛出执行异常会怎样？\n     \n     // 用一个单独的语句来构造shared_ptr变量; 保证这行代码是单独执行的;\n     std::tr1::shared_ptr<Widget> pw(new Widget);\n     processWidget(pw, priority());\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n\n#",normalizedContent:"# 资源管理, resource management\n\n\n# item 13：以对象管理资源 use objects to manage resources.\n\n 13. 用对象的形式管理资源 (raii， resource acquisition is initialization)，所以要特别注意构造和析构函数，在使用对象的时候可以使用shared_ptr之类的智能指针来管理每个对象的实例；\n     \n     1. 返回没有加工的指针， 容易造成资源泄露， 忘记delete\n     2. 手动释放资源， 可能会跑不到释放的那个地方， 也有可能造成double release；\n     3. 不要多个auto_ptr()指向同一个对象， 不然对象可能会被多次删除， 程序就会有未定义行为；\n     4. 使用factory设计模式来供给需要的invest对象\n     5. copy assignment要让原来的指针变成null\n     6. 使用reference counting smart pointer, 使用shared_ptr() 相关的实现；\n\n\n# item 14：在资源管理类中小心copying行为 think carefully about copyingbehavior in resource-managing classes.\n\n 14. 虽然都是raii原则， 但是要特别注意拷贝构造的行为，\n     \n     1. 一些复制行为明显是没有意义， 不合理的， 书里面用linux中的mutex的lock和unlock函数来举例子， 这个时候要禁止复制的行为；--\x3e uncopyable(陈硕muduo库里面， 好像也有类似的指定操作)， 或者把这些copy assignment设为private或者=delete\n     2. 底层资源使用reference-count的方式；\n     3. 要清楚自己做的是深拷贝还是浅拷贝，要确保自己是在做深拷贝， 不仅拷贝指针， 也拷贝指针所指的内存块；\n     4. 有时候拷贝其实是一种转移， 要确保系统中给目前只有这一个对象， 从一个地方转移到另外一个地方--\x3e auto_ptr， shared_ptr(), 对这些指针的内部构造要很熟悉。【rebuild the auto ptr code demo】\n     5. 自动生成的拷贝函数不一定能够满足需求；\n\n\n# item 15：在资源管理类中提供对原始资源的访问 provide access to raw resources in resource-managing classes.\n\n 15. 资源管理类中， 提供对原始资源的访问接口， 例如x.get， get_instance这种接口, 让类有接口返回内部资源\n     \n     1. 返回数字，\n     \n     2. 返回一个instance\n     \n     3. singleton的设计模式是怎么做的?\n     \n     4. factory模式是怎么做的？\n     \n     5. 操作符重载, 这是一种隐式转换的方法， 客户使用起来比较方便，但是显示转换会比较安全（使用xxxx.get()的模式）\n        \n        class font{\n        public:\n            operator fonthandle() const { //也可以重载类型转换函数；\n            \treturn f;\n            }\n        }\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        \n\n\n# item 16：成对使用new和delete时要采取相同形式 use the same form in corresponding uses of new and delete.\n\n 16. new和delete使用的时候要成对使用， 并且注意区别数组和对象的delete\n     \n     std::string* stringptr1 = new std::string;\n     std::string* stringptr2 = new std::string[100];\n     \n     delete stringptr1; // 删除一个对象， 一个指针；\n     delete [] stringptr2; // 删除一个数组， 一块内存\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n     * operator new, new operator的区别？\n     * placement new / new placement区别？[item 49之后有一些解释]\n     \n     \n     # item 17：以独立语句将newed对象置入智能指针 store newed objects in smart pointers in standalone statements.\n\n 17. 要保证new这个语句是单独执行的， 先于智能指针的赋值操作；\n     \n     processwidget(std::tr1::shared_ptr<widget>(new widget), priority()); // 万一priority()这个函数抛出执行异常会怎样？\n     \n     // 用一个单独的语句来构造shared_ptr变量; 保证这行代码是单独执行的;\n     std::tr1::shared_ptr<widget> pw(new widget);\n     processwidget(pw, priority());\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n\n#",charsets:{cjk:!0}},{title:"设计与声明",frontmatter:{title:"设计与声明",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/e85768/"},regularPath:"/01.Wiki/19.Reading%20Notes/01.Effective%20C++/04.%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E.html",relativePath:"01.Wiki/19.Reading Notes/01.Effective C++/04.设计与声明.md",key:"v-7b0d9a9e",path:"/pages/e85768/",headers:[{level:2,title:"设计与声明， Design and Declarations",slug:"设计与声明-design-and-declarations",normalizedTitle:"设计与声明， design and declarations",charIndex:2},{level:3,title:"Item 18：让接口容易被正确使用，不易被误用 Make interfaces easy to usecorrectly and hard to use incorrectly.",slug:"item-18-让接口容易被正确使用-不易被误用-make-interfaces-easy-to-usecorrectly-and-hard-to-use-incorrectly",normalizedTitle:"item 18：让接口容易被正确使用，不易被误用 make interfaces easy to usecorrectly and hard to use incorrectly.",charIndex:37},{level:3,title:"Item 19：设计class犹如设计type Treat class design as type design.",slug:"item-19-设计class犹如设计type-treat-class-design-as-type-design",normalizedTitle:"item 19：设计class犹如设计type treat class design as type design.",charIndex:930},{level:3,title:"Item 20：宁以pass-by-reference-to-const替换pass-by-value     Prefer pass-by-reference-to-const to pass-by-value.",slug:"item-20-宁以pass-by-reference-to-const替换pass-by-value-prefer-pass-by-reference-to-const-to-pass-by-value",normalizedTitle:"item 20：宁以pass-by-reference-to-const替换pass-by-value     prefer pass-by-reference-to-const to pass-by-value.",charIndex:null},{level:3,title:"Item 21：必须返回对象时，别妄想返回其reference     Don't try to return a reference when you must return an object.",slug:"item-21-必须返回对象时-别妄想返回其reference-don-t-try-to-return-a-reference-when-you-must-return-an-object",normalizedTitle:"item 21：必须返回对象时，别妄想返回其reference     don't try to return a reference when you must return an object.",charIndex:null},{level:3,title:"Item 22：将成员变量声明为private Declare     data members private.",slug:"item-22-将成员变量声明为private-declare-data-members-private",normalizedTitle:"item 22：将成员变量声明为private declare     data members private.",charIndex:null},{level:3,title:"Item 23：宁以non-member、non-friend替换member函数     Prefer non-member non-friend functions to member functions.",slug:"item-23-宁以non-member、non-friend替换member函数-prefer-non-member-non-friend-functions-to-member-functions",normalizedTitle:"item 23：宁以non-member、non-friend替换member函数     prefer non-member non-friend functions to member functions.",charIndex:null},{level:3,title:"Item 24：若所有参数皆需类型转换，请为此采用non-member函数 Declarenon-member functions when type conversions should apply to all parameters.",slug:"item-24-若所有参数皆需类型转换-请为此采用non-member函数-declarenon-member-functions-when-type-conversions-should-apply-to-all-parameters",normalizedTitle:"item 24：若所有参数皆需类型转换，请为此采用non-member函数 declarenon-member functions when type conversions should apply to all parameters.",charIndex:3817},{level:3,title:"Item 25：考虑写出一个不抛异常的swap函数 Consider support for a non-throwing swap.",slug:"item-25-考虑写出一个不抛异常的swap函数-consider-support-for-a-non-throwing-swap",normalizedTitle:"item 25：考虑写出一个不抛异常的swap函数 consider support for a non-throwing swap.",charIndex:5047},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"设计与声明， Design and Declarations Item 18：让接口容易被正确使用，不易被误用 Make interfaces easy to usecorrectly and hard to use incorrectly. Item 19：设计class犹如设计type Treat class design as type design. Item 20：宁以pass-by-reference-to-const替换pass-by-value     Prefer pass-by-reference-to-const to pass-by-value. Item 21：必须返回对象时，别妄想返回其reference     Don't try to return a reference when you must return an object. Item 22：将成员变量声明为private Declare     data members private. Item 23：宁以non-member、non-friend替换member函数     Prefer non-member non-friend functions to member functions. Item 24：若所有参数皆需类型转换，请为此采用non-member函数 Declarenon-member functions when type conversions should apply to all parameters. Item 25：考虑写出一个不抛异常的swap函数 Consider support for a non-throwing swap. ",content:'# 设计与声明， Design and Declarations\n\n\n# Item 18：让接口容易被正确使用，不易被误用 Make interfaces easy to usecorrectly and hard to use incorrectly.\n\n 18. 接口设计简明， 不要让用户对其有歧义\n     \n     1. 建立新类型，限制类型上的操作， 束缚对象值，消除客户的资源管理责任, 一个new type的案例,(enum会带来类型安全的问题? 什么是类型安全?)\n        \n        class Month{\n          public:\n            static Month Jan(){return Month(1);}  //见下文为什么使用函数，不使用对象\n            static Month Feb(){return Month(2);}\n            ...\n            static Month Dec(){return Month(12);} \n            ...\n          private:\n            explicit Month(int m);  //explicit禁止参数隐式转换，private禁止用户生成自定义的月份\n            ...\n        };\n        \n        Date d(Month::Mar(), Day(30), Year(1995)); //正确\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n        10\n        11\n        12\n        13\n        \n     \n     2. 好好设计程序的类型系统， 使用class， template， typedef， struct， enum等等(类型系统的C++最佳实践方式?)\n\n\n# Item 19：设计class犹如设计type Treat class design as type design.\n\n 19. 设计class的时候， 就好比设计type（一系列要注意的事项）\n     \n     * 新类型的对象要如何创建和销毁?\n     \n     这决定了要如何写构造函数和析构函数，包括要使用什么内存分配和释放函数，即new还是new[]，delete还是delete[]，见第16章\n     \n     * 对象初始化要如何区别于赋值?\n     \n     这决定了你如何写，如何区别构造函数和赋值运算符，以及不要把初始化与赋值混淆，因为它们的语义不同，构造函数适用于未创建的对象，赋值适用于已创建的对象，这也是为什么我们要在构造函数中使用初始化列表而不使用赋值的原因，见第4章和第12章。\n     \n     * 新类型的对象传值有什么意义?\n     \n     要记住拷贝构造函数决定了你的类型是如何被传值的，因为传值会生成本地的拷贝。\n     \n     * 新类型的合法数值有什么限制?\n     \n     通常情况下，并不是成员的任何数值组合都是合法的。要让数据成员合法，我们需要根据合法的组合，在成员函数中对数值进行检测，尤其是构造函数，赋值运算符和setter。这也会影响到使用它的函数会抛出什么异常。\n     \n     * 新类型属于某个继承层次吗?\n     \n     如果你的新类型继承自某个已有的类，你的设计将被这些父类影响到，尤其是父类的某些函数是不是虚函数。如果你的新类型要作为一个父类，你将要决定把哪些函数声明为虚函数，尤其要注意析构函数，见第7章。\n     \n     * 新类型允许什么样的转换?\n     \n     新类型的对象将会在程序的海洋中与其它各种各样的类型并用，这时你就要决定是否允许类型的转换。如果你希望把T1隐式转换为T2，你可以在T1中定义一个转换函数，例如operator T2，或者在T2中定义一个兼容T1的不加explicit修饰的构造函数。\n     \n     如果希望使用显式转换，你要定义执行显示转换的函数，详见第15章。\n     \n     * 什么运算符和函数对于你的新类型是有意义的?\n     \n     这决定了你要声明哪些函数，包括成员函数，非成员函数，友元函数等。\n     \n     * 你要禁止哪些标准函数?\n     \n     如果不希望使用编译器会自动生成的标准函数，把它们声明为私有，见第6章\n     \n     * 谁可以接触到成员?\n     \n     这影响到哪些成员是公有的，哪些是保护的，哪些是私有的。这也能帮你决定哪些类和函数是友元的，以及要不要使用嵌套类(nested class)。\n     \n     * 新类型的"隐藏接口"是什么?\n     \n     新类型对于性能，异常安全性，资源管理(例如锁和内存)有什么保障? 哪些问题是自动解决不需要用户操心的? 要实现这些保障，自然会对这个类的实现产生限制，例如要使用智能指针而不要使用裸指针。\n     \n     * 新类型有多通用?\n     \n     如果想让你的新类型通用于许多类型，定义一个类模板(class template)，而不是单个新类型。\n     \n     * 新类型真的是你需要的吗?\n       \n       如果定义一个子类只是为了给基类增加某些新功能，定义一些非成员的函数或者函数模板更加划算。\n     \n     * 如何创建和销毁， operator new, operator new[]. operator delete, operator delete[],\n     \n     * 对象初始化和对象的赋值有什么区别？ copy constructor 和copy assignment之间有什么区别？\n\n对一个新对象来说， pass by value意味着什么？因为要重载操作符， 函数， 和重载内存的分配和归还，\n\ntype cast的我呢提要怎么处理， 类型转换函数， operator T\n\n\n# Item 20：宁以pass-by-reference-to-const替换pass-by-value Prefer pass-by-reference-to-const to pass-by-value.\n\n 20. 函数的参数使用pass by reference to const替换pass by value，（内置类型， 其实pass by value也比较合适）\n     \n     1. 效率会比较高, 因为pass by value会产生临时对象, 对于非内置类型, 会调用copy constructor来进行构造\n     2. pass by reference to const 实际上传递的是指针, 能够支持继承类的多态特性.\n     3. 内置类型, STL迭代器和一些函数对象, 其实pass by value并不昂贵\n     \n     \n     # Item 21：必须返回对象时，别妄想返回其reference Don\'t try to return a reference when you must return an object.\n\n 21. 如果必须返回一个对象， 不要返回他的reference， 因为可能会返回一个local的对象，local对象的renference是没有用的；\n     \n     \n     # Item 22：将成员变量声明为private Declare data members private.\n\n 22. 成员变量声明为private\n     \n     1. public成员全部都是函数, 有利于语法一致性\n     2. 使用函数来对成员变量进行精确的访问控制， 这样能够给类更好的封装性\n     3. protect成员其实也是没有封装的, 因为如果在后续版本的代码里面,删除了这个protect成员, 其子类一样也需要修改\n     \n     \n     # Item 23：宁以non-member、non-friend替换member函数 Prefer non-member non-friend functions to member functions.\n\n 23. 使用non member, non friend来替换member函数\n     \n     1. 对于private成员, 能够接触它的就是成员函数+友元函数\n     2. 为的是增加封装性， 增加扩充的弹性，可以使用一个完全的第三方全局的function来进行, 称之为便携函数;\n     3. 可以把这个全局函数放在一个命名空间里面， 稍微约束一下它的作用域\n     \n     \n     # Item 24：若所有参数皆需类型转换，请为此采用non-member函数 Declarenon-member functions when type conversions should apply to all parameters.\n\n 24. 如果某个函数所有的参数都需要类型转换， 这个函数必须弄成non merber函数\n     \n     1. 隐式转换总体上会给程序带来隐患，因为如果出现了类型错误，编译器是不会报错的。\n     \n     2. 只有在参数表里出现的参数才可以进行隐式转换。例如operator*()这个函数, 局部的重载, 其实只能是X * 2这种形式, 但如果是要支持2 * x这种, 就需要全局的operator*()函数来支持;\n        \n        class Rational{\n          public:\n            ...\n            const Rational operator*(const Rational& lhs) const; // 成员函数\n          ...\n        };\n        result = oneHalf * 2; //编译通过\n        result = 2 * oneHalf; //编译错误\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        \n        \n        class Rational{...};\n        const Rational operator*(const Rational& lhs, const Rational& rhs){\n          return Rational(lhs.numerator() * rhs.numerator(),\n                          lhs.denominator() * rhs.denominator())\n        }//作为非成员函数, 两个参数都需要支持隐式转换\n        Rational oneFourth(1,4);\n        Rational result;\n        result = oneFourth * 2; //可以编译\n        result = 2 * oneFourth; //可以编译\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n        \n     \n     \n     # Item 25：考虑写出一个不抛异常的swap函数 Consider support for a non-throwing swap.\n\n 25. 给自己的类写的swap函数，不要抛出异常， 这是为了和STL库一样支持swap的异常安全；\n     \n     1. friend可以方位private变量和函数；\n     \n     2. 使用pimpl(the "pimpl" idiom，即"pointer to implementation"), 这样一来，要调换两个对象，直接交换指针就行了\n        \n        //这个类包含Widget类的数据\n        class WidgetImpl{\n          public:\n            ...\n          private:\n            int a,b,c;\n            std::vector<double> v; //高成本拷贝警告！\n        };\n        \n        //使用pimpl手法的类\n        class Widget{  \n          public:\n            Widget(const Widget& rhs);\n            //赋值运算符的实现见ch 10,11,12\n            Widget& operator=(const Widget& rhs){\n              ...\n              *pImpl = *(rhs.pImpl);\n              ...\n           }\n          ...\n          private:\n            WidgetImpl* pImpl; //使用pimpl指针来指向我们的数据\n        };\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n        10\n        11\n        12\n        13\n        14\n        15\n        16\n        17\n        18\n        19\n        20\n        21\n        22\n        23\n        \n     \n     3. 如果默认的std::swap不会对效率产生比较大的影响，例如对象的成员数据不多，直接使用是没有问题的，就不用大费周章搞这些了\n        \n        如果默认的std::swap会对你的函数/类模板产生效率影响: 给你的类使用pimpl手法，然后给它写一个只交换指针的swap成员函数，而且这个函数禁止抛出异常，然后:\n        \n        对于类模板，要在类模板相同的名空间下写一个自定义的swap，在里面调用swap成员函数\n        \n        对于类(不是类模板)，还要给std::swap进行特殊化，也在它里面调用swap成员函数\n        \n        调用swap的时候确保加上using语句来让std名空间里面的swap对编译器可见，然后swap函数前不要加任何名空间资格限制(qualification)\n     \n     4. 当默认的std::swap可能会拉低你自己的类的效率时，在自己的类里写一个swap成员函数，而且要保证它不会抛出异常\n        \n        写了swap成员函数，按照编程惯例还要写一个非成员swap函数，放在类或者类模板的名空间下，用它来调用成员swap函数。对于类(非模板)，还要特殊化std::swap\n        \n        在调用swap时，要加上一句using std::swap，然后调用时不需要再加任何名空间资格限制, 否则可能会调用到私有的swap函数里面去\n        \n        为了自定义的类而完全特殊化std模板是没问题的，但千万不要给std里添加任何东西。\n        \n        再或者, 直接使用类自带的namespace, 来重写swap函数;\n        \n        class Widget{\n          public:\n           ...\n            void swap(Widget& data){\n              using std::swap; // 这句稍后解释\n              swap(pImpl, other.pImpl); // 执行真正的swap，只交换指针\n            }\n           ...\n        };\n        \n        namespace std{\n          template<> // 完全特殊化的std::swap\n          void swap<Widget>(Widget& a, Widget& b){\n            a.swap(b);\n          }\n        }\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n        10\n        11\n        12\n        13\n        14\n        15\n        16\n        \n\n\n#',normalizedContent:'# 设计与声明， design and declarations\n\n\n# item 18：让接口容易被正确使用，不易被误用 make interfaces easy to usecorrectly and hard to use incorrectly.\n\n 18. 接口设计简明， 不要让用户对其有歧义\n     \n     1. 建立新类型，限制类型上的操作， 束缚对象值，消除客户的资源管理责任, 一个new type的案例,(enum会带来类型安全的问题? 什么是类型安全?)\n        \n        class month{\n          public:\n            static month jan(){return month(1);}  //见下文为什么使用函数，不使用对象\n            static month feb(){return month(2);}\n            ...\n            static month dec(){return month(12);} \n            ...\n          private:\n            explicit month(int m);  //explicit禁止参数隐式转换，private禁止用户生成自定义的月份\n            ...\n        };\n        \n        date d(month::mar(), day(30), year(1995)); //正确\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n        10\n        11\n        12\n        13\n        \n     \n     2. 好好设计程序的类型系统， 使用class， template， typedef， struct， enum等等(类型系统的c++最佳实践方式?)\n\n\n# item 19：设计class犹如设计type treat class design as type design.\n\n 19. 设计class的时候， 就好比设计type（一系列要注意的事项）\n     \n     * 新类型的对象要如何创建和销毁?\n     \n     这决定了要如何写构造函数和析构函数，包括要使用什么内存分配和释放函数，即new还是new[]，delete还是delete[]，见第16章\n     \n     * 对象初始化要如何区别于赋值?\n     \n     这决定了你如何写，如何区别构造函数和赋值运算符，以及不要把初始化与赋值混淆，因为它们的语义不同，构造函数适用于未创建的对象，赋值适用于已创建的对象，这也是为什么我们要在构造函数中使用初始化列表而不使用赋值的原因，见第4章和第12章。\n     \n     * 新类型的对象传值有什么意义?\n     \n     要记住拷贝构造函数决定了你的类型是如何被传值的，因为传值会生成本地的拷贝。\n     \n     * 新类型的合法数值有什么限制?\n     \n     通常情况下，并不是成员的任何数值组合都是合法的。要让数据成员合法，我们需要根据合法的组合，在成员函数中对数值进行检测，尤其是构造函数，赋值运算符和setter。这也会影响到使用它的函数会抛出什么异常。\n     \n     * 新类型属于某个继承层次吗?\n     \n     如果你的新类型继承自某个已有的类，你的设计将被这些父类影响到，尤其是父类的某些函数是不是虚函数。如果你的新类型要作为一个父类，你将要决定把哪些函数声明为虚函数，尤其要注意析构函数，见第7章。\n     \n     * 新类型允许什么样的转换?\n     \n     新类型的对象将会在程序的海洋中与其它各种各样的类型并用，这时你就要决定是否允许类型的转换。如果你希望把t1隐式转换为t2，你可以在t1中定义一个转换函数，例如operator t2，或者在t2中定义一个兼容t1的不加explicit修饰的构造函数。\n     \n     如果希望使用显式转换，你要定义执行显示转换的函数，详见第15章。\n     \n     * 什么运算符和函数对于你的新类型是有意义的?\n     \n     这决定了你要声明哪些函数，包括成员函数，非成员函数，友元函数等。\n     \n     * 你要禁止哪些标准函数?\n     \n     如果不希望使用编译器会自动生成的标准函数，把它们声明为私有，见第6章\n     \n     * 谁可以接触到成员?\n     \n     这影响到哪些成员是公有的，哪些是保护的，哪些是私有的。这也能帮你决定哪些类和函数是友元的，以及要不要使用嵌套类(nested class)。\n     \n     * 新类型的"隐藏接口"是什么?\n     \n     新类型对于性能，异常安全性，资源管理(例如锁和内存)有什么保障? 哪些问题是自动解决不需要用户操心的? 要实现这些保障，自然会对这个类的实现产生限制，例如要使用智能指针而不要使用裸指针。\n     \n     * 新类型有多通用?\n     \n     如果想让你的新类型通用于许多类型，定义一个类模板(class template)，而不是单个新类型。\n     \n     * 新类型真的是你需要的吗?\n       \n       如果定义一个子类只是为了给基类增加某些新功能，定义一些非成员的函数或者函数模板更加划算。\n     \n     * 如何创建和销毁， operator new, operator new[]. operator delete, operator delete[],\n     \n     * 对象初始化和对象的赋值有什么区别？ copy constructor 和copy assignment之间有什么区别？\n\n对一个新对象来说， pass by value意味着什么？因为要重载操作符， 函数， 和重载内存的分配和归还，\n\ntype cast的我呢提要怎么处理， 类型转换函数， operator t\n\n\n# item 20：宁以pass-by-reference-to-const替换pass-by-value prefer pass-by-reference-to-const to pass-by-value.\n\n 20. 函数的参数使用pass by reference to const替换pass by value，（内置类型， 其实pass by value也比较合适）\n     \n     1. 效率会比较高, 因为pass by value会产生临时对象, 对于非内置类型, 会调用copy constructor来进行构造\n     2. pass by reference to const 实际上传递的是指针, 能够支持继承类的多态特性.\n     3. 内置类型, stl迭代器和一些函数对象, 其实pass by value并不昂贵\n     \n     \n     # item 21：必须返回对象时，别妄想返回其reference don\'t try to return a reference when you must return an object.\n\n 21. 如果必须返回一个对象， 不要返回他的reference， 因为可能会返回一个local的对象，local对象的renference是没有用的；\n     \n     \n     # item 22：将成员变量声明为private declare data members private.\n\n 22. 成员变量声明为private\n     \n     1. public成员全部都是函数, 有利于语法一致性\n     2. 使用函数来对成员变量进行精确的访问控制， 这样能够给类更好的封装性\n     3. protect成员其实也是没有封装的, 因为如果在后续版本的代码里面,删除了这个protect成员, 其子类一样也需要修改\n     \n     \n     # item 23：宁以non-member、non-friend替换member函数 prefer non-member non-friend functions to member functions.\n\n 23. 使用non member, non friend来替换member函数\n     \n     1. 对于private成员, 能够接触它的就是成员函数+友元函数\n     2. 为的是增加封装性， 增加扩充的弹性，可以使用一个完全的第三方全局的function来进行, 称之为便携函数;\n     3. 可以把这个全局函数放在一个命名空间里面， 稍微约束一下它的作用域\n     \n     \n     # item 24：若所有参数皆需类型转换，请为此采用non-member函数 declarenon-member functions when type conversions should apply to all parameters.\n\n 24. 如果某个函数所有的参数都需要类型转换， 这个函数必须弄成non merber函数\n     \n     1. 隐式转换总体上会给程序带来隐患，因为如果出现了类型错误，编译器是不会报错的。\n     \n     2. 只有在参数表里出现的参数才可以进行隐式转换。例如operator*()这个函数, 局部的重载, 其实只能是x * 2这种形式, 但如果是要支持2 * x这种, 就需要全局的operator*()函数来支持;\n        \n        class rational{\n          public:\n            ...\n            const rational operator*(const rational& lhs) const; // 成员函数\n          ...\n        };\n        result = onehalf * 2; //编译通过\n        result = 2 * onehalf; //编译错误\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        \n        \n        class rational{...};\n        const rational operator*(const rational& lhs, const rational& rhs){\n          return rational(lhs.numerator() * rhs.numerator(),\n                          lhs.denominator() * rhs.denominator())\n        }//作为非成员函数, 两个参数都需要支持隐式转换\n        rational onefourth(1,4);\n        rational result;\n        result = onefourth * 2; //可以编译\n        result = 2 * onefourth; //可以编译\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n        \n     \n     \n     # item 25：考虑写出一个不抛异常的swap函数 consider support for a non-throwing swap.\n\n 25. 给自己的类写的swap函数，不要抛出异常， 这是为了和stl库一样支持swap的异常安全；\n     \n     1. friend可以方位private变量和函数；\n     \n     2. 使用pimpl(the "pimpl" idiom，即"pointer to implementation"), 这样一来，要调换两个对象，直接交换指针就行了\n        \n        //这个类包含widget类的数据\n        class widgetimpl{\n          public:\n            ...\n          private:\n            int a,b,c;\n            std::vector<double> v; //高成本拷贝警告！\n        };\n        \n        //使用pimpl手法的类\n        class widget{  \n          public:\n            widget(const widget& rhs);\n            //赋值运算符的实现见ch 10,11,12\n            widget& operator=(const widget& rhs){\n              ...\n              *pimpl = *(rhs.pimpl);\n              ...\n           }\n          ...\n          private:\n            widgetimpl* pimpl; //使用pimpl指针来指向我们的数据\n        };\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n        10\n        11\n        12\n        13\n        14\n        15\n        16\n        17\n        18\n        19\n        20\n        21\n        22\n        23\n        \n     \n     3. 如果默认的std::swap不会对效率产生比较大的影响，例如对象的成员数据不多，直接使用是没有问题的，就不用大费周章搞这些了\n        \n        如果默认的std::swap会对你的函数/类模板产生效率影响: 给你的类使用pimpl手法，然后给它写一个只交换指针的swap成员函数，而且这个函数禁止抛出异常，然后:\n        \n        对于类模板，要在类模板相同的名空间下写一个自定义的swap，在里面调用swap成员函数\n        \n        对于类(不是类模板)，还要给std::swap进行特殊化，也在它里面调用swap成员函数\n        \n        调用swap的时候确保加上using语句来让std名空间里面的swap对编译器可见，然后swap函数前不要加任何名空间资格限制(qualification)\n     \n     4. 当默认的std::swap可能会拉低你自己的类的效率时，在自己的类里写一个swap成员函数，而且要保证它不会抛出异常\n        \n        写了swap成员函数，按照编程惯例还要写一个非成员swap函数，放在类或者类模板的名空间下，用它来调用成员swap函数。对于类(非模板)，还要特殊化std::swap\n        \n        在调用swap时，要加上一句using std::swap，然后调用时不需要再加任何名空间资格限制, 否则可能会调用到私有的swap函数里面去\n        \n        为了自定义的类而完全特殊化std模板是没问题的，但千万不要给std里添加任何东西。\n        \n        再或者, 直接使用类自带的namespace, 来重写swap函数;\n        \n        class widget{\n          public:\n           ...\n            void swap(widget& data){\n              using std::swap; // 这句稍后解释\n              swap(pimpl, other.pimpl); // 执行真正的swap，只交换指针\n            }\n           ...\n        };\n        \n        namespace std{\n          template<> // 完全特殊化的std::swap\n          void swap<widget>(widget& a, widget& b){\n            a.swap(b);\n          }\n        }\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        8\n        9\n        10\n        11\n        12\n        13\n        14\n        15\n        16\n        \n\n\n#',charsets:{cjk:!0}},{title:"实现Implementations",frontmatter:{title:"实现Implementations",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/fb96c7/"},regularPath:"/01.Wiki/19.Reading%20Notes/01.Effective%20C++/05.%E5%AE%9E%E7%8E%B0.html",relativePath:"01.Wiki/19.Reading Notes/01.Effective C++/05.实现.md",key:"v-7dbd198c",path:"/pages/fb96c7/",headers:[{level:2,title:"实现， Implementations",slug:"实现-implementations",normalizedTitle:"实现， implementations",charIndex:2},{level:3,title:"Item 26：尽可能延后变量定义式的出现时间 Postpone variable definitionsas long as possible.",slug:"item-26-尽可能延后变量定义式的出现时间-postpone-variable-definitionsas-long-as-possible",normalizedTitle:"item 26：尽可能延后变量定义式的出现时间 postpone variable definitionsas long as possible.",charIndex:26},{level:3,title:"Item 27：尽量少做Casting， Minimize casting.",slug:"item-27-尽量少做casting-minimize-casting",normalizedTitle:"item 27：尽量少做casting， minimize casting.",charIndex:1168},{level:3,title:'Item 28：避免返回handles指向对象内部成分 Avoid returning"handles"toobject internals.',slug:"item-28-避免返回handles指向对象内部成分-avoid-returning-handles-toobject-internals",normalizedTitle:"item 28：避免返回handles指向对象内部成分 avoid returning&quot;handles&quot;toobject internals.",charIndex:null},{level:3,title:"Item 29：为“异常安全”而努力是值得的 Strive for exception-safe code.",slug:"item-29-为-异常安全-而努力是值得的-strive-for-exception-safe-code",normalizedTitle:"item 29：为“异常安全”而努力是值得的 strive for exception-safe code.",charIndex:2346},{level:3,title:"Item 30：透彻了解inlining的里里外外     Understand the ins and outs of inlining.",slug:"item-30-透彻了解inlining的里里外外-understand-the-ins-and-outs-of-inlining",normalizedTitle:"item 30：透彻了解inlining的里里外外     understand the ins and outs of inlining.",charIndex:null},{level:3,title:"Item 31：将文件间的编译依存关系降至最低 Minimize compilation dependencies between files.",slug:"item-31-将文件间的编译依存关系降至最低-minimize-compilation-dependencies-between-files",normalizedTitle:"item 31：将文件间的编译依存关系降至最低 minimize compilation dependencies between files.",charIndex:3732}],headersStr:'实现， Implementations Item 26：尽可能延后变量定义式的出现时间 Postpone variable definitionsas long as possible. Item 27：尽量少做Casting， Minimize casting. Item 28：避免返回handles指向对象内部成分 Avoid returning"handles"toobject internals. Item 29：为“异常安全”而努力是值得的 Strive for exception-safe code. Item 30：透彻了解inlining的里里外外     Understand the ins and outs of inlining. Item 31：将文件间的编译依存关系降至最低 Minimize compilation dependencies between files.',content:'# 实现， Implementations\n\n\n# Item 26：尽可能延后变量定义式的出现时间 Postpone variable definitionsas long as possible.\n\n 26. 延迟变量定义的出现时间， 尽量用到的时候再定义；\n     \n     1. 每当定义一个变量时，就会带来构造和析构的运行成本，因为代码运行到定义时会调用对象的构造函数，当离开作用域时便会调用析构函数。\n     2. 把它的定义尽量往后推迟，直到我们100%确定要用到:\n     \n     //用:\n     string encrypted(password);\n     //替换掉:\n     string encrypted;\n     encrypted = password;\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n     \n     我们不仅仅需要把变量的定义推迟到100%要用到的地方，还要把它推迟到100%有构造参数可用的时候。这样做既可以避免不必要的构造和析构过程，也能节省默认构造再赋值的成本。而且这样的代码也更可读，因为变量定义在了真正需要它的环境下。\n     \n     对于一个变量只在循环里用到，把它定义在循环外面然后每次在里面赋值好，即代码A，还是直接在里面定义呢，即代码B?\n     \n     //代码A，在外面定义\n     Widget w;\n     for(int i=0; i<n, i++){\n     w=...;\n     ...\n     }\n     \n     //代码B，在里面定义\n     for(int i=0; i<n; i++){\n     Widget w(...);\n     ...\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     \n     \n     那么我们就来分析一下A和B各自的运行成本:\n     \n     A: 1个构造 + n个赋值 + 1个析构\n     B: n个构造 + n个析构\n     \n     \n     1\n     2\n     \n     \n     对于赋值成本低于(构造+析构)的类，A是更高效的选择，尤其是当n很大的时候。反之如果赋值成本大于(构造+析构)，B则是更好的选择。但是对象在A的作用域比在B要大，有时是不利于程序的可读性和可维护性的。因此除非你知道赋值成本低于(构造+析构)，而且这段代码要更注重效率，那么我们应该默认使用B。\n\n\n# Item 27：尽量少做Casting， Minimize casting.\n\n 27. 少做cast转型动作， 即使要用也尽量使用C++自己的那四个转型, 这里涉及几种C++形式的转换的作用和相关的优缺点\n     \n     1. C++的类型转换有3种方式，C风格，函数风格和C++风格:\n\n(T)expression  //C风格\nT(expression) //函数风格\n\n//C++风格\nstatic_cast<T>(expression)\ndynamic_cast<T>(expression)     //T必须是指向多态类型的指针或引用\nconst_cast<T>(expression)       //T必须是指针或引用\nreinterpret_cast<T>(expression) //T必须是指针或引用\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果一定要转型， 请放在函数里面， 不要让用户在使用这个函数的时候还要惦记转型的事情；\n\n\n# Item 28：避免返回handles指向对象内部成分 Avoid returning"handles"toobject internals.\n\n 28. 避免返回一个handler， 这个handler却有指向对象的内部成分，\n     \n     1. 如果一个函数返回了指向储存在对象外部的数据成员的引用，即使这个函数声明为了const，调用这个函数的人也能修改这个成员(见第3章bitwise constness的局限性)\n     \n     2. 避免返回的是一个空悬的指针；\n     \n     3. 避免可以使用调用的操作来对函数内部的元素进行修改， 可以指定返回值是一个const， 这样用户就不能修改了；\n        \n        class Rectangle{\n          public:   \n            //现在返回的是const Point&   \n            const Point& upperLeft() const{return pData->ulhc;}\n            const Point& lowerRight() const{return pData->lrhc;}\n          ... \n        };\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        \n     \n     4. 避免返回指向内部成员的"句柄"，包括指针，引用，迭代器。不返回"句柄"能增强封装性，让const函数真正const，也能减少"野句柄"。\n\n\n# Item 29：为“异常安全”而努力是值得的 Strive for exception-safe code.\n\n 29. 注意异常安全， （exceptional C++里面有很多异常安全的相关介绍）\n     \n     * 异常安全\n       \n       > 异常安全***的意思就是，当程序在异常发生的时候，程序可以回退的很干净。什么是回退的很干净呢？其实就是函数在发生异常的时候***不会泄露资源***或者***不会发生任何数据结构的破坏。\n       \n       不泄露任何资源\n       \n       不允许破坏任何数据\n\n * 异常安全的函数即使在抛出异常时也不会泄露资源，损坏数据结构。这种安全性有三种级别，基本保证，强保证和不抛出保证\n   \n   * 提供基本保证(basic guarantee)的函数可以保证即使抛出了异常，函数也能在有效的状态下运行，没有对象或数据损坏，所有对象也保持内部一致，依然满足类不变量(class invariant)，但是程序本身则可能处于不确定状态。例如用户使用我们changeBackground方法时抛出了异常，PrettyMenu对象可能依然持有原来的背景，或者持有默认的背景，但具体哪个则是不确定的。\n   * 提供强保证(strong guarantee)的函数可以保证如果函数抛出了异常，程序的状态不会改变。这就意味着对强保证函数的调用是原子性的(atomic)，如果成功了就成功了，如果失败了就像什么都没有发生一样。强保证函数比基本保证函数更容易使用，因为强保证函数只能导致两种状态，成功或者不变，而基本保证的函数可能引向任何状态。\n   * 提供不抛出保证(nothrow guarantee)的函数保证永远不会抛出异常。例如所有对于基本类型(int，指针等等)的操作都提供不抛出保证。它是异常安全代码的基础。\n\n * copy and swap是实现强保证的有效方法，但给所有的函数加上强保证显然也不是实际的选择\n\n * 函数的异常安全性遵循木桶原理，函数的最强安全性取决于它所调用操作的最弱安全性\n\n\n# Item 30：透彻了解inlining的里里外外 Understand the ins and outs of inlining.\n\n 30. 对inline的里里外外需要透彻了解；\n\n * 尽量inline， 也许compiler就能够执行context相关的inline优化；\n * 定义在类里面的函数， 自动inline\n * inline会让代码文件变大， 会导致更多的换页行为（paging），降低 i cache的命中率, 如果函数比较小， inline对 icache miss的影响会稍微比较小， 但是inline的函数比较大， 就有可能会得不偿失；\n * 虚函数的inline， 大多都不会生效\n * inline不仅会导致代码变大， 而且一旦inline的函数发生改变， 所有用到inline function的地方都要重新编译\n * inline函数一般放在头文件里面， template一般也都是发那个在头文件里面；\n * template要避免无脑成为一个inline函数， 它的代价是很大的；因为可能程序中很多地方都用到了这个模板\n\n\n# Item 31：将文件间的编译依存关系降至最低 Minimize compilation dependencies between files.\n\n 31. 尽量减少文件之间的编译依赖关系；不然修改之后编译， 会导致很多部件都一起编译了【缺demo】\n\n * 头文件应该仅有声明不要有定义；\n * 可以只有声明， 而没有定义， 这会导致一个方法： 前向声明， 前向声明只是把#include的内容， 放在代码的前面；\n * 一般使用pointer to implementation 和纯虚函数的工厂方法来解决， 前者叫handle class, 后者叫interface class;',normalizedContent:'# 实现， implementations\n\n\n# item 26：尽可能延后变量定义式的出现时间 postpone variable definitionsas long as possible.\n\n 26. 延迟变量定义的出现时间， 尽量用到的时候再定义；\n     \n     1. 每当定义一个变量时，就会带来构造和析构的运行成本，因为代码运行到定义时会调用对象的构造函数，当离开作用域时便会调用析构函数。\n     2. 把它的定义尽量往后推迟，直到我们100%确定要用到:\n     \n     //用:\n     string encrypted(password);\n     //替换掉:\n     string encrypted;\n     encrypted = password;\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n     \n     我们不仅仅需要把变量的定义推迟到100%要用到的地方，还要把它推迟到100%有构造参数可用的时候。这样做既可以避免不必要的构造和析构过程，也能节省默认构造再赋值的成本。而且这样的代码也更可读，因为变量定义在了真正需要它的环境下。\n     \n     对于一个变量只在循环里用到，把它定义在循环外面然后每次在里面赋值好，即代码a，还是直接在里面定义呢，即代码b?\n     \n     //代码a，在外面定义\n     widget w;\n     for(int i=0; i<n, i++){\n     w=...;\n     ...\n     }\n     \n     //代码b，在里面定义\n     for(int i=0; i<n; i++){\n     widget w(...);\n     ...\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     \n     \n     那么我们就来分析一下a和b各自的运行成本:\n     \n     a: 1个构造 + n个赋值 + 1个析构\n     b: n个构造 + n个析构\n     \n     \n     1\n     2\n     \n     \n     对于赋值成本低于(构造+析构)的类，a是更高效的选择，尤其是当n很大的时候。反之如果赋值成本大于(构造+析构)，b则是更好的选择。但是对象在a的作用域比在b要大，有时是不利于程序的可读性和可维护性的。因此除非你知道赋值成本低于(构造+析构)，而且这段代码要更注重效率，那么我们应该默认使用b。\n\n\n# item 27：尽量少做casting， minimize casting.\n\n 27. 少做cast转型动作， 即使要用也尽量使用c++自己的那四个转型, 这里涉及几种c++形式的转换的作用和相关的优缺点\n     \n     1. c++的类型转换有3种方式，c风格，函数风格和c++风格:\n\n(t)expression  //c风格\nt(expression) //函数风格\n\n//c++风格\nstatic_cast<t>(expression)\ndynamic_cast<t>(expression)     //t必须是指向多态类型的指针或引用\nconst_cast<t>(expression)       //t必须是指针或引用\nreinterpret_cast<t>(expression) //t必须是指针或引用\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果一定要转型， 请放在函数里面， 不要让用户在使用这个函数的时候还要惦记转型的事情；\n\n\n# item 28：避免返回handles指向对象内部成分 avoid returning"handles"toobject internals.\n\n 28. 避免返回一个handler， 这个handler却有指向对象的内部成分，\n     \n     1. 如果一个函数返回了指向储存在对象外部的数据成员的引用，即使这个函数声明为了const，调用这个函数的人也能修改这个成员(见第3章bitwise constness的局限性)\n     \n     2. 避免返回的是一个空悬的指针；\n     \n     3. 避免可以使用调用的操作来对函数内部的元素进行修改， 可以指定返回值是一个const， 这样用户就不能修改了；\n        \n        class rectangle{\n          public:   \n            //现在返回的是const point&   \n            const point& upperleft() const{return pdata->ulhc;}\n            const point& lowerright() const{return pdata->lrhc;}\n          ... \n        };\n        \n        \n        1\n        2\n        3\n        4\n        5\n        6\n        7\n        \n     \n     4. 避免返回指向内部成员的"句柄"，包括指针，引用，迭代器。不返回"句柄"能增强封装性，让const函数真正const，也能减少"野句柄"。\n\n\n# item 29：为“异常安全”而努力是值得的 strive for exception-safe code.\n\n 29. 注意异常安全， （exceptional c++里面有很多异常安全的相关介绍）\n     \n     * 异常安全\n       \n       > 异常安全***的意思就是，当程序在异常发生的时候，程序可以回退的很干净。什么是回退的很干净呢？其实就是函数在发生异常的时候***不会泄露资源***或者***不会发生任何数据结构的破坏。\n       \n       不泄露任何资源\n       \n       不允许破坏任何数据\n\n * 异常安全的函数即使在抛出异常时也不会泄露资源，损坏数据结构。这种安全性有三种级别，基本保证，强保证和不抛出保证\n   \n   * 提供基本保证(basic guarantee)的函数可以保证即使抛出了异常，函数也能在有效的状态下运行，没有对象或数据损坏，所有对象也保持内部一致，依然满足类不变量(class invariant)，但是程序本身则可能处于不确定状态。例如用户使用我们changebackground方法时抛出了异常，prettymenu对象可能依然持有原来的背景，或者持有默认的背景，但具体哪个则是不确定的。\n   * 提供强保证(strong guarantee)的函数可以保证如果函数抛出了异常，程序的状态不会改变。这就意味着对强保证函数的调用是原子性的(atomic)，如果成功了就成功了，如果失败了就像什么都没有发生一样。强保证函数比基本保证函数更容易使用，因为强保证函数只能导致两种状态，成功或者不变，而基本保证的函数可能引向任何状态。\n   * 提供不抛出保证(nothrow guarantee)的函数保证永远不会抛出异常。例如所有对于基本类型(int，指针等等)的操作都提供不抛出保证。它是异常安全代码的基础。\n\n * copy and swap是实现强保证的有效方法，但给所有的函数加上强保证显然也不是实际的选择\n\n * 函数的异常安全性遵循木桶原理，函数的最强安全性取决于它所调用操作的最弱安全性\n\n\n# item 30：透彻了解inlining的里里外外 understand the ins and outs of inlining.\n\n 30. 对inline的里里外外需要透彻了解；\n\n * 尽量inline， 也许compiler就能够执行context相关的inline优化；\n * 定义在类里面的函数， 自动inline\n * inline会让代码文件变大， 会导致更多的换页行为（paging），降低 i cache的命中率, 如果函数比较小， inline对 icache miss的影响会稍微比较小， 但是inline的函数比较大， 就有可能会得不偿失；\n * 虚函数的inline， 大多都不会生效\n * inline不仅会导致代码变大， 而且一旦inline的函数发生改变， 所有用到inline function的地方都要重新编译\n * inline函数一般放在头文件里面， template一般也都是发那个在头文件里面；\n * template要避免无脑成为一个inline函数， 它的代价是很大的；因为可能程序中很多地方都用到了这个模板\n\n\n# item 31：将文件间的编译依存关系降至最低 minimize compilation dependencies between files.\n\n 31. 尽量减少文件之间的编译依赖关系；不然修改之后编译， 会导致很多部件都一起编译了【缺demo】\n\n * 头文件应该仅有声明不要有定义；\n * 可以只有声明， 而没有定义， 这会导致一个方法： 前向声明， 前向声明只是把#include的内容， 放在代码的前面；\n * 一般使用pointer to implementation 和纯虚函数的工厂方法来解决， 前者叫handle class, 后者叫interface class;',charsets:{cjk:!0}},{title:"模板，Templates and GP",frontmatter:{title:"模板，Templates and GP",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/61c62c/"},regularPath:"/01.Wiki/19.Reading%20Notes/01.Effective%20C++/07.%E6%A8%A1%E6%9D%BF.html",relativePath:"01.Wiki/19.Reading Notes/01.Effective C++/07.模板.md",key:"v-249122e1",path:"/pages/61c62c/",headers:[{level:2,title:"模板，Templates and GP",slug:"模板-templates-and-gp",normalizedTitle:"模板，templates and gp",charIndex:2},{level:3,title:"Item 41：了解隐式接口和编译期多态 Understand     implicit interfaces and compile-time polymorphism.",slug:"item-41-了解隐式接口和编译期多态-understand-implicit-interfaces-and-compile-time-polymorphism",normalizedTitle:"item 41：了解隐式接口和编译期多态 understand     implicit interfaces and compile-time polymorphism.",charIndex:null},{level:3,title:"Item 42：了解typename的双重意义 Understand     the two meanings of typename.",slug:"item-42-了解typename的双重意义-understand-the-two-meanings-of-typename",normalizedTitle:"item 42：了解typename的双重意义 understand     the two meanings of typename.",charIndex:null},{level:3,title:"Item 43：学习处理模板化基类内的名称 Know how to     access names in templatized base classes.",slug:"item-43-学习处理模板化基类内的名称-know-how-to-access-names-in-templatized-base-classes",normalizedTitle:"item 43：学习处理模板化基类内的名称 know how to     access names in templatized base classes.",charIndex:null},{level:3,title:"Item 44：将与参数无关的代码抽离templates Factor     parameter-independent code out of templates.",slug:"item-44-将与参数无关的代码抽离templates-factor-parameter-independent-code-out-of-templates",normalizedTitle:"item 44：将与参数无关的代码抽离templates factor     parameter-independent code out of templates.",charIndex:null},{level:3,title:'Item 45：运用成员函数模板接受所有兼容类型 Use member     function templates to accept"all compatible types."',slug:"item-45-运用成员函数模板接受所有兼容类型-use-member-function-templates-to-accept-all-compatible-types",normalizedTitle:"item 45：运用成员函数模板接受所有兼容类型 use member     function templates to accept&quot;all compatible types.&quot;",charIndex:null},{level:3,title:"Item 46：需要类型转换时请为模板定义非成员函数 Define     non-member functions inside templates when type conversions are desired.",slug:"item-46-需要类型转换时请为模板定义非成员函数-define-non-member-functions-inside-templates-when-type-conversions-are-desired",normalizedTitle:"item 46：需要类型转换时请为模板定义非成员函数 define     non-member functions inside templates when type conversions are desired.",charIndex:null},{level:3,title:"Item 47：请使用traits classes表现类型信息 Use     traits classes for information about types.",slug:"item-47-请使用traits-classes表现类型信息-use-traits-classes-for-information-about-types",normalizedTitle:"item 47：请使用traits classes表现类型信息 use     traits classes for information about types.",charIndex:null},{level:3,title:"Item 48：认识template元编程 Be aware of     template metaprogramming.",slug:"item-48-认识template元编程-be-aware-of-template-metaprogramming",normalizedTitle:"item 48：认识template元编程 be aware of     template metaprogramming.",charIndex:null}],headersStr:'模板，Templates and GP Item 41：了解隐式接口和编译期多态 Understand     implicit interfaces and compile-time polymorphism. Item 42：了解typename的双重意义 Understand     the two meanings of typename. Item 43：学习处理模板化基类内的名称 Know how to     access names in templatized base classes. Item 44：将与参数无关的代码抽离templates Factor     parameter-independent code out of templates. Item 45：运用成员函数模板接受所有兼容类型 Use member     function templates to accept"all compatible types." Item 46：需要类型转换时请为模板定义非成员函数 Define     non-member functions inside templates when type conversions are desired. Item 47：请使用traits classes表现类型信息 Use     traits classes for information about types. Item 48：认识template元编程 Be aware of     template metaprogramming.',content:'# 模板，Templates and GP\n\n\n# Item 41：了解隐式接口和编译期多态 Understand implicit interfaces and compile-time polymorphism.\n\n 41. 隐式接口和编译期多态（和RTTI的区别？）\n\n\n# Item 42：了解typename的双重意义 Understand the two meanings of typename.\n\n 42. typename和class关键字， typename关键字的双重定义\n\n\n# Item 43：学习处理模板化基类内的名称 Know how to access names in templatized base classes.\n\n 43. 如何处理模板化基类的里面的名称\n\n\n# Item 44：将与参数无关的代码抽离templates Factor parameter-independent code out of templates.\n\n 44. 参数无关的代码， 抽离template\n\n\n# Item 45：运用成员函数模板接受所有兼容类型 Use member function templates to accept"all compatible types."\n\n 45. 使用成员函数模板来接受所有兼容的类型\n\n\n# Item 46：需要类型转换时请为模板定义非成员函数 Define non-member functions inside templates when type conversions are desired.\n\n 46. 需要类型转换的时候， 为模板定义一个非成员函数\n\n\n# Item 47：请使用traits classes表现类型信息 Use traits classes for information about types.\n\n 47. 使用traits来表现模板里面的类型信息\n\n\n# Item 48：认识template元编程 Be aware of template metaprogramming.\n\n 48. 什么是template元编程',normalizedContent:'# 模板，templates and gp\n\n\n# item 41：了解隐式接口和编译期多态 understand implicit interfaces and compile-time polymorphism.\n\n 41. 隐式接口和编译期多态（和rtti的区别？）\n\n\n# item 42：了解typename的双重意义 understand the two meanings of typename.\n\n 42. typename和class关键字， typename关键字的双重定义\n\n\n# item 43：学习处理模板化基类内的名称 know how to access names in templatized base classes.\n\n 43. 如何处理模板化基类的里面的名称\n\n\n# item 44：将与参数无关的代码抽离templates factor parameter-independent code out of templates.\n\n 44. 参数无关的代码， 抽离template\n\n\n# item 45：运用成员函数模板接受所有兼容类型 use member function templates to accept"all compatible types."\n\n 45. 使用成员函数模板来接受所有兼容的类型\n\n\n# item 46：需要类型转换时请为模板定义非成员函数 define non-member functions inside templates when type conversions are desired.\n\n 46. 需要类型转换的时候， 为模板定义一个非成员函数\n\n\n# item 47：请使用traits classes表现类型信息 use traits classes for information about types.\n\n 47. 使用traits来表现模板里面的类型信息\n\n\n# item 48：认识template元编程 be aware of template metaprogramming.\n\n 48. 什么是template元编程',charsets:{cjk:!0}},{title:"定制new和delete",frontmatter:{title:"定制new和delete",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/875a85/"},regularPath:"/01.Wiki/19.Reading%20Notes/01.Effective%20C++/08.%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete.html",relativePath:"01.Wiki/19.Reading Notes/01.Effective C++/08.定制new和delete.md",key:"v-5687f1b4",path:"/pages/875a85/",headers:[{level:2,title:"定制new和delete",slug:"定制new和delete",normalizedTitle:"定制new和delete",charIndex:2},{level:3,title:"Item 49：了解new-handler的行为 Understand  the behavior of the new-handler.",slug:"item-49-了解new-handler的行为-understand-the-behavior-of-the-new-handler",normalizedTitle:"item 49：了解new-handler的行为 understand  the behavior of the new-handler.",charIndex:null},{level:3,title:"Item 50：了解new和delete的合理替换时机     Understand when it makes sense to replace new and delete.",slug:"item-50-了解new和delete的合理替换时机-understand-when-it-makes-sense-to-replace-new-and-delete",normalizedTitle:"item 50：了解new和delete的合理替换时机     understand when it makes sense to replace new and delete.",charIndex:null},{level:3,title:"Item 51：编写new和delete时需固守常规 Adhere     to convention when writing new and delete.",slug:"item-51-编写new和delete时需固守常规-adhere-to-convention-when-writing-new-and-delete",normalizedTitle:"item 51：编写new和delete时需固守常规 adhere     to convention when writing new and delete.",charIndex:null},{level:3,title:"Item 52：写了placement new也要写placement delete Write placement delete if you write placement new.",slug:"item-52-写了placement-new也要写placement-delete-write-placement-delete-if-you-write-placement-new",normalizedTitle:"item 52：写了placement new也要写placement delete write placement delete if you write placement new.",charIndex:401}],headersStr:"定制new和delete Item 49：了解new-handler的行为 Understand  the behavior of the new-handler. Item 50：了解new和delete的合理替换时机     Understand when it makes sense to replace new and delete. Item 51：编写new和delete时需固守常规 Adhere     to convention when writing new and delete. Item 52：写了placement new也要写placement delete Write placement delete if you write placement new.",content:"# 定制new和delete\n\n\n# Item 49：了解new-handler的行为 Understand the behavior of the new-handler.\n\n 49. new handler的行为（处理new失败时候throw的异常）， 底层是怎样构成的？\n\n\n# Item 50：了解new和delete的合理替换时机 Understand when it makes sense to replace new and delete.\n\n 50. operator new和operator delete的合理替换时机；\n\n\n# Item 51：编写new和delete时需固守常规 Adhere to convention when writing new and delete.\n\n 51. operator new和operator delete需要遵循的一些规则\n\n\n# Item 52：写了placement new也要写placement delete Write placement delete if you write placement new.\n\n 52. placement new和placement delete",normalizedContent:"# 定制new和delete\n\n\n# item 49：了解new-handler的行为 understand the behavior of the new-handler.\n\n 49. new handler的行为（处理new失败时候throw的异常）， 底层是怎样构成的？\n\n\n# item 50：了解new和delete的合理替换时机 understand when it makes sense to replace new and delete.\n\n 50. operator new和operator delete的合理替换时机；\n\n\n# item 51：编写new和delete时需固守常规 adhere to convention when writing new and delete.\n\n 51. operator new和operator delete需要遵循的一些规则\n\n\n# item 52：写了placement new也要写placement delete write placement delete if you write placement new.\n\n 52. placement new和placement delete",charsets:{cjk:!0}},{title:"杂项, Misc",frontmatter:{title:"杂项, Misc",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/589042/"},regularPath:"/01.Wiki/19.Reading%20Notes/01.Effective%20C++/09.%E6%9D%82%E9%A1%B9_Misc.html",relativePath:"01.Wiki/19.Reading Notes/01.Effective C++/09.杂项_Misc.md",key:"v-06ae3d06",path:"/pages/589042/",headers:[{level:2,title:"杂项, Misc",slug:"杂项-misc",normalizedTitle:"杂项, misc",charIndex:2},{level:3,title:"Item 53：不要轻忽编译器的警告 Pay attention to compiler warnings.",slug:"item-53-不要轻忽编译器的警告-pay-attention-to-compiler-warnings",normalizedTitle:"item 53：不要轻忽编译器的警告 pay attention to compiler warnings.",charIndex:15},{level:3,title:"Item 54：让自己熟悉包括TR1在内的标准程序库     Familiarize yourself with the standard library，including TR1.",slug:"item-54-让自己熟悉包括tr1在内的标准程序库-familiarize-yourself-with-the-standard-library-including-tr1",normalizedTitle:"item 54：让自己熟悉包括tr1在内的标准程序库     familiarize yourself with the standard library，including tr1.",charIndex:null},{level:3,title:"Item 55：让自己熟悉Boost库 Familiarize yourself with Boost.",slug:"item-55-让自己熟悉boost库-familiarize-yourself-with-boost",normalizedTitle:"item 55：让自己熟悉boost库 familiarize yourself with boost.",charIndex:375}],headersStr:"杂项, Misc Item 53：不要轻忽编译器的警告 Pay attention to compiler warnings. Item 54：让自己熟悉包括TR1在内的标准程序库     Familiarize yourself with the standard library，including TR1. Item 55：让自己熟悉Boost库 Familiarize yourself with Boost.",content:'# 杂项, Misc\n\n\n# Item 53：不要轻忽编译器的警告 Pay attention to compiler warnings.\n\n\n# Item 54：让自己熟悉包括TR1在内的标准程序库 Familiarize yourself with the standard library，including TR1.\n\nTR1（"Technical Report 1"）是一份规范，描述加入C++标准程序库的诸多新机能。这些机能以新的classtemplates和function templates形式体现，针对的题目有hash tables，reference-counting smart pointers，regular expressions，以及更多。所有TR1组件都被置于命名空间tr1内，后者嵌套于命名空间std内。\n\n\n# Item 55：让自己熟悉Boost库 Familiarize yourself with Boost.\n\nBoost是个组织，亦是一个网站（http：//boost.org），提供可移植、同僚复审、源码开放的C++程序库。大多数TR1机能是以Boost的工作为基础。在编译器厂商于其C++程序库中含入TR1之前，对那些搜寻TR1实现品的开发人员而言，Boost网站可能是第一个逗留点。Boost提供比TR1更多的东西，所以无论如何值得了解它。',normalizedContent:'# 杂项, misc\n\n\n# item 53：不要轻忽编译器的警告 pay attention to compiler warnings.\n\n\n# item 54：让自己熟悉包括tr1在内的标准程序库 familiarize yourself with the standard library，including tr1.\n\ntr1（"technical report 1"）是一份规范，描述加入c++标准程序库的诸多新机能。这些机能以新的classtemplates和function templates形式体现，针对的题目有hash tables，reference-counting smart pointers，regular expressions，以及更多。所有tr1组件都被置于命名空间tr1内，后者嵌套于命名空间std内。\n\n\n# item 55：让自己熟悉boost库 familiarize yourself with boost.\n\nboost是个组织，亦是一个网站（http：//boost.org），提供可移植、同僚复审、源码开放的c++程序库。大多数tr1机能是以boost的工作为基础。在编译器厂商于其c++程序库中含入tr1之前，对那些搜寻tr1实现品的开发人员而言，boost网站可能是第一个逗留点。boost提供比tr1更多的东西，所以无论如何值得了解它。',charsets:{cjk:!0}},{title:"基础议题",frontmatter:{title:"基础议题",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/ce94a9/"},regularPath:"/01.Wiki/19.Reading%20Notes/02.More%20Effective%20C++/01.%E5%9F%BA%E7%A1%80%E8%AE%AE%E9%A2%98.html",relativePath:"01.Wiki/19.Reading Notes/02.More Effective C++/01.基础议题.md",key:"v-7fefcb5b",path:"/pages/ce94a9/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:2,title:"基础议题",slug:"基础议题",normalizedTitle:"基础议题",charIndex:6},{level:3,title:"Item  1：区别 pointers和 references",slug:"item-1-区别-pointers和-references",normalizedTitle:"item  1：区别 pointers和 references",charIndex:null},{level:3,title:"Item  2：尽量使用C++的Cast操作符而不是C的",slug:"item-2-尽量使用c-的cast操作符而不是c的",normalizedTitle:"item  2：尽量使用c++的cast操作符而不是c的",charIndex:null},{level:3,title:"Item 3：不以多态（polymorphically）方式处理数组",slug:"item-3-不以多态-polymorphically-方式处理数组",normalizedTitle:"item 3：不以多态（polymorphically）方式处理数组",charIndex:1191},{level:3,title:"Item  4：非必要不提供 default constructor",slug:"item-4-非必要不提供-default-constructor",normalizedTitle:"item  4：非必要不提供 default constructor",charIndex:null}],headersStr:" 基础议题 Item  1：区别 pointers和 references Item  2：尽量使用C++的Cast操作符而不是C的 Item 3：不以多态（polymorphically）方式处理数组 Item  4：非必要不提供 default constructor",content:'#\n\n\n# 基础议题\n\n\n# Item 1：区别 pointers和 references\n\n * references 必须有初值，pointer是可以没有初值的；(reference 一定得代表某个对象)\n\n ```cpp\n string &rs // 错误\n \n string s("hello");\n string& rs=s; // 正确\n \n string* ps; // 正确\n ```\n\n\n * 用references 可能会比使用pointers 更高效。因为使用 reference 之前不需要测试其有效性, 如果是指针, 需要判断是否为nullptr, if(pc),\n\n * Pointers 和 references 之间的一个重要差异是，pointers 可以被重新赋值指向另一个对象，reference 却总是指向（代表）它最初获得的那个对象\n\n * 先考虑用pointer, 如果真的是指向一个不变的东西, 或者pointer办不到的时候, 再考虑使用referenc\n\n\n# Item 2：尽量使用C++的Cast操作符而不是C的\n\n优先使用C++的cast操作: static_cast(), const_cast(), reinterprete_cast(), dynamic_cast()；\n\n * static_cast 基本上拥有与 C 旧式转型相同的威力与意义，以及相同的限制。\n\n * const_cast 用来改变一个变量的常量性（constness）或变易性（volatileness）\n\n * dynamic_cast，用来“安全地向下转型或跨系转型动作”。也就是说可用dynamic_cast，将“指向base class objects的pointers或 references”转型为“指向 derived（或 sibling base）class objects的 pointers 或 references”，并能够通过返回值得知转型是否成功(0 or 1)\n   \n   * 具体到函数的传参上面使用, 其实就是多态的相反的用法:\n     \n     update(&csw);\n     update(const_cast<SpecialWidget*>(&csw));   // 转移const属性;\n     update(dynamic_cast<SpecialWidget*>(&csw)); // 从父类cast到子类;\n     \n     \n     1\n     2\n     3\n     \n\n * reinterpret_cast转换结果几乎总是与编译平台息息相关。所以reinterpret_casts不具移植性。reinterpret_cast的最常用的地方是转换“函数指针”。\n\n\n# Item 3：不以多态（polymorphically）方式处理数组\n\n不要以多态的方式处理数组， 因为多态的时候, 导致数组里面元素的大小不一样， 在数组里面slicing会导致便偏移错误；\n\n// sample code\nclass BST{ ... };\nclass BalancedBST : public BST{ ... };\n\nvoid printBSTArray(ostream &s, const BST array[], int numElements){\n for(int i=0; i<numElement; i++){\n     s << array[i];  // 假设BST Objects有一个operator可用\n }\n}\n\nBST BSTArray[10];\nPrintBSTArray(cout, BSTArray, 10);  // 运行良好\n\nBalancedBST bBSTArray[10];\nprintBSTArray(cout, bBSTArry, 10); // 多态方式处理, 不可以, 结果未定义\n\n// 如果删除\nvoid deleteArray(ostream &logstream, BST array[]){\n logStream << "Deleting array at address, " << static_cast<void*>(array) << "\\n";\n delete [] array;\n}\n\nBalancedBST *balTreeArray = new BalancedBST[50]; // 产生一个子类数组;\ndeleteArray(cout, balTreeArray); // 这样通过父类指针去删除子类数组, 结果未定义;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n多态和指针算数不能够混用;\n\n\n# Item 4：非必要不提供 default constructor\n\n非必要不使用默认的default constructor(没有参数的ctor)\n\n * 在一个完美的世界中，凡可以“合理地从无到有生成对象”的 classes，都应该内含 default constructors，而“必须有某些外来信息才能生成对象”的 classes，则不必拥有 default constructors。但我们的世界毕竟不是完美的世界，所以我们必须纳入其他考虑。\n\n * 缺乏default constructor可能产生的问题\n   \n   class Equipement{\n       public:\n       \tEquipement(int numEque);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   * 在产生数组的时候。无法为数组中的对象指定 constructor 自变量，所以几乎不可能产生一个由 EquipmentPiece objects 构成的数组：\n     \n     Equipement bestPieces[10]; // 出错 没有办法调用default ctor\n     Equipement *bestPieces = new EquipementPiece[10]; // 出错\n     \n     \n     1\n     2\n     \n   \n   * 这些class不适用于许多 template-based container classes。对那些 templates 而言，被实例化（instantiated）的“目标类型”必须得有一个 default constructors。\n   \n   * virtual base class constructors 的自变量必须由欲产生的对象的派生层次最深（所谓 most derived）的 class 提供。于是，一个缺乏 default constructor的 virtual base class，要求其所有的 derived classes——不论距离多么遥远——都必须知道、了解其意义，并且提供 virtual base class 的 constructors 自变量, 这是非常难做到的， 除非：\n     \n     // sample\n     \n     \n     1\n     \n\n * 添加无意义的default constructors也会影响class的效率；\n\n * 使其他的member function更加复杂',normalizedContent:'#\n\n\n# 基础议题\n\n\n# item 1：区别 pointers和 references\n\n * references 必须有初值，pointer是可以没有初值的；(reference 一定得代表某个对象)\n\n ```cpp\n string &rs // 错误\n \n string s("hello");\n string& rs=s; // 正确\n \n string* ps; // 正确\n ```\n\n\n * 用references 可能会比使用pointers 更高效。因为使用 reference 之前不需要测试其有效性, 如果是指针, 需要判断是否为nullptr, if(pc),\n\n * pointers 和 references 之间的一个重要差异是，pointers 可以被重新赋值指向另一个对象，reference 却总是指向（代表）它最初获得的那个对象\n\n * 先考虑用pointer, 如果真的是指向一个不变的东西, 或者pointer办不到的时候, 再考虑使用referenc\n\n\n# item 2：尽量使用c++的cast操作符而不是c的\n\n优先使用c++的cast操作: static_cast(), const_cast(), reinterprete_cast(), dynamic_cast()；\n\n * static_cast 基本上拥有与 c 旧式转型相同的威力与意义，以及相同的限制。\n\n * const_cast 用来改变一个变量的常量性（constness）或变易性（volatileness）\n\n * dynamic_cast，用来“安全地向下转型或跨系转型动作”。也就是说可用dynamic_cast，将“指向base class objects的pointers或 references”转型为“指向 derived（或 sibling base）class objects的 pointers 或 references”，并能够通过返回值得知转型是否成功(0 or 1)\n   \n   * 具体到函数的传参上面使用, 其实就是多态的相反的用法:\n     \n     update(&csw);\n     update(const_cast<specialwidget*>(&csw));   // 转移const属性;\n     update(dynamic_cast<specialwidget*>(&csw)); // 从父类cast到子类;\n     \n     \n     1\n     2\n     3\n     \n\n * reinterpret_cast转换结果几乎总是与编译平台息息相关。所以reinterpret_casts不具移植性。reinterpret_cast的最常用的地方是转换“函数指针”。\n\n\n# item 3：不以多态（polymorphically）方式处理数组\n\n不要以多态的方式处理数组， 因为多态的时候, 导致数组里面元素的大小不一样， 在数组里面slicing会导致便偏移错误；\n\n// sample code\nclass bst{ ... };\nclass balancedbst : public bst{ ... };\n\nvoid printbstarray(ostream &s, const bst array[], int numelements){\n for(int i=0; i<numelement; i++){\n     s << array[i];  // 假设bst objects有一个operator可用\n }\n}\n\nbst bstarray[10];\nprintbstarray(cout, bstarray, 10);  // 运行良好\n\nbalancedbst bbstarray[10];\nprintbstarray(cout, bbstarry, 10); // 多态方式处理, 不可以, 结果未定义\n\n// 如果删除\nvoid deletearray(ostream &logstream, bst array[]){\n logstream << "deleting array at address, " << static_cast<void*>(array) << "\\n";\n delete [] array;\n}\n\nbalancedbst *baltreearray = new balancedbst[50]; // 产生一个子类数组;\ndeletearray(cout, baltreearray); // 这样通过父类指针去删除子类数组, 结果未定义;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n多态和指针算数不能够混用;\n\n\n# item 4：非必要不提供 default constructor\n\n非必要不使用默认的default constructor(没有参数的ctor)\n\n * 在一个完美的世界中，凡可以“合理地从无到有生成对象”的 classes，都应该内含 default constructors，而“必须有某些外来信息才能生成对象”的 classes，则不必拥有 default constructors。但我们的世界毕竟不是完美的世界，所以我们必须纳入其他考虑。\n\n * 缺乏default constructor可能产生的问题\n   \n   class equipement{\n       public:\n       \tequipement(int numeque);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   * 在产生数组的时候。无法为数组中的对象指定 constructor 自变量，所以几乎不可能产生一个由 equipmentpiece objects 构成的数组：\n     \n     equipement bestpieces[10]; // 出错 没有办法调用default ctor\n     equipement *bestpieces = new equipementpiece[10]; // 出错\n     \n     \n     1\n     2\n     \n   \n   * 这些class不适用于许多 template-based container classes。对那些 templates 而言，被实例化（instantiated）的“目标类型”必须得有一个 default constructors。\n   \n   * virtual base class constructors 的自变量必须由欲产生的对象的派生层次最深（所谓 most derived）的 class 提供。于是，一个缺乏 default constructor的 virtual base class，要求其所有的 derived classes——不论距离多么遥远——都必须知道、了解其意义，并且提供 virtual base class 的 constructors 自变量, 这是非常难做到的， 除非：\n     \n     // sample\n     \n     \n     1\n     \n\n * 添加无意义的default constructors也会影响class的效率；\n\n * 使其他的member function更加复杂',charsets:{cjk:!0}},{title:"继承与OOP",frontmatter:{title:"继承与OOP",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/81fe36/"},regularPath:"/01.Wiki/19.Reading%20Notes/01.Effective%20C++/06.%E7%BB%A7%E6%89%BF%E4%B8%8EOOP.html",relativePath:"01.Wiki/19.Reading Notes/01.Effective C++/06.继承与OOP.md",key:"v-18172e6c",path:"/pages/81fe36/",headers:[{level:2,title:"继承与OOP,  Inheritance and Object-Oriented Design",slug:"继承与oop-inheritance-and-object-oriented-design",normalizedTitle:"继承与oop,  inheritance and object-oriented design",charIndex:null},{level:3,title:'Item 32：确定你的public继承塑模出is-a关系 Make sure public inheritancemodels"is-a."',slug:"item-32-确定你的public继承塑模出is-a关系-make-sure-public-inheritancemodels-is-a",normalizedTitle:"item 32：确定你的public继承塑模出is-a关系 make sure public inheritancemodels&quot;is-a.&quot;",charIndex:null},{level:3,title:"Item 33：避免遮掩继承而来的名称 Avoid hiding inherited names.",slug:"item-33-避免遮掩继承而来的名称-avoid-hiding-inherited-names",normalizedTitle:"item 33：避免遮掩继承而来的名称 avoid hiding inherited names.",charIndex:496},{level:3,title:"Item 34：区分接口继承和实现继承 Differentiate     between inheritance of interface and inheritance of implementation.",slug:"item-34-区分接口继承和实现继承-differentiate-between-inheritance-of-interface-and-inheritance-of-implementation",normalizedTitle:"item 34：区分接口继承和实现继承 differentiate     between inheritance of interface and inheritance of implementation.",charIndex:null},{level:3,title:"Item 35：考虑virtual函数以外的其他选择 Consider alte rnatives to virtual functions.",slug:"item-35-考虑virtual函数以外的其他选择-consider-alte-rnatives-to-virtual-functions",normalizedTitle:"item 35：考虑virtual函数以外的其他选择 consider alte rnatives to virtual functions.",charIndex:1233},{level:3,title:"Item 36：绝不重新定义继承而来的non-virtual函数 Never redefine an inherited non-virtual function.",slug:"item-36-绝不重新定义继承而来的non-virtual函数-never-redefine-an-inherited-non-virtual-function",normalizedTitle:"item 36：绝不重新定义继承而来的non-virtual函数 never redefine an inherited non-virtual function.",charIndex:1650},{level:3,title:"Item 37：绝不重新定义继承而来的缺省参数值 Never redefine a function's inherited default parameter value.",slug:"item-37-绝不重新定义继承而来的缺省参数值-never-redefine-a-function-s-inherited-default-parameter-value",normalizedTitle:"item 37：绝不重新定义继承而来的缺省参数值 never redefine a function's inherited default parameter value.",charIndex:1877},{level:3,title:'Item 38：通过复合塑模出has-a或“根据某物实现出” Model"has-a"or"is-implemented-in-terms-of"through composition.',slug:"item-38-通过复合塑模出has-a或-根据某物实现出-model-has-a-or-is-implemented-in-terms-of-through-composition",normalizedTitle:"item 38：通过复合塑模出has-a或“根据某物实现出” model&quot;has-a&quot;or&quot;is-implemented-in-terms-of&quot;through composition.",charIndex:null},{level:3,title:"Item 39：明智而审慎地使用private继承 Use     private inheritance judiciously.",slug:"item-39-明智而审慎地使用private继承-use-private-inheritance-judiciously",normalizedTitle:"item 39：明智而审慎地使用private继承 use     private inheritance judiciously.",charIndex:null},{level:3,title:"Item 40：明智而审慎地使用多重继承 Use multiple inheritance judiciously.",slug:"item-40-明智而审慎地使用多重继承-use-multiple-inheritance-judiciously",normalizedTitle:"item 40：明智而审慎地使用多重继承 use multiple inheritance judiciously.",charIndex:2547}],headersStr:'继承与OOP,  Inheritance and Object-Oriented Design Item 32：确定你的public继承塑模出is-a关系 Make sure public inheritancemodels"is-a." Item 33：避免遮掩继承而来的名称 Avoid hiding inherited names. Item 34：区分接口继承和实现继承 Differentiate     between inheritance of interface and inheritance of implementation. Item 35：考虑virtual函数以外的其他选择 Consider alte rnatives to virtual functions. Item 36：绝不重新定义继承而来的non-virtual函数 Never redefine an inherited non-virtual function. Item 37：绝不重新定义继承而来的缺省参数值 Never redefine a function\'s inherited default parameter value. Item 38：通过复合塑模出has-a或“根据某物实现出” Model"has-a"or"is-implemented-in-terms-of"through composition. Item 39：明智而审慎地使用private继承 Use     private inheritance judiciously. Item 40：明智而审慎地使用多重继承 Use multiple inheritance judiciously.',content:'# 继承与OOP, Inheritance and Object-Oriented Design\n\n * 单一继承与多重继承\n\n * public继承，private继承， protected继承\n   \n   class Person{ ... }\n   class Student : public Person{ ... }\n   \n   \n   1\n   2\n   \n\n * virtual / non-virtual 继承\n\n * 成员函数和其他语言特性的影响\n   \n   * 缺省参数与virtual函数的影响？\n   * 继承如何影响C++函数名臣的查找规则？\n   * 设计选项\n   * class行为如果要修改， virtual函数是最佳选择吗？\n\n\n# Item 32：确定你的public继承塑模出is-a关系 Make sure public inheritancemodels"is-a."\n\n 32. public继承的时候， 确认两个对象是 is a的关系；多态通过虚函数来完成，\n     \n     1. 什么时候用虚函数？什么时候用纯虚函数？\n\n\n# Item 33：避免遮掩继承而来的名称 Avoid hiding inherited names.\n\n 33. 继承的时候，注意类内部的变量名称是否会被覆盖，\n\n * 即使是重载的函数，不管函数接口形式是否一样， 也会被子类的同名函数覆盖\n * 使用using Base::mf3() 可以指定在子类作用域范围里面使用base类的mf3函数，\n * 如果只想使用某一个mf3(), 只能是子类的函数里面， 再调用Base::mf3(); 这种方式叫forward functions;\n\n\n# Item 34：区分接口继承和实现继承 Differentiate between inheritance of interface and inheritance of implementation.\n\n 34. 什么是接口继承和实现继承？\n     1. pure virtual函数的目的就是接口继承， 但是也可以有一份基类实现，调用的时候只能通过子类指定父类名称的方式来调用（纯虚函数必须重写）；\n     2. 非纯虚函数是为了让子类继承接口 + 缺省实现， 这些都是自动继承的， 如果子类不override 虚函数的话（一般虚函数可以重写， 也可以不重写）；\n     3. 非虚函数的目的是强制让子类继承一个缺省的实现；（非虚函数，没有多态性，直接继承）\n     4. 接口和实现继承分开， 也就是把接口用一个纯虚函数来声明， 实现使用一个private或者protected的缺省实现来代替， 这样子类必须要重写纯虚函数，但是可以默认使用缺省的实现；\n     5. 也可以使用一个虚函数的非虚实现， 然后再在子类里面overide的时候调用这个函数；\n\n\n# Item 35：考虑virtual函数以外的其他选择 Consider alte rnatives to virtual functions.\n\n 35. 除了virtual函数之外，也可以考虑一下其他的选择\n     1. 通过一个public函数， 调用自己的virtual函数， non-virtual interface（NVI）方法；（模板方法设计模式）， 子类就\n     2. 借助funciion pointer实现strategy模式\n     3. 使用各个库里面的function component来实现strategy模式， 例如std::function， 而且这个东西支持任何callable entities，包括运算符重载的struct和class\n     4. 标准设计模式， 古典的strategy模式， 就是使用pImple的方式来实现strategy， 来代替第一条里面的实现方式\n\n\n# Item 36：绝不重新定义继承而来的non-virtual函数 Never redefine an inherited non-virtual function.\n\n 36. 不要重新定义继承来的non virtual函数， 这其实是一种overloading， 并不能实现多态特性的overide， nonvirtual 函数其实是静态绑定的(dynamic binding)；virtual函数是动态绑定(dynamic binding)\n\n\n# Item 37：绝不重新定义继承而来的缺省参数值 Never redefine a function\'s inherited default parameter value.\n\n 37. 不要重新定义继承来的缺省参数值， 因为可能会在调用子类的时候， 用到父类里面这个函数的默认值，（对于通过对象指针， 引用的方式都会有这个问题， 因为默认参数的绑定是一种静态绑定），子类就声明参数就可以了， 不需要有默认值\n\n\n# Item 38：通过复合塑模出has-a或“根据某物实现出” Model"has-a"or"is-implemented-in-terms-of"through composition.\n\n 38. 通过composition实现has a, 或者根据某物实现的关系\n     \n     1. 要区分， composite和interitate之间的区别（复合与继承之间的关系）\n\n\n# Item 39：明智而审慎地使用private继承 Use private inheritance judiciously.\n\n 39. 谨慎使用private继承，\n     1. 编译器不会把一个private继承的子类，自动转换成一个基类\n     2. private继承下来的所有成员， 在子类中都会变成private属性\n     3. protect继承\n        1. 默认的基本上都是public继承；\n        2. 尽可能使用compiosition， 必要的时候再使用private继承\n\n\n# Item 40：明智而审慎地使用多重继承 Use multiple inheritance judiciously.\n\n 40. 谨慎使用多重继承（子类从多个父类继承而来）\n     1. 可能对导致对基类函数调用的歧义，到底调用的是哪一个基类的成员函数？\n     2. 钻石形继承， 二级基类可以是虚基类(virtual继承)， 这样三级再继承的时候， 就不会重复出现两个爷爷类里面的成员函数了；\n     3. virtual继承会带来更多大小，速度，初始化的成本。如果非要有一个virtual base class， 最好不要在虚基类里面放置数据；\n     4. 有一种情况， 比较适合多重继承，public继承某个interface class， private继承某个协助实现的class；帮助子类实现某些功能。但是还是谨记第一条吧；',normalizedContent:'# 继承与oop, inheritance and object-oriented design\n\n * 单一继承与多重继承\n\n * public继承，private继承， protected继承\n   \n   class person{ ... }\n   class student : public person{ ... }\n   \n   \n   1\n   2\n   \n\n * virtual / non-virtual 继承\n\n * 成员函数和其他语言特性的影响\n   \n   * 缺省参数与virtual函数的影响？\n   * 继承如何影响c++函数名臣的查找规则？\n   * 设计选项\n   * class行为如果要修改， virtual函数是最佳选择吗？\n\n\n# item 32：确定你的public继承塑模出is-a关系 make sure public inheritancemodels"is-a."\n\n 32. public继承的时候， 确认两个对象是 is a的关系；多态通过虚函数来完成，\n     \n     1. 什么时候用虚函数？什么时候用纯虚函数？\n\n\n# item 33：避免遮掩继承而来的名称 avoid hiding inherited names.\n\n 33. 继承的时候，注意类内部的变量名称是否会被覆盖，\n\n * 即使是重载的函数，不管函数接口形式是否一样， 也会被子类的同名函数覆盖\n * 使用using base::mf3() 可以指定在子类作用域范围里面使用base类的mf3函数，\n * 如果只想使用某一个mf3(), 只能是子类的函数里面， 再调用base::mf3(); 这种方式叫forward functions;\n\n\n# item 34：区分接口继承和实现继承 differentiate between inheritance of interface and inheritance of implementation.\n\n 34. 什么是接口继承和实现继承？\n     1. pure virtual函数的目的就是接口继承， 但是也可以有一份基类实现，调用的时候只能通过子类指定父类名称的方式来调用（纯虚函数必须重写）；\n     2. 非纯虚函数是为了让子类继承接口 + 缺省实现， 这些都是自动继承的， 如果子类不override 虚函数的话（一般虚函数可以重写， 也可以不重写）；\n     3. 非虚函数的目的是强制让子类继承一个缺省的实现；（非虚函数，没有多态性，直接继承）\n     4. 接口和实现继承分开， 也就是把接口用一个纯虚函数来声明， 实现使用一个private或者protected的缺省实现来代替， 这样子类必须要重写纯虚函数，但是可以默认使用缺省的实现；\n     5. 也可以使用一个虚函数的非虚实现， 然后再在子类里面overide的时候调用这个函数；\n\n\n# item 35：考虑virtual函数以外的其他选择 consider alte rnatives to virtual functions.\n\n 35. 除了virtual函数之外，也可以考虑一下其他的选择\n     1. 通过一个public函数， 调用自己的virtual函数， non-virtual interface（nvi）方法；（模板方法设计模式）， 子类就\n     2. 借助funciion pointer实现strategy模式\n     3. 使用各个库里面的function component来实现strategy模式， 例如std::function， 而且这个东西支持任何callable entities，包括运算符重载的struct和class\n     4. 标准设计模式， 古典的strategy模式， 就是使用pimple的方式来实现strategy， 来代替第一条里面的实现方式\n\n\n# item 36：绝不重新定义继承而来的non-virtual函数 never redefine an inherited non-virtual function.\n\n 36. 不要重新定义继承来的non virtual函数， 这其实是一种overloading， 并不能实现多态特性的overide， nonvirtual 函数其实是静态绑定的(dynamic binding)；virtual函数是动态绑定(dynamic binding)\n\n\n# item 37：绝不重新定义继承而来的缺省参数值 never redefine a function\'s inherited default parameter value.\n\n 37. 不要重新定义继承来的缺省参数值， 因为可能会在调用子类的时候， 用到父类里面这个函数的默认值，（对于通过对象指针， 引用的方式都会有这个问题， 因为默认参数的绑定是一种静态绑定），子类就声明参数就可以了， 不需要有默认值\n\n\n# item 38：通过复合塑模出has-a或“根据某物实现出” model"has-a"or"is-implemented-in-terms-of"through composition.\n\n 38. 通过composition实现has a, 或者根据某物实现的关系\n     \n     1. 要区分， composite和interitate之间的区别（复合与继承之间的关系）\n\n\n# item 39：明智而审慎地使用private继承 use private inheritance judiciously.\n\n 39. 谨慎使用private继承，\n     1. 编译器不会把一个private继承的子类，自动转换成一个基类\n     2. private继承下来的所有成员， 在子类中都会变成private属性\n     3. protect继承\n        1. 默认的基本上都是public继承；\n        2. 尽可能使用compiosition， 必要的时候再使用private继承\n\n\n# item 40：明智而审慎地使用多重继承 use multiple inheritance judiciously.\n\n 40. 谨慎使用多重继承（子类从多个父类继承而来）\n     1. 可能对导致对基类函数调用的歧义，到底调用的是哪一个基类的成员函数？\n     2. 钻石形继承， 二级基类可以是虚基类(virtual继承)， 这样三级再继承的时候， 就不会重复出现两个爷爷类里面的成员函数了；\n     3. virtual继承会带来更多大小，速度，初始化的成本。如果非要有一个virtual base class， 最好不要在虚基类里面放置数据；\n     4. 有一种情况， 比较适合多重继承，public继承某个interface class， private继承某个协助实现的class；帮助子类实现某些功能。但是还是谨记第一条吧；',charsets:{cjk:!0}},{title:"操作符（operators）",frontmatter:{title:"操作符（operators）",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/225e98/"},regularPath:"/01.Wiki/19.Reading%20Notes/02.More%20Effective%20C++/02.%E6%93%8D%E4%BD%9C%E7%AC%A6.html",relativePath:"01.Wiki/19.Reading Notes/02.More Effective C++/02.操作符.md",key:"v-1cc12d3b",path:"/pages/225e98/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:2,title:"操作符（operators）",slug:"操作符-operators",normalizedTitle:"操作符（operators）",charIndex:6},{level:3,title:"Item 5：对定制的“类型转换函数”保持警觉， cast function",slug:"item-5-对定制的-类型转换函数-保持警觉-cast-function",normalizedTitle:"item 5：对定制的“类型转换函数”保持警觉， cast function",charIndex:25},{level:3,title:"Item  6：区别     increment/decrement  操作符的前置（prefix）和后置（postfix）形式",slug:"item-6-区别-increment-decrement-操作符的前置-prefix-和后置-postfix-形式",normalizedTitle:"item  6：区别     increment/decrement  操作符的前置（prefix）和后置（postfix）形式",charIndex:null},{level:3,title:"Item  7：千万不要重载 &&，||   和， 操作符",slug:"item-7-千万不要重载-和-操作符",normalizedTitle:"item  7：千万不要重载 &amp;&amp;，||   和， 操作符",charIndex:null},{level:3,title:"Item  8：了解各种不同意义的 new和 delete",slug:"item-8-了解各种不同意义的-new和-delete",normalizedTitle:"item  8：了解各种不同意义的 new和 delete",charIndex:null}],headersStr:" 操作符（operators） Item 5：对定制的“类型转换函数”保持警觉， cast function Item  6：区别     increment/decrement  操作符的前置（prefix）和后置（postfix）形式 Item  7：千万不要重载 &&，||   和， 操作符 Item  8：了解各种不同意义的 new和 delete",content:'#\n\n\n# 操作符（operators）\n\n\n# Item 5：对定制的“类型转换函数”保持警觉， cast function\n\n允许编译器执行隐式类型转换, 坏处大于好处， 所以对于自己定制的类型转换函数，要小心（拷贝构造, 拷贝赋值）：\n\n * 主要是一些内建default对类对象的类型转换， 比如int和short之间类型的默认转换\n\n * 一些转换函数 在自己想不到的时候， 会偶然被调用；\n\n * 所以自定义类型转换, 要避免发生隐式类型转换, 它最好只能够非常清晰地从type A到typeB\n\n * 关键词 explicit。这个特性之所以被导入，就是为了解决隐式类型转换带来的问题。其用法十分直接易懂，只要将 constructors声明为 explicit，编译器就不能因隐式类型转换而调用它们。特别是对于单一参数的构造函数，加上explicit；\n   \n   * 单一参数的构造函数， 大概会有两种理解方式， 单一参数， 多参数但是后面的参数有默认值，\n     \n     class Name{\n         Name(const string& s ); // 把string转换为Name\n         ...\n     };\n     \n     class Rational{\n         Rational(int numerator=0, ind denominator=1); // 把int转换为Rational\n         // 为了让 Rational objects 能够被隐式转换为doubles（这对掺杂有 Rational objects的混合算术运算可能有用）\n         operator double() const; // 把rational转换为const， 在cout<<Rational找不到的时候，可能把这个Rational当作double来输出\n         \n         ...\n     };\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     \n   \n   * 愈有经验的 C++程序员愈可能避免使用类型转换操作符\n     \n     template<class T>\n     class Array{\n     public:\n         class ArraySize{ // 这个新加入的class就被称为proxy class\n         public:\n             ArraySize(int numElements) : theSize(numElements) {}\n             int size() const { return theSize;}\n         private:\n             int theSize;\n         };\n         Array(int lowBound, int highBound); // 双参数的ctor, 没法成为类型转换函数\n         Array(int size); // 本来的语义是构造一个包含size个元素的Array，但是使用（）却会造成一个单参数的implicit类型转换\n         \n         // 使用explicit可以避免implicit的类型转换 如下：\n         explicit Array(int size);\n         \n         Array(ArraySize size); // 使用了上面的proxy class\n     }\n     \n     //如果不是使用下标[], 一不小心使用了（）， 就会造成一个类型转换；\n     Array<int> a(10);\n     Array<int> b(10)\n         \n     a == b[10]; // ?\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     \n\n * 考虑 Array template的时候。需要一种方法，不仅允许以一个整数作为constructor 自变量来指定数组大小，又要阻止一个整数被隐式转换为一个临时性Array 对象。所以要产生一个新的 class，名为 ArraySize。\n\n * 类似 ArraySize 这样的 classes，往往被称为proxy classes，因为它的每一个对象都是为了其他对象而存在的, 把 ArraySize 嵌套放进 Array 内，强调一个事实：它永远与 Array搭配使用\n   \n   template<class T>\n   class Array{\n   public:\n       class ArraySize{ // 这个新加入的class就被称为proxy class\n       public:\n           ArraySize(int numElements) : theSize(numElements) {}\n           int size() const { return theSize;}\n       private:\n           int theSize;\n       };\n       Array(int lowBound, int highBound); // 双参数的ctor, 没法成为类型转换函数    \n       Array(ArraySize size); // 使用了上面的proxy class\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n\n# Item 6：区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式\n\n * 重载的时候, 前置是operator++()，后置是operator++(int)， ++C没有临时变量，C++是有的\n\n * 返回const原值是为了避免连加， 但是却能够把这个值赋给别人： c++++ --\x3e ints 并不允许连续两次使用后置式 increment 操作符\n   \n   const UPInt UPInt::opreator++(){  // ++a， 没有临时变量， 理论上更高效\n     \t*this += 1;\n     \treturn *this;\t\n   } \n     \n   const UPInt UPInt::opreator++(int){ // a++， 所以后置的时候， 会用到前置的重构在函数\n     \tUPInt oldValue = *this;\n     \t++(*this);\n     \treturn oldValue;\t\n   } \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n\n# Item 7：千万不要重载 &&，|| 和， 操作符\n\n * C++允许为“用户定制类型”量身定做&&和||操作符。做法是对operator&&和 operator||两函数进行重载工作。你可以在global scope 或是在每个 class内做这件事儿。然而如果你决定运用这个机会，你必须知道，从此“函数调用 语义”会取代“骤死式 语义”，也就是说将operator&&重载之\n   \n   if(expr1 && expr2) ...\n   \n   // 上面的语句将会改为一下两种操作之一\n   if(expr1.operator&&(expr2) ...\n   if(operator&&(expr1, expr2)) ...\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   * 重载&& , ||操作符之后, 再调用这些重载函数, 所有的expr都需要已经被计算出来, 但通常我们在用这些操作符的时候会把一些没有计算出来的表达式放在里面去做||, &&操作, 这样就不能构成“骤死式 语义”\n   \n   * C++并未明确定义函数调用动作中各参数的计算顺序，所以没办法知道expr1和expr2哪个会先被计算出来。\n\n\n# Item 8：了解各种不同意义的 new和 delete\n\n对不同含义的new和delete， 需要充分搞清楚区别和含义；[拓展： 侯捷, 内存管理课程]\n\n// new operator:\nstring *ps = new string("Memory management");\ndelete ps; //只有new operator出来的内存才能delete， malloc出来的要经过cast成为对象的指针才能够使用delete；\ndelete [] ps; // 如果ps是一个数组的话, 需要使用delete []\n\n// operator new: 唯一任务就是分配内存, 返回一个void*类型的指针\nvoid* operator new(size_t size);\nvoid* rawMemory = operator new(sizeof(string)); //可以直接这样使用，像使用malloc一样， 把内存转换成对象是new operator做的事情；\nstring* ps = static_cast<string*>(rawMemory); // operator new之后的raw内存， 再cast成特定的指针类型\n// 使用operator delete: 类似于malloc之后的free\noperater delete(rawMemory); \n\n//placement new：返回指向一个Widget object的指针，构造于buffer上， 当运行到shared memory或memory-mapped I/O时候，这种函数也许有用的，等于是结合了new operator和operator new, 构成了一个先operator new然后再隐式用new做了一次static_cast\nWidget* constructWidgetInBuffer(void *buffer, int widgetSize){\n return new (buffer) Widget(widgetSize); // 这里等于是结合了new operator和operator new, 构成了一个隐式的cast\n}\n\n// 指针数组\nint* bestPractice = new *int[10];\nchar* bestPractice[] = {"C++", "Python", "JavaScript"};\n// 数组指针\nint (*bestPractice)[10];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',normalizedContent:'#\n\n\n# 操作符（operators）\n\n\n# item 5：对定制的“类型转换函数”保持警觉， cast function\n\n允许编译器执行隐式类型转换, 坏处大于好处， 所以对于自己定制的类型转换函数，要小心（拷贝构造, 拷贝赋值）：\n\n * 主要是一些内建default对类对象的类型转换， 比如int和short之间类型的默认转换\n\n * 一些转换函数 在自己想不到的时候， 会偶然被调用；\n\n * 所以自定义类型转换, 要避免发生隐式类型转换, 它最好只能够非常清晰地从type a到typeb\n\n * 关键词 explicit。这个特性之所以被导入，就是为了解决隐式类型转换带来的问题。其用法十分直接易懂，只要将 constructors声明为 explicit，编译器就不能因隐式类型转换而调用它们。特别是对于单一参数的构造函数，加上explicit；\n   \n   * 单一参数的构造函数， 大概会有两种理解方式， 单一参数， 多参数但是后面的参数有默认值，\n     \n     class name{\n         name(const string& s ); // 把string转换为name\n         ...\n     };\n     \n     class rational{\n         rational(int numerator=0, ind denominator=1); // 把int转换为rational\n         // 为了让 rational objects 能够被隐式转换为doubles（这对掺杂有 rational objects的混合算术运算可能有用）\n         operator double() const; // 把rational转换为const， 在cout<<rational找不到的时候，可能把这个rational当作double来输出\n         \n         ...\n     };\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     \n   \n   * 愈有经验的 c++程序员愈可能避免使用类型转换操作符\n     \n     template<class t>\n     class array{\n     public:\n         class arraysize{ // 这个新加入的class就被称为proxy class\n         public:\n             arraysize(int numelements) : thesize(numelements) {}\n             int size() const { return thesize;}\n         private:\n             int thesize;\n         };\n         array(int lowbound, int highbound); // 双参数的ctor, 没法成为类型转换函数\n         array(int size); // 本来的语义是构造一个包含size个元素的array，但是使用（）却会造成一个单参数的implicit类型转换\n         \n         // 使用explicit可以避免implicit的类型转换 如下：\n         explicit array(int size);\n         \n         array(arraysize size); // 使用了上面的proxy class\n     }\n     \n     //如果不是使用下标[], 一不小心使用了（）， 就会造成一个类型转换；\n     array<int> a(10);\n     array<int> b(10)\n         \n     a == b[10]; // ?\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     \n\n * 考虑 array template的时候。需要一种方法，不仅允许以一个整数作为constructor 自变量来指定数组大小，又要阻止一个整数被隐式转换为一个临时性array 对象。所以要产生一个新的 class，名为 arraysize。\n\n * 类似 arraysize 这样的 classes，往往被称为proxy classes，因为它的每一个对象都是为了其他对象而存在的, 把 arraysize 嵌套放进 array 内，强调一个事实：它永远与 array搭配使用\n   \n   template<class t>\n   class array{\n   public:\n       class arraysize{ // 这个新加入的class就被称为proxy class\n       public:\n           arraysize(int numelements) : thesize(numelements) {}\n           int size() const { return thesize;}\n       private:\n           int thesize;\n       };\n       array(int lowbound, int highbound); // 双参数的ctor, 没法成为类型转换函数    \n       array(arraysize size); // 使用了上面的proxy class\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n\n# item 6：区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式\n\n * 重载的时候, 前置是operator++()，后置是operator++(int)， ++c没有临时变量，c++是有的\n\n * 返回const原值是为了避免连加， 但是却能够把这个值赋给别人： c++++ --\x3e ints 并不允许连续两次使用后置式 increment 操作符\n   \n   const upint upint::opreator++(){  // ++a， 没有临时变量， 理论上更高效\n     \t*this += 1;\n     \treturn *this;\t\n   } \n     \n   const upint upint::opreator++(int){ // a++， 所以后置的时候， 会用到前置的重构在函数\n     \tupint oldvalue = *this;\n     \t++(*this);\n     \treturn oldvalue;\t\n   } \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n\n# item 7：千万不要重载 &&，|| 和， 操作符\n\n * c++允许为“用户定制类型”量身定做&&和||操作符。做法是对operator&&和 operator||两函数进行重载工作。你可以在global scope 或是在每个 class内做这件事儿。然而如果你决定运用这个机会，你必须知道，从此“函数调用 语义”会取代“骤死式 语义”，也就是说将operator&&重载之\n   \n   if(expr1 && expr2) ...\n   \n   // 上面的语句将会改为一下两种操作之一\n   if(expr1.operator&&(expr2) ...\n   if(operator&&(expr1, expr2)) ...\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   * 重载&& , ||操作符之后, 再调用这些重载函数, 所有的expr都需要已经被计算出来, 但通常我们在用这些操作符的时候会把一些没有计算出来的表达式放在里面去做||, &&操作, 这样就不能构成“骤死式 语义”\n   \n   * c++并未明确定义函数调用动作中各参数的计算顺序，所以没办法知道expr1和expr2哪个会先被计算出来。\n\n\n# item 8：了解各种不同意义的 new和 delete\n\n对不同含义的new和delete， 需要充分搞清楚区别和含义；[拓展： 侯捷, 内存管理课程]\n\n// new operator:\nstring *ps = new string("memory management");\ndelete ps; //只有new operator出来的内存才能delete， malloc出来的要经过cast成为对象的指针才能够使用delete；\ndelete [] ps; // 如果ps是一个数组的话, 需要使用delete []\n\n// operator new: 唯一任务就是分配内存, 返回一个void*类型的指针\nvoid* operator new(size_t size);\nvoid* rawmemory = operator new(sizeof(string)); //可以直接这样使用，像使用malloc一样， 把内存转换成对象是new operator做的事情；\nstring* ps = static_cast<string*>(rawmemory); // operator new之后的raw内存， 再cast成特定的指针类型\n// 使用operator delete: 类似于malloc之后的free\noperater delete(rawmemory); \n\n//placement new：返回指向一个widget object的指针，构造于buffer上， 当运行到shared memory或memory-mapped i/o时候，这种函数也许有用的，等于是结合了new operator和operator new, 构成了一个先operator new然后再隐式用new做了一次static_cast\nwidget* constructwidgetinbuffer(void *buffer, int widgetsize){\n return new (buffer) widget(widgetsize); // 这里等于是结合了new operator和operator new, 构成了一个隐式的cast\n}\n\n// 指针数组\nint* bestpractice = new *int[10];\nchar* bestpractice[] = {"c++", "python", "javascript"};\n// 数组指针\nint (*bestpractice)[10];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',charsets:{cjk:!0}},{title:"异常（exceptions）",frontmatter:{title:"异常（exceptions）",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/3e106f/"},regularPath:"/01.Wiki/19.Reading%20Notes/02.More%20Effective%20C++/03.%E5%BC%82%E5%B8%B8.html",relativePath:"01.Wiki/19.Reading Notes/02.More Effective C++/03.异常.md",key:"v-2f694f79",path:"/pages/3e106f/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:2,title:"异常（exceptions）",slug:"异常-exceptions",normalizedTitle:"异常（exceptions）",charIndex:6},{level:3,title:"Item  9：利用     destructors避免泄漏资源",slug:"item-9-利用-destructors避免泄漏资源",normalizedTitle:"item  9：利用     destructors避免泄漏资源",charIndex:null},{level:3,title:"Item  10：在     constructors内阻止资源泄漏（resource leak）",slug:"item-10-在-constructors内阻止资源泄漏-resource-leak",normalizedTitle:"item  10：在     constructors内阻止资源泄漏（resource leak）",charIndex:null},{level:3,title:"Item  11：禁止异常（exceptions）流出 destructors之外",slug:"item-11-禁止异常-exceptions-流出-destructors之外",normalizedTitle:"item  11：禁止异常（exceptions）流出 destructors之外",charIndex:null},{level:3,title:"Item  12：了解“抛出一个     exception”与“传递一个参数”或“调用一个虚函数”之间的差异",slug:"item-12-了解-抛出一个-exception-与-传递一个参数-或-调用一个虚函数-之间的差异",normalizedTitle:"item  12：了解“抛出一个     exception”与“传递一个参数”或“调用一个虚函数”之间的差异",charIndex:null},{level:3,title:"Item  13：以 Catch-by-reference 方式捕捉 exceptions",slug:"item-13-以-catch-by-reference-方式捕捉-exceptions",normalizedTitle:"item  13：以 catch-by-reference 方式捕捉 exceptions",charIndex:null},{level:3,title:"Item  14：明智运用 exception specifications",slug:"item-14-明智运用-exception-specifications",normalizedTitle:"item  14：明智运用 exception specifications",charIndex:null},{level:3,title:"Item 15：了解异常处理（exception handling）的成本",slug:"item-15-了解异常处理-exception-handling-的成本",normalizedTitle:"item 15：了解异常处理（exception handling）的成本",charIndex:2523}],headersStr:" 异常（exceptions） Item  9：利用     destructors避免泄漏资源 Item  10：在     constructors内阻止资源泄漏（resource leak） Item  11：禁止异常（exceptions）流出 destructors之外 Item  12：了解“抛出一个     exception”与“传递一个参数”或“调用一个虚函数”之间的差异 Item  13：以 Catch-by-reference 方式捕捉 exceptions Item  14：明智运用 exception specifications Item 15：了解异常处理（exception handling）的成本",content:"#\n\n\n# 异常（exceptions）\n\n\n# Item 9：利用 destructors避免泄漏资源\n\n利用destructor来避免资源的泄露（什么是资源泄露？没有delete的指针）， 最好还是使用智能指针的类来处理会比较好；\n\n * 要么catch到exception之后， 要及时释放资源， 避免资源泄露；\n\n * 要么就在destructor里面， 增加资源的释放， 即使遇到异常， 退出的时候也会调用析构函数里面的delete；\n\n * 虚基类（多态基类）一定要有自己的虚dtor函数【Effectie C++里面也用到了】\n   \n   使用智能指针， auto_ptr(), shared_ptr(), weak_ptr() 注意他们相关的实现\n\n\n# Item 10：在 constructors内阻止资源泄漏（resource leak）\n\n利用constructor来避免资源泄露（最好还是使用智能指针的类比较好）\n\n * 在构造新对象的过程中， 如果构造失败， 就可能会造成资源泄露\n\n * 析构函数指挥析构已经构造完成的对象， 所以要考虑到在构造对象的时候，是否会发生异常。\n\n * 所以要直接在构造函数里面对构造失败的异常进行捕获， 并且处理好这些异常， 对野指针进行delete。\n\n * 把这些指针的删除， 全部包在一个clean up()的函数里面；\n\n * 指向const的指针， 只能在初始化列表里面进行初始化， 这些对象的初始化过程中的异常， 可以放在一个private函数里面去进行，\n\n * 不过最好还是使用auto_ptr之类的东西， 直接去管理类的成员数据， 比较方便一些\n\n * 由于 C++不自动清理那些“构造期间抛出 exceptions”的对象，所以你必须设计你的 constructors，使它们在那种情况下亦能自我清理。\n\n\n# Item 11：禁止异常（exceptions）流出 destructors之外\n\n别让异常跑出destructor（dtor里面， 就不要再把异常往外抛了）\n\n 1. 可以避免 terminate函数在exception传播过程的栈展开（stack-unwinding）机制中被调用；\n 2. 它可以协助确保 destructors 完成其应该完成的所有事情, 程序不会中断。\n 3. 也可以dtor里面也可以什么都不做， 就是为了程序能够顺利运行下去， 但是要确保这个异常不会真正影响程序本身\n\n\n# Item 12：了解“抛出一个 exception”与“传递一个参数”或“调用一个虚函数”之间的差异\n\n弄清楚， 抛出一个异常， 和 传递一个参数之间的区别\n\n一个对象被抛出作为 exception时，总是会发生复制（copy）, 但是若是以by value的方式捕获， throw和catch的时候， 都会发生一次临时变量的复制；\n\nvoid passAndThrowWidget(){\n\tstatic Widget localWidget;\n\t\n\tcin >> localWidget;\n\tthrow localWidget; // 还是会对localWidget发生copy行为，然后再抛出\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n两种不同的throw语句：\n\ncatch(Widget &w){\n    ... \n    throw; // 重新抛出这个exception，使它能继续传播\n}\n\ncatch(Widget &w){\n    ...\n    throw w; // 处理好之后， 继续往外传播这里catch到的exception\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n三种catch语句：\n\ncatch (Widget w) ...\ncatch (Wiget& w) ...\ncatch (const Widget& w) ...\n\n\n1\n2\n3\n\n\nexecption和catch子句之间 不能发生隐式的类型转换：\n\nvoid func(int value){\n    try{\n        if(someFunction()){\n            throw value;\n        }\n    } \n    catch(double d){ // 上面throw的是一个int类型， 这里是catch不到这个value的\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n但是，类型转换是能够发生在C++ exceptions的继承体系中的，可以理解为exception支持多态：\n\n从有形指针抓换为无形指针的转换，catch是支持的：\n\ncatch(const void*){\n    ...\n}\n\n\n1\n2\n3\n\n\n\n# Item 13：以 Catch-by-reference 方式捕捉 exceptions\n\n * by value的局部变量复制问题， 并且，如果我们要继承exception定义自己的exception子类， 使用by value，虽然支持catch， 会发生slicing的问题， 也就是多态只能够针对地址类型才能够有效\n\n * by pointer 会有局部对象问题需要考虑，用起来考虑的问题比较多（catch之后要不要删除？是否返回了局部对象的地址？）\n\n * 所以要以Catch-by-reference的方式捕获一个exception;\n\n\n# Item 14：明智运用 exception specifications\n\n明智地运用exception specification， 因为一旦使用， 就和async的使用一样， exception也会有内外传递的问题；\n\nvoid func() throw(int); // 这里指定func()会抛出一个int类型的exception\n// 继承exception定义自己的exception的时候，也是这种形势， 需要重新定义what的行为；\n\n\n1\n2\n\n\n\n# Item 15：了解异常处理（exception handling）的成本\n\n * 要清楚异常处理带来的成本；这些东西是C++本身就包括在里面的\n\n * 粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%～10%，执行速度亦大约下降这个数。这是在假设没有任何 exceptions 被抛出的情况下。此处我们所讨论的只是“代码中出现 try 语句块”的成本而已。\n\n * 主要是时间和空间上面的成本；\n\n * 需要讨论， C++ runtime时候， 编译， 连接的时候，对这些exceptions是怎么处理的？要使用profile工具针对特定程序做特定的性能分析；",normalizedContent:"#\n\n\n# 异常（exceptions）\n\n\n# item 9：利用 destructors避免泄漏资源\n\n利用destructor来避免资源的泄露（什么是资源泄露？没有delete的指针）， 最好还是使用智能指针的类来处理会比较好；\n\n * 要么catch到exception之后， 要及时释放资源， 避免资源泄露；\n\n * 要么就在destructor里面， 增加资源的释放， 即使遇到异常， 退出的时候也会调用析构函数里面的delete；\n\n * 虚基类（多态基类）一定要有自己的虚dtor函数【effectie c++里面也用到了】\n   \n   使用智能指针， auto_ptr(), shared_ptr(), weak_ptr() 注意他们相关的实现\n\n\n# item 10：在 constructors内阻止资源泄漏（resource leak）\n\n利用constructor来避免资源泄露（最好还是使用智能指针的类比较好）\n\n * 在构造新对象的过程中， 如果构造失败， 就可能会造成资源泄露\n\n * 析构函数指挥析构已经构造完成的对象， 所以要考虑到在构造对象的时候，是否会发生异常。\n\n * 所以要直接在构造函数里面对构造失败的异常进行捕获， 并且处理好这些异常， 对野指针进行delete。\n\n * 把这些指针的删除， 全部包在一个clean up()的函数里面；\n\n * 指向const的指针， 只能在初始化列表里面进行初始化， 这些对象的初始化过程中的异常， 可以放在一个private函数里面去进行，\n\n * 不过最好还是使用auto_ptr之类的东西， 直接去管理类的成员数据， 比较方便一些\n\n * 由于 c++不自动清理那些“构造期间抛出 exceptions”的对象，所以你必须设计你的 constructors，使它们在那种情况下亦能自我清理。\n\n\n# item 11：禁止异常（exceptions）流出 destructors之外\n\n别让异常跑出destructor（dtor里面， 就不要再把异常往外抛了）\n\n 1. 可以避免 terminate函数在exception传播过程的栈展开（stack-unwinding）机制中被调用；\n 2. 它可以协助确保 destructors 完成其应该完成的所有事情, 程序不会中断。\n 3. 也可以dtor里面也可以什么都不做， 就是为了程序能够顺利运行下去， 但是要确保这个异常不会真正影响程序本身\n\n\n# item 12：了解“抛出一个 exception”与“传递一个参数”或“调用一个虚函数”之间的差异\n\n弄清楚， 抛出一个异常， 和 传递一个参数之间的区别\n\n一个对象被抛出作为 exception时，总是会发生复制（copy）, 但是若是以by value的方式捕获， throw和catch的时候， 都会发生一次临时变量的复制；\n\nvoid passandthrowwidget(){\n\tstatic widget localwidget;\n\t\n\tcin >> localwidget;\n\tthrow localwidget; // 还是会对localwidget发生copy行为，然后再抛出\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n两种不同的throw语句：\n\ncatch(widget &w){\n    ... \n    throw; // 重新抛出这个exception，使它能继续传播\n}\n\ncatch(widget &w){\n    ...\n    throw w; // 处理好之后， 继续往外传播这里catch到的exception\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n三种catch语句：\n\ncatch (widget w) ...\ncatch (wiget& w) ...\ncatch (const widget& w) ...\n\n\n1\n2\n3\n\n\nexecption和catch子句之间 不能发生隐式的类型转换：\n\nvoid func(int value){\n    try{\n        if(somefunction()){\n            throw value;\n        }\n    } \n    catch(double d){ // 上面throw的是一个int类型， 这里是catch不到这个value的\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n但是，类型转换是能够发生在c++ exceptions的继承体系中的，可以理解为exception支持多态：\n\n从有形指针抓换为无形指针的转换，catch是支持的：\n\ncatch(const void*){\n    ...\n}\n\n\n1\n2\n3\n\n\n\n# item 13：以 catch-by-reference 方式捕捉 exceptions\n\n * by value的局部变量复制问题， 并且，如果我们要继承exception定义自己的exception子类， 使用by value，虽然支持catch， 会发生slicing的问题， 也就是多态只能够针对地址类型才能够有效\n\n * by pointer 会有局部对象问题需要考虑，用起来考虑的问题比较多（catch之后要不要删除？是否返回了局部对象的地址？）\n\n * 所以要以catch-by-reference的方式捕获一个exception;\n\n\n# item 14：明智运用 exception specifications\n\n明智地运用exception specification， 因为一旦使用， 就和async的使用一样， exception也会有内外传递的问题；\n\nvoid func() throw(int); // 这里指定func()会抛出一个int类型的exception\n// 继承exception定义自己的exception的时候，也是这种形势， 需要重新定义what的行为；\n\n\n1\n2\n\n\n\n# item 15：了解异常处理（exception handling）的成本\n\n * 要清楚异常处理带来的成本；这些东西是c++本身就包括在里面的\n\n * 粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%～10%，执行速度亦大约下降这个数。这是在假设没有任何 exceptions 被抛出的情况下。此处我们所讨论的只是“代码中出现 try 语句块”的成本而已。\n\n * 主要是时间和空间上面的成本；\n\n * 需要讨论， c++ runtime时候， 编译， 连接的时候，对这些exceptions是怎么处理的？要使用profile工具针对特定程序做特定的性能分析；",charsets:{cjk:!0}},{title:"效率（efficiency）",frontmatter:{title:"效率（efficiency）",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/24653b/"},regularPath:"/01.Wiki/19.Reading%20Notes/02.More%20Effective%20C++/04.%E6%80%A7%E8%83%BD.html",relativePath:"01.Wiki/19.Reading Notes/02.More Effective C++/04.性能.md",key:"v-64b006d2",path:"/pages/24653b/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:2,title:", 这部分可以参考高性能C++相关的书籍",slug:"这部分可以参考高性能c-相关的书籍",normalizedTitle:", 这部分可以参考高性能c++相关的书籍",charIndex:6},{level:3,title:"Item  16：谨记 80-20     法则",slug:"item-16-谨记-80-20-法则",normalizedTitle:"item  16：谨记 80-20     法则",charIndex:null},{level:3,title:"Item  17：考虑使用     lazy evaluation（缓式评估）",slug:"item-17-考虑使用-lazy-evaluation-缓式评估",normalizedTitle:"item  17：考虑使用     lazy evaluation（缓式评估）",charIndex:null},{level:3,title:"Item  18：分期摊还预期的计算成本",slug:"item-18-分期摊还预期的计算成本",normalizedTitle:"item  18：分期摊还预期的计算成本",charIndex:null},{level:3,title:"Item 19：了解临时对象的来源",slug:"item-19-了解临时对象的来源",normalizedTitle:"item 19：了解临时对象的来源",charIndex:917},{level:3,title:"Item 20：协助完成“返回值优化（RVO）”",slug:"item-20-协助完成-返回值优化-rvo",normalizedTitle:"item 20：协助完成“返回值优化（rvo）”",charIndex:1039},{level:3,title:"Item 21：利用重载技术（overload）避免隐式类型转换（implicit type conversions）",slug:"item-21-利用重载技术-overload-避免隐式类型转换-implicit-type-conversions",normalizedTitle:"item 21：利用重载技术（overload）避免隐式类型转换（implicit type conversions）",charIndex:1230},{level:3,title:"Item  22：考虑以操作符复合形式（op=）取代其独身形式（op）",slug:"item-22-考虑以操作符复合形式-op-取代其独身形式-op",normalizedTitle:"item  22：考虑以操作符复合形式（op=）取代其独身形式（op）",charIndex:null},{level:3,title:"Item 23：考虑使用其他程序库",slug:"item-23-考虑使用其他程序库",normalizedTitle:"item 23：考虑使用其他程序库",charIndex:1835},{level:3,title:"Item  24：了解 virtual functions、multiple inheritance、virtual base classes、runtime type  identification的成本",slug:"item-24-了解-virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification的成本",normalizedTitle:"item  24：了解 virtual functions、multiple inheritance、virtual base classes、runtime type  identification的成本",charIndex:null}],headersStr:" , 这部分可以参考高性能C++相关的书籍 Item  16：谨记 80-20     法则 Item  17：考虑使用     lazy evaluation（缓式评估） Item  18：分期摊还预期的计算成本 Item 19：了解临时对象的来源 Item 20：协助完成“返回值优化（RVO）” Item 21：利用重载技术（overload）避免隐式类型转换（implicit type conversions） Item  22：考虑以操作符复合形式（op=）取代其独身形式（op） Item 23：考虑使用其他程序库 Item  24：了解 virtual functions、multiple inheritance、virtual base classes、runtime type  identification的成本",content:"#\n\n\n# , 这部分可以参考高性能C++相关的书籍\n\n与运行时， 虚函数， 以及对象的内存模型相关的知识；\n\n\n# Item 16：谨记 80-20 法则\n\n要清楚80-20法则， 有时候还是根方效率， 也就是100个人里面， 只有10个人完成了一半的工作， 10000个人里面只有100个人完成了一半的工作；\n\n * 只有20%代码占用了程序的80%的时间\n * 需要对程序做合理的profile， 找出程序的热点函数\n\n\n# Item 17：考虑使用 lazy evaluation（缓式评估）\n\n考虑使用缓式评估（lazy evaluation）: 可避免非必要的对象复制，可区别 operator[]的读取和写动作，可避免非必要的数据库读取动作，可避免非必要的数值计算动作\n\n * Laze Fetching：产生Object对象的时候不从数据库里面取出文件，里面字段被用到的时候再取， copy on write;\n * Lazy Expression Evaluation\n * 用到的时候, 再把需要的中间变量计算出来, 不然过早计算, 可能后面会用不到,\n * 避免不必要的重复冗余计算;\n * 用到的变量, 也是这样, 过早声明定义, 有可能会浪费\n\n\n# Item 18：分期摊还预期的计算成本\n\n分期摊还预期的计算成本\n\n 1. SW Cache\n\n 2. Prefetch:\n    \n    > 你可以把 prefetching 想象是购买大量物品时的一个折扣。例如，磁盘控制器，当它们从磁盘中读取数据时，读的是整个数据块或 sectors——即使程序只需其中少量数据。那是因为一次读一大块数据比分成两三次每次读小块数据，速度上快得多。此外，经验显示，如果某处的数据被需要，通常其邻近的数据也会被需要，这便是有名的 locality of reference 现象（译注：意指被取用的数据有“位置集中”的倾向）。系统设计者依此现象而设计出磁盘缓存（disk caches）、指令与数据的内存缓存（memory caches），以及“指令预先取出（instruction prefetches）”。\n\n\n# Item 19：了解临时对象的来源\n\n 1. 函数的变量传递（pass by value 或者 pass to reference-to-const）\n 2. 函数的返回值（return to const极有可能会产生一个临时的对象）\n\n\n# Item 20：协助完成“返回值优化（RVO）”\n\n协助程序完成返回值优化（RVO） 在return by value的时候，\n\nconst rational(int a, int b){\n    return Rational(a + b);  // 在最后return的语句里面，直接返回实例的表达式， 可以省去在函数体内部多出来的一个临时对象；\n}\n\n\n1\n2\n3\n\n\n\n# Item 21：利用重载技术（overload）避免隐式类型转换（implicit type conversions）\n\noverload一个global function来支持不同类型的参数， 从而避免隐式的类型转换\n\nconst UPInt operator+(int lhs, const UPInt& rhs); \n\n\n1\n\n\n\n# Item 22：考虑以操作符复合形式（op=）取代其独身形式（op）\n\n考虑使用操作符复合形式（op=）取代其独立的形式（op）\n\n * += 比 + 拥有更少的临时对象，\n\n * 在类的里面， operator+ 调用operator+=\n\n * 在类的外面， 全局重载的operator+, 调用了局部的operator+=\n\n * 在进行操作符重载的时候， 独立形式的操作符也会使用复合形式的操作符重载来完成， 和++a a++一样， 都会有多余的overhead；\n\n * 返回匿名对象的overhead不会比返回命名对象更多\n   \n   template<T>\n   const T operator+(const T& lhs, const T& rhs){\n       T result(lhs);\n       return result += rhs;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# Item 23：考虑使用其他程序库\n\n观点在工作执行的时候， 其实不需要考虑很多；\n\n但是反过来论述工作的重要性和优越性的时候， 需要这些角度和观点的切入；\n\n积极使用其他的库，（更快的性能， 更小的代码体积，效率，扩展性，移植性考虑在内）(这里整理一些不错的C++库，可以用来学习， 也可以用来搜集)\n\n * 基础库\n * 网络库\n * 计算库\n * 存储库\n * json库\n\n比如OneDNN / MKL、 libevent， 以及一些网络的库\n\n\n# Item 24：了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification的成本\n\n时间空间成本（主要是对象模型相关的内容）\n\n虚函数，\n\n多重继承，\n\n虚基类，\n\nRTTI\n\n他们的成本代价都是一些什么？",normalizedContent:"#\n\n\n# , 这部分可以参考高性能c++相关的书籍\n\n与运行时， 虚函数， 以及对象的内存模型相关的知识；\n\n\n# item 16：谨记 80-20 法则\n\n要清楚80-20法则， 有时候还是根方效率， 也就是100个人里面， 只有10个人完成了一半的工作， 10000个人里面只有100个人完成了一半的工作；\n\n * 只有20%代码占用了程序的80%的时间\n * 需要对程序做合理的profile， 找出程序的热点函数\n\n\n# item 17：考虑使用 lazy evaluation（缓式评估）\n\n考虑使用缓式评估（lazy evaluation）: 可避免非必要的对象复制，可区别 operator[]的读取和写动作，可避免非必要的数据库读取动作，可避免非必要的数值计算动作\n\n * laze fetching：产生object对象的时候不从数据库里面取出文件，里面字段被用到的时候再取， copy on write;\n * lazy expression evaluation\n * 用到的时候, 再把需要的中间变量计算出来, 不然过早计算, 可能后面会用不到,\n * 避免不必要的重复冗余计算;\n * 用到的变量, 也是这样, 过早声明定义, 有可能会浪费\n\n\n# item 18：分期摊还预期的计算成本\n\n分期摊还预期的计算成本\n\n 1. sw cache\n\n 2. prefetch:\n    \n    > 你可以把 prefetching 想象是购买大量物品时的一个折扣。例如，磁盘控制器，当它们从磁盘中读取数据时，读的是整个数据块或 sectors——即使程序只需其中少量数据。那是因为一次读一大块数据比分成两三次每次读小块数据，速度上快得多。此外，经验显示，如果某处的数据被需要，通常其邻近的数据也会被需要，这便是有名的 locality of reference 现象（译注：意指被取用的数据有“位置集中”的倾向）。系统设计者依此现象而设计出磁盘缓存（disk caches）、指令与数据的内存缓存（memory caches），以及“指令预先取出（instruction prefetches）”。\n\n\n# item 19：了解临时对象的来源\n\n 1. 函数的变量传递（pass by value 或者 pass to reference-to-const）\n 2. 函数的返回值（return to const极有可能会产生一个临时的对象）\n\n\n# item 20：协助完成“返回值优化（rvo）”\n\n协助程序完成返回值优化（rvo） 在return by value的时候，\n\nconst rational(int a, int b){\n    return rational(a + b);  // 在最后return的语句里面，直接返回实例的表达式， 可以省去在函数体内部多出来的一个临时对象；\n}\n\n\n1\n2\n3\n\n\n\n# item 21：利用重载技术（overload）避免隐式类型转换（implicit type conversions）\n\noverload一个global function来支持不同类型的参数， 从而避免隐式的类型转换\n\nconst upint operator+(int lhs, const upint& rhs); \n\n\n1\n\n\n\n# item 22：考虑以操作符复合形式（op=）取代其独身形式（op）\n\n考虑使用操作符复合形式（op=）取代其独立的形式（op）\n\n * += 比 + 拥有更少的临时对象，\n\n * 在类的里面， operator+ 调用operator+=\n\n * 在类的外面， 全局重载的operator+, 调用了局部的operator+=\n\n * 在进行操作符重载的时候， 独立形式的操作符也会使用复合形式的操作符重载来完成， 和++a a++一样， 都会有多余的overhead；\n\n * 返回匿名对象的overhead不会比返回命名对象更多\n   \n   template<t>\n   const t operator+(const t& lhs, const t& rhs){\n       t result(lhs);\n       return result += rhs;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# item 23：考虑使用其他程序库\n\n观点在工作执行的时候， 其实不需要考虑很多；\n\n但是反过来论述工作的重要性和优越性的时候， 需要这些角度和观点的切入；\n\n积极使用其他的库，（更快的性能， 更小的代码体积，效率，扩展性，移植性考虑在内）(这里整理一些不错的c++库，可以用来学习， 也可以用来搜集)\n\n * 基础库\n * 网络库\n * 计算库\n * 存储库\n * json库\n\n比如onednn / mkl、 libevent， 以及一些网络的库\n\n\n# item 24：了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification的成本\n\n时间空间成本（主要是对象模型相关的内容）\n\n虚函数，\n\n多重继承，\n\n虚基类，\n\nrtti\n\n他们的成本代价都是一些什么？",charsets:{cjk:!0}},{title:"技术（techniques, idioms, patterns）",frontmatter:{title:"技术（techniques, idioms, patterns）",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/b26674/"},regularPath:"/01.Wiki/19.Reading%20Notes/02.More%20Effective%20C++/05.%E6%8A%80%E6%9C%AF.html",relativePath:"01.Wiki/19.Reading Notes/02.More Effective C++/05.技术.md",key:"v-4cf7131f",path:"/pages/b26674/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:2,title:"技术（techniques, idioms, patterns）",slug:"技术-techniques-idioms-patterns",normalizedTitle:"技术（techniques, idioms, patterns）",charIndex:6},{level:3,title:"Item  25：将 constructor和 non-member functions虚化",slug:"item-25-将-constructor和-non-member-functions虚化",normalizedTitle:"item  25：将 constructor和 non-member functions虚化",charIndex:null},{level:3,title:"Item  26：限制某个 class所能产生的对象数量",slug:"item-26-限制某个-class所能产生的对象数量",normalizedTitle:"item  26：限制某个 class所能产生的对象数量",charIndex:null},{level:3,title:"Item  27：要求（或禁止）对象产生于 heap之中",slug:"item-27-要求-或禁止-对象产生于-heap之中",normalizedTitle:"item  27：要求（或禁止）对象产生于 heap之中",charIndex:null},{level:3,title:"Item  28：Smart Pointers（智能指针）",slug:"item-28-smart-pointers-智能指针",normalizedTitle:"item  28：smart pointers（智能指针）",charIndex:null},{level:3,title:"Item  29：Reference counting（引用计数）",slug:"item-29-reference-counting-引用计数",normalizedTitle:"item  29：reference counting（引用计数）",charIndex:null},{level:3,title:"Item  30：为什么要使用Proxy  classes（替身类、代理类）",slug:"item-30-为什么要使用proxy-classes-替身类、代理类",normalizedTitle:"item  30：为什么要使用proxy  classes（替身类、代理类）",charIndex:null},{level:3,title:"Item 31：如何让函数根据一个以上的对象类型来决定如何虚化",slug:"item-31-如何让函数根据一个以上的对象类型来决定如何虚化",normalizedTitle:"item 31：如何让函数根据一个以上的对象类型来决定如何虚化",charIndex:3448}],headersStr:" 技术（techniques, idioms, patterns） Item  25：将 constructor和 non-member functions虚化 Item  26：限制某个 class所能产生的对象数量 Item  27：要求（或禁止）对象产生于 heap之中 Item  28：Smart Pointers（智能指针） Item  29：Reference counting（引用计数） Item  30：为什么要使用Proxy  classes（替身类、代理类） Item 31：如何让函数根据一个以上的对象类型来决定如何虚化",content:'#\n\n\n# 技术（techniques, idioms, patterns）\n\n这部分内容更像是设计模式要解决的相关的问题；\n\n\n# Item 25：将 constructor和 non-member functions虚化\n\nvirtual copy constructor 感觉和设计模式里面的工厂模式是差不多的概念\n\nnon-member function的虚化：写一个虚函数做实际工作，再写一个什么都不做的非虚函数，只负责调用虚函数。当然啦，为了避免这种操作受到函数调用所带来的成本，你可以将非虚函数 inline\n\n#include <iostream>\n\nclass A\n{\n    public:\n        virtual std::ostream &print(std::ostream &s) const = 0;\n};\n\nclass B: public A\n{\n    public:\n        virtual std::ostream &print(std::ostream &s) const { s << "i am b"; return s; };\n};\n\nclass C : public A\n{\n    public:\n        virtual std::ostream &print(std::ostream &s) const { s << "i am c"; return s; };\n};\n\nstd::ostream &operator <<(std::ostream &s, const A &a) // 这就是那个非虚函数，负责调用上面的虚函数\n{\n    return a.print(s);\n}\n\nint main(void)\n{\n    B b;\n    C c;\n    std::cout << b << "\\n" << c << std::endl;\n\n    return 0;\n}\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# Item 26：限制某个 class所能产生的对象数量\n\n限制某个class所能产生的对象数量(如果只是一个， 那么用static对象， 记得看singleton设计模式)\n\n使用引用计数\n\n使用全局函数， 并且用private来封锁ctor和dtor，全局函数里面包裹一个static的对象， 只能产生一个：\n\nclass Printer{\npublic:\n\tvoid submitJob(const PrintJob& Job);\n    void reset();\n   \tvoid performSelfTest();\n    friend Printer& thePrinter();\n    ...\nprivate:\n    Printer();\n    Printer(const Printer& rhs);\n    ...\n}\n\nPrinter& thePrinter(){\n    static Printer p; // 这里限制了程序只能产生一个P\n    return p;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n但是全局函数是不安全的， 最好不要动不动就用全局的东西\n\n使用namespace来包裹一下这个全局函数， 会在使用的收， 增加对全局函数作用域的控制；\n\n“class拥有一个 static对象”的意思是：即使从未被用到，它也会被构造（及析构）。相反地“函数拥有一个 static 对象”的意思是：此对象在函数第一次被调用时才产生。如果该函数从未被调用，这个对象也就绝不会诞生（然而你必须付出代价，在函数每次被调用时检查对象是否需要诞生）\n\n\n# Item 27：要求（或禁止）对象产生于 heap之中\n\n手动限制或者禁止对象产生与heap之中， 把ctor和dtor， operator new()， operator new放在private里面，或者使用=delete\n\n（private不能继承， 但是可以弄成protected的，但是弄成protected就不知道是在heap上还是stack上面了）\n\nclass A\n{\npublic:\n    /* 做一个伪析构 */\n    void destory() { this->~A(); }\n\nprivate:\n    /* 析构函数设为私有，防止在栈上构建对象 */\n    ~A() { };\n};\n\nclass M\n{\n    // A a_; /* 错误，不可在堆上创建 */\n    A *pa_; /* 在内含类中，需要改为指针使用 */\n};\n\nint main(void)\n{\n    // A a; /* 错误 */\n    A *pa = new A(); /* 正确 */\n    // delete pa; /* 错误 */\n    pa->destory(); /* 正确 */\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n禁止在heap上产生对象， 要把operator new()， operator new以及相应的delete函数放在private里面；\n\n#include <iostream>\n\nclass A\n{\npublic:\n    /* 用c++11的方式 */\n    /*\n        static void *operator new(size_t) = delete;\n        static void operator delete(void *) = delete;\n        static void *operator new [](size_t) = delete;\n        static void operator delete [](void *) =delete;\n    */\nprivate:\n    static void *operator new(size_t);\n    static void operator delete(void *);\n    static void *operator new [](size_t);\n    static void operator delete [](void *);\n};\n\nint main(void)\n{\n    A a;\n    // A *pa = new A();   /* 错误 */\n    // A *pa = new A[10]; /* 错误 */\n    A *p = &a;\n    // delete p; /* 错误，delete已经被私有化，编译器就可以报错，delete []同原理 */\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# Item 28：Smart Pointers（智能指针）\n\nsmart pointer智能指针，在现代C++里面， 主要是auto_ptr(), shared_ptr()相关的类型， 可以使用；\n\n\n# Item 29：Reference counting（引用计数）\n\nreference counter引用技术 、 copy on write相关的技术\n\n（如何实现引用计数？）\n\n\n# Item 30：为什么要使用Proxy classes（替身类、代理类）\n\n代理类实际上有三种好处，\n\n * 实现多维数组： 真实数组为一个一维数组，内嵌代理为一个一维数组，组合起来就是一个二维数组\n * 区分读写\n * 压制隐式转换 因为返回的类型为代理类类型，所以很多操作需要隐式类型转换，如果代理类没实现，就不能进行隐式类型转换，这样可以有效的压制隐式类型转换\n\n\n# Item 31：如何让函数根据一个以上的对象类型来决定如何虚化\n\n让函数根据一个以上的对象类型来决定如何虚化这个函数；\n\n虚函数的调用其实也可以理解为一个message dispatch, 如果一个虚函数要根据两个参数的类型来进行虚化， 则称为 double dispatch,\n\n使用RTTI， typeid();\n\n',normalizedContent:'#\n\n\n# 技术（techniques, idioms, patterns）\n\n这部分内容更像是设计模式要解决的相关的问题；\n\n\n# item 25：将 constructor和 non-member functions虚化\n\nvirtual copy constructor 感觉和设计模式里面的工厂模式是差不多的概念\n\nnon-member function的虚化：写一个虚函数做实际工作，再写一个什么都不做的非虚函数，只负责调用虚函数。当然啦，为了避免这种操作受到函数调用所带来的成本，你可以将非虚函数 inline\n\n#include <iostream>\n\nclass a\n{\n    public:\n        virtual std::ostream &print(std::ostream &s) const = 0;\n};\n\nclass b: public a\n{\n    public:\n        virtual std::ostream &print(std::ostream &s) const { s << "i am b"; return s; };\n};\n\nclass c : public a\n{\n    public:\n        virtual std::ostream &print(std::ostream &s) const { s << "i am c"; return s; };\n};\n\nstd::ostream &operator <<(std::ostream &s, const a &a) // 这就是那个非虚函数，负责调用上面的虚函数\n{\n    return a.print(s);\n}\n\nint main(void)\n{\n    b b;\n    c c;\n    std::cout << b << "\\n" << c << std::endl;\n\n    return 0;\n}\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# item 26：限制某个 class所能产生的对象数量\n\n限制某个class所能产生的对象数量(如果只是一个， 那么用static对象， 记得看singleton设计模式)\n\n使用引用计数\n\n使用全局函数， 并且用private来封锁ctor和dtor，全局函数里面包裹一个static的对象， 只能产生一个：\n\nclass printer{\npublic:\n\tvoid submitjob(const printjob& job);\n    void reset();\n   \tvoid performselftest();\n    friend printer& theprinter();\n    ...\nprivate:\n    printer();\n    printer(const printer& rhs);\n    ...\n}\n\nprinter& theprinter(){\n    static printer p; // 这里限制了程序只能产生一个p\n    return p;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n但是全局函数是不安全的， 最好不要动不动就用全局的东西\n\n使用namespace来包裹一下这个全局函数， 会在使用的收， 增加对全局函数作用域的控制；\n\n“class拥有一个 static对象”的意思是：即使从未被用到，它也会被构造（及析构）。相反地“函数拥有一个 static 对象”的意思是：此对象在函数第一次被调用时才产生。如果该函数从未被调用，这个对象也就绝不会诞生（然而你必须付出代价，在函数每次被调用时检查对象是否需要诞生）\n\n\n# item 27：要求（或禁止）对象产生于 heap之中\n\n手动限制或者禁止对象产生与heap之中， 把ctor和dtor， operator new()， operator new放在private里面，或者使用=delete\n\n（private不能继承， 但是可以弄成protected的，但是弄成protected就不知道是在heap上还是stack上面了）\n\nclass a\n{\npublic:\n    /* 做一个伪析构 */\n    void destory() { this->~a(); }\n\nprivate:\n    /* 析构函数设为私有，防止在栈上构建对象 */\n    ~a() { };\n};\n\nclass m\n{\n    // a a_; /* 错误，不可在堆上创建 */\n    a *pa_; /* 在内含类中，需要改为指针使用 */\n};\n\nint main(void)\n{\n    // a a; /* 错误 */\n    a *pa = new a(); /* 正确 */\n    // delete pa; /* 错误 */\n    pa->destory(); /* 正确 */\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n禁止在heap上产生对象， 要把operator new()， operator new以及相应的delete函数放在private里面；\n\n#include <iostream>\n\nclass a\n{\npublic:\n    /* 用c++11的方式 */\n    /*\n        static void *operator new(size_t) = delete;\n        static void operator delete(void *) = delete;\n        static void *operator new [](size_t) = delete;\n        static void operator delete [](void *) =delete;\n    */\nprivate:\n    static void *operator new(size_t);\n    static void operator delete(void *);\n    static void *operator new [](size_t);\n    static void operator delete [](void *);\n};\n\nint main(void)\n{\n    a a;\n    // a *pa = new a();   /* 错误 */\n    // a *pa = new a[10]; /* 错误 */\n    a *p = &a;\n    // delete p; /* 错误，delete已经被私有化，编译器就可以报错，delete []同原理 */\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# item 28：smart pointers（智能指针）\n\nsmart pointer智能指针，在现代c++里面， 主要是auto_ptr(), shared_ptr()相关的类型， 可以使用；\n\n\n# item 29：reference counting（引用计数）\n\nreference counter引用技术 、 copy on write相关的技术\n\n（如何实现引用计数？）\n\n\n# item 30：为什么要使用proxy classes（替身类、代理类）\n\n代理类实际上有三种好处，\n\n * 实现多维数组： 真实数组为一个一维数组，内嵌代理为一个一维数组，组合起来就是一个二维数组\n * 区分读写\n * 压制隐式转换 因为返回的类型为代理类类型，所以很多操作需要隐式类型转换，如果代理类没实现，就不能进行隐式类型转换，这样可以有效的压制隐式类型转换\n\n\n# item 31：如何让函数根据一个以上的对象类型来决定如何虚化\n\n让函数根据一个以上的对象类型来决定如何虚化这个函数；\n\n虚函数的调用其实也可以理解为一个message dispatch, 如果一个虚函数要根据两个参数的类型来进行虚化， 则称为 double dispatch,\n\n使用rtti， typeid();\n\n',charsets:{cjk:!0}},{title:"杂项讨论，Misc",frontmatter:{title:"杂项讨论，Misc",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/pages/b3853a/"},regularPath:"/01.Wiki/19.Reading%20Notes/02.More%20Effective%20C++/06.%E6%9D%82%E9%A1%B9.html",relativePath:"01.Wiki/19.Reading Notes/02.More Effective C++/06.杂项.md",key:"v-3dcfaa6a",path:"/pages/b3853a/",headers:[{level:2,title:"杂项讨论，Misc",slug:"杂项讨论-misc",normalizedTitle:"杂项讨论，misc",charIndex:2},{level:3,title:"Item 32：在未来时态下发展程序",slug:"item-32-在未来时态下发展程序",normalizedTitle:"item 32：在未来时态下发展程序",charIndex:16},{level:3,title:"Item 33：将非尾端类（non leaf classes）设计为抽象类（abstract classes）",slug:"item-33-将非尾端类-non-leaf-classes-设计为抽象类-abstract-classes",normalizedTitle:"item 33：将非尾端类（non leaf classes）设计为抽象类（abstract classes）",charIndex:450},{level:3,title:"Item  34：如何在同一个程序中结合 C++和 C",slug:"item-34-如何在同一个程序中结合-c-和-c",normalizedTitle:"item  34：如何在同一个程序中结合 c++和 c",charIndex:null},{level:3,title:"Item  35：让自己习惯于标准 C++语言（多用一些C++的新特性）",slug:"item-35-让自己习惯于标准-c-语言-多用一些c-的新特性",normalizedTitle:"item  35：让自己习惯于标准 c++语言（多用一些c++的新特性）",charIndex:null}],headersStr:"杂项讨论，Misc Item 32：在未来时态下发展程序 Item 33：将非尾端类（non leaf classes）设计为抽象类（abstract classes） Item  34：如何在同一个程序中结合 C++和 C Item  35：让自己习惯于标准 C++语言（多用一些C++的新特性）",content:'# 杂项讨论，Misc\n\n\n# Item 32：在未来时态下发展程序\n\n在未来时态下发展程序， 为以后程序的变动留下足够的弹性设计空间；（设计模式和设计经验， 架构的经验）\n\n● 提供完整的 classes（见Item E18）——即使某些部分目前用不到。当新的需求进来，你不太需要回头去修改那些 classes。\n\n● 设计你的接口，使有利于共同的操作行为，阻止共同的错误（见Item E46）。让这些 classes 轻易地被正确运用，难以被错误运用。例如，面对那些“copying和 assignment 并不合理”的classes，请禁止那些动作的发生（见Item E27）。请防止部分赋值（partial assignments，见Item 33）的发生。\n\n● 尽量使你的代码一般化（泛化），除非有不良的巨大后果。举个例子，如果你正在写一个算法，用于树状结构（tree）的来回遍历，请考虑将它一般化，以便能够处理任何种类的 directed acyclic（非环状的）graph\n\n\n# Item 33：将非尾端类（non leaf classes）设计为抽象类（abstract classes）\n\n将non leaf class 设计为一个抽象类（最上层的类， 利于派生）\n\n\n# Item 34：如何在同一个程序中结合 C++和 C\n\n如何在同一个程序中结合C和C++\n\n#ifdef _cplusplus\nextern "C" {\n#endif\n\n[ C code ]\n    \n#ifdef _cplusplus\n}\n#endif\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nstatic class 对象、全局对象、namespace 内的对象以及文件范围（file scope）内的对象，其 constructors 总是在 main 之前就获得执行。这个过程称为 static initialization（见Item E47）\n\n\n# Item 35：让自己习惯于标准 C++语言（多用一些C++的新特性）\n\n让自己习惯于标准的C++的一些新特性，\n\n * 支持数值应用。复数（complex numbers）长久以来是许多 C++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。●\n * 支持广泛用途的 containers（容器）和 algorithms（算法）。C++标准程序库内含一组 class templates 和 function templates，统称为 Standard Template Library（STL）。STL 是 C++标准程序库中最具革命性的部分。稍后我会摘要说明其特征。\n * 支持数值应用。复数（complex numbers）长久以来是许多 C++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。\n * 支持广泛用途的 containers（容器）和 algorithms（算法）。C++标准程序库内含一组 class templates 和 function templates，统称为 Standard Template Library（STL）。STL 是 C++标准程序库中最具革命性的部分。稍后我会摘要说明其特征。\n * STL\n   * 支持 C标准函数库。别担心，C++还记得它的根源。某些微小的变化，使“C++版本的 C函数库”与“C++的强烈类型检验性质”得以一致。但是，你对 C函数库所知道的一切，以及对它的爱恨情仇，在 C++中都依然存在。\n   * 支持 strings。就像 C++标准程序库小组主席 Mike Vilot所说：“如果没有提供一个标准的 string 类型，恐怕会出现街头流血事件！”（有些人就是这么感情用事。）冷静点，放下那些砖头棍棒——C++标准程序库提供了 string。\n   * 支持国别（地域别、本土化，localization）。不同的文化使用不同的字符集，并在显示日期、时间、排序事物、货币值的时候有着不同的习俗。标准程序库对于国别的支持，使程序开发得以轻松容纳多种文化差异。\n   * 支持 I/O。iostream 程序库仍旧是标准 C++的一部分，但是委员会对它做了一些修补。虽然某些 classes 被剔除了（特别值得注意的是 iostream 和fstream），某些 classes 被取代了（例如 string-based stringstreams 取代了 char＊-based strstreams，后者不再被标准委员会认可），不过 iostream 内的各个标准 classes仍可忠实反映那些早已存在多年的基本功能。\n   * 支持数值应用。复数（complex numbers）长久以来是许多 C++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。\n   * 支持数值应用。复数（complex numbers）长久以来是许多 C++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。\n   * 支持广泛用途的 containers（容器）和 algorithms（算法）。C++标准程序库内含一组 class templates 和 function templates，统称为 Standard Template Library（STL）。STL 是 C++标准程序库中最具革命性的部分。稍后我会摘要说明其特征。\n\n推荐的阅读清单： 后面可以一起总结\n\n 1. 有一本书的基调和我的 Effective C++差不多，但涵盖主题不同：C++ Strategies and Tactics\n\n一个造轮子的repo： https://github.com/codecrafters-io/build-your-own-x\n\nshared_ptr() 代码\n\nauto_ptr() 代码',normalizedContent:'# 杂项讨论，misc\n\n\n# item 32：在未来时态下发展程序\n\n在未来时态下发展程序， 为以后程序的变动留下足够的弹性设计空间；（设计模式和设计经验， 架构的经验）\n\n● 提供完整的 classes（见item e18）——即使某些部分目前用不到。当新的需求进来，你不太需要回头去修改那些 classes。\n\n● 设计你的接口，使有利于共同的操作行为，阻止共同的错误（见item e46）。让这些 classes 轻易地被正确运用，难以被错误运用。例如，面对那些“copying和 assignment 并不合理”的classes，请禁止那些动作的发生（见item e27）。请防止部分赋值（partial assignments，见item 33）的发生。\n\n● 尽量使你的代码一般化（泛化），除非有不良的巨大后果。举个例子，如果你正在写一个算法，用于树状结构（tree）的来回遍历，请考虑将它一般化，以便能够处理任何种类的 directed acyclic（非环状的）graph\n\n\n# item 33：将非尾端类（non leaf classes）设计为抽象类（abstract classes）\n\n将non leaf class 设计为一个抽象类（最上层的类， 利于派生）\n\n\n# item 34：如何在同一个程序中结合 c++和 c\n\n如何在同一个程序中结合c和c++\n\n#ifdef _cplusplus\nextern "c" {\n#endif\n\n[ c code ]\n    \n#ifdef _cplusplus\n}\n#endif\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nstatic class 对象、全局对象、namespace 内的对象以及文件范围（file scope）内的对象，其 constructors 总是在 main 之前就获得执行。这个过程称为 static initialization（见item e47）\n\n\n# item 35：让自己习惯于标准 c++语言（多用一些c++的新特性）\n\n让自己习惯于标准的c++的一些新特性，\n\n * 支持数值应用。复数（complex numbers）长久以来是许多 c++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。●\n * 支持广泛用途的 containers（容器）和 algorithms（算法）。c++标准程序库内含一组 class templates 和 function templates，统称为 standard template library（stl）。stl 是 c++标准程序库中最具革命性的部分。稍后我会摘要说明其特征。\n * 支持数值应用。复数（complex numbers）长久以来是许多 c++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。\n * 支持广泛用途的 containers（容器）和 algorithms（算法）。c++标准程序库内含一组 class templates 和 function templates，统称为 standard template library（stl）。stl 是 c++标准程序库中最具革命性的部分。稍后我会摘要说明其特征。\n * stl\n   * 支持 c标准函数库。别担心，c++还记得它的根源。某些微小的变化，使“c++版本的 c函数库”与“c++的强烈类型检验性质”得以一致。但是，你对 c函数库所知道的一切，以及对它的爱恨情仇，在 c++中都依然存在。\n   * 支持 strings。就像 c++标准程序库小组主席 mike vilot所说：“如果没有提供一个标准的 string 类型，恐怕会出现街头流血事件！”（有些人就是这么感情用事。）冷静点，放下那些砖头棍棒——c++标准程序库提供了 string。\n   * 支持国别（地域别、本土化，localization）。不同的文化使用不同的字符集，并在显示日期、时间、排序事物、货币值的时候有着不同的习俗。标准程序库对于国别的支持，使程序开发得以轻松容纳多种文化差异。\n   * 支持 i/o。iostream 程序库仍旧是标准 c++的一部分，但是委员会对它做了一些修补。虽然某些 classes 被剔除了（特别值得注意的是 iostream 和fstream），某些 classes 被取代了（例如 string-based stringstreams 取代了 char＊-based strstreams，后者不再被标准委员会认可），不过 iostream 内的各个标准 classes仍可忠实反映那些早已存在多年的基本功能。\n   * 支持数值应用。复数（complex numbers）长久以来是许多 c++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。\n   * 支持数值应用。复数（complex numbers）长久以来是许多 c++教科书的示范对象，如今终于被奉祀于标准程序库的殿堂上。此外，标准程序库还包含特殊的数组类（valarrays），可以制止别名（aliasing）的发生。这些数组比传统的内建数组有更进取的优化倾向，特别是在多进程结构体系（multiprocessing architectures）下。标准程序库也提供一些常用的数值函数，包括“部分和（partial sum）”以及“相邻差值（adjacent difference）”。\n   * 支持广泛用途的 containers（容器）和 algorithms（算法）。c++标准程序库内含一组 class templates 和 function templates，统称为 standard template library（stl）。stl 是 c++标准程序库中最具革命性的部分。稍后我会摘要说明其特征。\n\n推荐的阅读清单： 后面可以一起总结\n\n 1. 有一本书的基调和我的 effective c++差不多，但涵盖主题不同：c++ strategies and tactics\n\n一个造轮子的repo： https://github.com/codecrafters-io/build-your-own-x\n\nshared_ptr() 代码\n\nauto_ptr() 代码',charsets:{cjk:!0}},{title:"《C++ 性能优化指南》",frontmatter:{pageClass:"diary",title:"《C++ 性能优化指南》",date:"2022-06-27T07:53:54.000Z",categories:["Reading"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},permalink:"/wiki/Reading_Notes/"},regularPath:"/01.Wiki/19.Reading%20Notes/03.C++%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97.html",relativePath:"01.Wiki/19.Reading Notes/03.C++性能优化指南.md",key:"v-76d7a407",path:"/wiki/Reading_Notes/",headers:[{level:2,title:"Optimized C++: proven techniques for heightened performance",slug:"optimized-c-proven-techniques-for-heightened-performance",normalizedTitle:"optimized c++: proven techniques for heightened performance",charIndex:2},{level:2,title:"CH1 基础策略",slug:"ch1-基础策略",normalizedTitle:"ch1 基础策略",charIndex:80},{level:2,title:"Ch2 影响计算机性能的行为",slug:"ch2-影响计算机性能的行为",normalizedTitle:"ch2 影响计算机性能的行为",charIndex:197},{level:2,title:"Ch3 性能测量",slug:"ch3-性能测量",normalizedTitle:"ch3 性能测量",charIndex:442},{level:2,title:"Ch4 字符串优化",slug:"ch4-字符串优化",normalizedTitle:"ch4 字符串优化",charIndex:774},{level:2,title:"Ch5 算法优化",slug:"ch5-算法优化",normalizedTitle:"ch5 算法优化",charIndex:788},{level:2,title:"ch6 动态分配内存的变量优化",slug:"ch6-动态分配内存的变量优化",normalizedTitle:"ch6 动态分配内存的变量优化",charIndex:801},{level:2,title:"ch7 热点语句的优化",slug:"ch7-热点语句的优化",normalizedTitle:"ch7 热点语句的优化",charIndex:821},{level:2,title:"ch8 使用更好的库",slug:"ch8-使用更好的库",normalizedTitle:"ch8 使用更好的库",charIndex:837},{level:2,title:"ch9 优化查找和排序",slug:"ch9-优化查找和排序",normalizedTitle:"ch9 优化查找和排序",charIndex:852},{level:2,title:"ch10 优化数据结构",slug:"ch10-优化数据结构",normalizedTitle:"ch10 优化数据结构",charIndex:868},{level:2,title:"ch11 优化IO",slug:"ch11-优化io",normalizedTitle:"ch11 优化io",charIndex:884},{level:2,title:"ch12 优化并发",slug:"ch12-优化并发",normalizedTitle:"ch12 优化并发",charIndex:898},{level:2,title:"ch13 优化内存管理",slug:"ch13-优化内存管理",normalizedTitle:"ch13 优化内存管理",charIndex:912}],headersStr:"Optimized C++: proven techniques for heightened performance CH1 基础策略 Ch2 影响计算机性能的行为 Ch3 性能测量 Ch4 字符串优化 Ch5 算法优化 ch6 动态分配内存的变量优化 ch7 热点语句的优化 ch8 使用更好的库 ch9 优化查找和排序 ch10 优化数据结构 ch11 优化IO ch12 优化并发 ch13 优化内存管理",content:"# Optimized C++: proven techniques for heightened performance\n\n《C++ 性能优化指南》\n\n\n# CH1 基础策略\n\n 1. 更好的编译器\n 2. 更好的算法\n 3. 更好的库\n 4. 减少内存分配和赋值\n 5. 减少计算密集部分\n 6. 更好的数据结构\n 7. 并发和并行处理;\n 8. 优化内存管理(更好的内存管理库)\n\n\n# Ch2 影响计算机性能的行为\n\n 1. 内存访问的代价是非常大的\n 2. cache miss\n 3. pipeline stall导致cycle被浪费\n 4. 线程切换, 同步的锁的开销,是非常大的;\n 5. 系统调用是昂贵的\n 6. 非对其的字节访问, 开销会很大, 会带来page threading 的效果;\n 7. 计算比分支判断的速度要快;\n 8. 所有的语句并非都是顺序执行.\\\n 9. 也不是所有指令的开销都是一样的, 每个指令所需要的cycle数量应该是不同的;\n\n\n# Ch3 性能测量\n\n 1.  时间测量(timer)是非常必要的\n 2.  CPU硬件profile测量也是有必要的\n 3.  使用profiler工具 找出热点代码\n 4.  90-10, 80-20方法\n 5.  性能优化其实是一种实验\n 6.  算法更优不代表其执行速度就会更快, 因为要考虑到实现时候的效率\n 7.  要有baseline, 要有实验记录, 要有随手记实验数据的习惯;\n 8.  测量延时, 测量吞吐, 测量batch\n 9.  linux上面, 如何进行profile, 原理是什么, 如何进行时间测量, 怎么样测量才会比较精确\n 10. 设置一些matrices, 根据这些指标来指导性能优化;\n 11. profile很重要\n\n\n# Ch4 字符串优化\n\n\n# Ch5 算法优化\n\n\n# ch6 动态分配内存的变量优化\n\n\n# ch7 热点语句的优化\n\n\n# ch8 使用更好的库\n\n\n# ch9 优化查找和排序\n\n\n# ch10 优化数据结构\n\n\n# ch11 优化IO\n\n\n# ch12 优化并发\n\n\n# ch13 优化内存管理",normalizedContent:"# optimized c++: proven techniques for heightened performance\n\n《c++ 性能优化指南》\n\n\n# ch1 基础策略\n\n 1. 更好的编译器\n 2. 更好的算法\n 3. 更好的库\n 4. 减少内存分配和赋值\n 5. 减少计算密集部分\n 6. 更好的数据结构\n 7. 并发和并行处理;\n 8. 优化内存管理(更好的内存管理库)\n\n\n# ch2 影响计算机性能的行为\n\n 1. 内存访问的代价是非常大的\n 2. cache miss\n 3. pipeline stall导致cycle被浪费\n 4. 线程切换, 同步的锁的开销,是非常大的;\n 5. 系统调用是昂贵的\n 6. 非对其的字节访问, 开销会很大, 会带来page threading 的效果;\n 7. 计算比分支判断的速度要快;\n 8. 所有的语句并非都是顺序执行.\\\n 9. 也不是所有指令的开销都是一样的, 每个指令所需要的cycle数量应该是不同的;\n\n\n# ch3 性能测量\n\n 1.  时间测量(timer)是非常必要的\n 2.  cpu硬件profile测量也是有必要的\n 3.  使用profiler工具 找出热点代码\n 4.  90-10, 80-20方法\n 5.  性能优化其实是一种实验\n 6.  算法更优不代表其执行速度就会更快, 因为要考虑到实现时候的效率\n 7.  要有baseline, 要有实验记录, 要有随手记实验数据的习惯;\n 8.  测量延时, 测量吞吐, 测量batch\n 9.  linux上面, 如何进行profile, 原理是什么, 如何进行时间测量, 怎么样测量才会比较精确\n 10. 设置一些matrices, 根据这些指标来指导性能优化;\n 11. profile很重要\n\n\n# ch4 字符串优化\n\n\n# ch5 算法优化\n\n\n# ch6 动态分配内存的变量优化\n\n\n# ch7 热点语句的优化\n\n\n# ch8 使用更好的库\n\n\n# ch9 优化查找和排序\n\n\n# ch10 优化数据结构\n\n\n# ch11 优化io\n\n\n# ch12 优化并发\n\n\n# ch13 优化内存管理",charsets:{cjk:!0},lastUpdated:"2023/06/18, 16:23:56",lastUpdatedTimestamp:1687076636e3},{title:"Archives",frontmatter:{archivesPage:!0,title:"Archives",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-04def3fa",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/30, 23:47:28",lastUpdatedTimestamp:1656604048e3},{title:"Category",frontmatter:{categoriesPage:!0,title:"Category",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-faf1db3a",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/07, 21:13:28",lastUpdatedTimestamp:1657199608e3},{title:"Tags",frontmatter:{tagsPage:!0,title:"Tags",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-b1c16cfa",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/30, 23:47:28",lastUpdatedTimestamp:1656604048e3},{title:"编程议题",frontmatter:{pageClass:"notes",title:"编程议题",date:"2022-05-18T01:43:24.000Z",permalink:"/pages/9b7dad/",categories:["Programming"],tags:[null],author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},sidebar:"auto"},regularPath:"/_posts/Notes/%E7%BC%96%E7%A8%8B%E8%AE%AE%E9%A2%98.html",relativePath:"_posts/Notes/编程议题.md",key:"v-cda71308",path:"/pages/9b7dad/",headersStr:null,content:" 1. 异步？同步？ 阻塞？ 非阻塞？ ==> benchmark\n 2. 进程？线程？协程？ 纤程？ ==> benchmark\n 3. OS系统调度， 性能工程相关的内容",normalizedContent:" 1. 异步？同步？ 阻塞？ 非阻塞？ ==> benchmark\n 2. 进程？线程？协程？ 纤程？ ==> benchmark\n 3. os系统调度， 性能工程相关的内容",charsets:{cjk:!0},lastUpdated:"2023/03/11, 03:13:10",lastUpdatedTimestamp:167847559e4},{title:"Why you have to write",frontmatter:{title:"Why you have to write",date:"2020-05-15T00:00:00.000Z",sidebar:!1,sticky:1,categories:["writing"],tags:["sayhi"],permalink:"/pages/cc9a5c/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/_posts/Writing/WhyYouHave2Write.html",relativePath:"_posts/Writing/WhyYouHave2Write.md",key:"v-1bf730e3",path:"/pages/cc9a5c/",excerpt:"<p>为什么你应该把脑子里面的东西写下来? 脑子里面会有一闪而过的一些很棒的想法?<br>\n为什么你想了那么多，却不能把自己的想法绑定成一个有意义的事物?<br>\n有些事情你真的想透了吗？为什么有些事情你总是想不透？</p>\n",headersStr:null,content:'为什么你应该把脑子里面的东西写下来? 脑子里面会有一闪而过的一些很棒的想法?\n为什么你想了那么多，却不能把自己的想法绑定成一个有意义的事物?\n有些事情你真的想透了吗？为什么有些事情你总是想不透？\n\n> If you learn to write and to edit, you will also be able to tell the difference between good ideas, intelligently presented, and bad ideas put forth by murky and unskilled thinkers. That means that you will be able to separate the wheat from the chaff (look it up). Then you can be properly influenced by profound and solid ideas instead of falling prey to foolish fads and whims and ideologies, which can range in their danger from trivial to mortal.\n> \n> Those who can think and communicate are simply more powerful than those who cannot, and powerful in the good way, the way that means “able to do a wide range of things competently and efficiently.” Furthermore, the further up the ladder of competence you climb, with your well-formulated thoughts, the more important thinking and communicating become. At the very top of the most complex hierarchies (law, medicine, academia, business, theology, politics) nothing is more necessary and valuable. If you can think and communicate, you can also defend yourself, and your friends and family, when that becomes necessary, and it will become necessary at various points in your life.\n> \n> Finally, it is useful to note that your mind is organized verbally, at the highest and most abstract levels. Thus, if you learn to think, through writing, then you will develop a well organized, efficient mind – and one that is well-founded and certain. This also means that you will be healthier, mentally and physically, as lack of clarity and ignorance means unnecessary stress. Unnecessary stress makes your body react more to what could otherwise be treated as trivial affairs. This makes for excess energy expenditure, and more rapid aging (along with all the negative health-related consequences of aging)\n> \n> -- Essay Writing Guide by Jordan B. Peterson\n\n\n\n自己关于写作的记忆, 最早的一件事情应该是小学三年级的时候, 那时候我的语文老师姓余, 也是我们的班主任, 三年级有一个期末考试, 期末考试的语文作文, 我拿了一个满分, 小学三年级语文期末考试, 也是第一次有作文出现的期末考试,在这之前的语文,就只有句子和字词的题目, 人生第一场语文期末考试, 作文拿了满分,与老师表扬了我, 我想我妈妈应该也是知道的, 当时并不觉得这有什么特别的含义, 只是觉得, 这是一个好的开始, 以及小孩子拿了第一名的那种喜悦.\n\n(我记得那个时候, 不记得是二年级还是三年级了, 但还是在小学老教学楼时候, 有一年好像语文数学的期末考试考得很好, 但是没有到双百,没有达成和爸妈的约定,所以也让爸妈给买一个什么东西, 具体约定的内容, 已经不记得是什么了)\n\n我们家以前是住在小县城的一个比较拐角的地方, 高一那年我们家从县城的南面靠山的地方, 搬到了县城比较靠中间的地方, 也就是说, 小学六年级和初中的绝大部分时间, 我们家都住在以前爷爷留下来的老房子里面, 房子是以前爷爷单位的员工宿舍， 后来由于单位破产, 改为私人拥有, 所以职工的宿舍也就便宜卖给了各家各户.\n\n我们初中那个时候, 其实郭敬明和韩寒的小说, 应该是最火的时候, 那时候有最小说, 最小说旗下是有不少新生代的作者, 有落落, 安东尼等等, 说到这里,大家可能会觉得我会说和他们之间产生了某种联系,\n\n其实不是, 很自然的时候,那个时候大家都是情窦初开, 多愁善感的年纪里面, 总是会莫名奇妙地产生很多很多情愫, 我真的不记得是六年级, 还是初中的时候, 想开始自己写点东西, 因为六年级和初中, 都是在旧房子里面度过的, 所以这一块的时间节点, 有点模糊了, 但是我猜想应该是初一或者是初二, 虽然那时候自己想写的还是类似于郑渊洁作品那样的现代童话, 但是有一些场景, 比如县城的大桥, 东方红广场之类的, 应该是初中时候比较常去的地方了.\n\n那时候就想自己写点东西, 希望能有自己的一些作品出来, 我想这里面很大一部分原因是那个时候其实初中生或者六年级学生, 并没有多少的课外消遣活动, 那个时候电脑其实也还不怎么普及,整个班上, 家里有电脑的同学其实也还是不多的, 即使有电脑, 但是网络上面的娱乐内容, 也没有现在这样泛滥. 那个时候, 像我这样, 家境一般, 父母又管的严的孩子, 其实唯一"合法", 又有资源的, 就是阅读了, 所以大家对与读物中的作者, 其实是有很多很多类似于现在追星的那种情感, 之所以我想写点东西, 更多可能是因为希望同龄人能够读到自己的东西, 想在同龄人里面脱颖而出. (大学之后, 基本上大家就开始崇拜学习好,成绩优秀,以及平时活动表现突出的这种典型了,好像阅读的人越来越少, 另外,追星的潮流也比之前更加涌动了).\n\n当时想写点东西, 还得是用笔去写, 电脑都不普及,更不用说是笔记本电脑了,我记得, 那个时候还缠着母亲在县城的超市,专门买了一本比较厚的本子, 母亲说很薄的本子就可以了, 当时不乐意, 最终还是缠着母亲买了很厚的一个本子, 回来准备写一个一众朋友结伴去探险的故事, 我想那个时候应该是读了很多淘气包马小跳， 皮皮鲁之类的故事， 所以特别想自己写一个， 把自己和要好的朋友带入进去， 一定是很酷的一件事情，\n\n很有意思的是， 在写作之前， 花了很多时间在纠结要选择身边哪些朋友和自己一起开始“我们的旅途”这件事情上面，带哪些朋友一起上路在这件事情上面成为了一个问题。\n\n小孩子身上， 我想最可贵的一些品质是持之以恒， 尤其是在心性的磨练上面，对于自己越做越痛苦， 或者不太愿意取做，但是知道是对的事情，训练自己的心性如何坚持下去， 是非常重要的， 而就在这件事情上面，我就表现得特别不能持之以恒， 写这个故事前后应该也没有坚持一个星期，最后也就不了了之了， 但是那个本子， 似乎很久之后都还有看到，现在不知道还在不在了， 希望有一天能够回去找到这个东西，拿出来翻一翻看一看， 这应该是自己关于写作最后一次回忆起来较为舒适的会议了。\n\n上了高中之后， 语文成绩极度不理想， 好像整个高中语文成绩及格的次数，应该是一双手能够数的出来的， 其实高一的时候身边很多同学都会觉得高中语文比初中语文难很多， 所以高一的时候大家语文成绩都会有一个明显的塌陷， 有的人适应得快， 有的人适应得很慢， 而我好像一直适应到了高三。\n\n高中语文对我很难， 一方面自己并没有什么意识，一方面也没有什么努力，一直到高考前夕，才进行有针对性地学习， 我记得高三已经到比较紧张的时候， 我们的语文老师在一次卷子点评上面，在批评同样班里语文最差劲的几位同学的时候，说就连我的作文都开始看得懂了， 不像以前那样一塌糊涂了，有进步了， 为什么他们几个还是不见起色呢。那个时刻， 我是以反面角色出现地比较多。\n\n再之后， 就没有之后了， 之后就是大学上的是理工科， 写的报告几乎都是固定的格式，流程， 所以大学时候很多的实验报告，有的是抄的，有的是组队参赛其他组员写的， 再之后就是本科毕业论文， 研究生发表论文， 研究生毕业论文。\n\n研究生需要发表论文才能够毕业， 那段时间开始用英文写作， 才发现自己其实根本没有逻辑， 其实我们中的大多数人， 写东西说话， 都十分缺乏逻辑。\n\n如果不相信， 你可以试一试， 找人以对方的标准改一改， 我想你会相信的。你不仅会相信自己没有逻辑，而且你会相信不同人之间的逻辑，差别大得惊人。\n\n研究生的时候， 我的导师有一个习惯，就是每次找他问问题， 都需要准备一个ppt，即使是两个人一对一地交谈， 也需要一个ppt， 我一开始其实是十分不理解，也十分厌烦的， 这中间没有少吐槽我的导师， 但是积累时间长了之后， 大概过了一年到两年之后， 我意识到了这么做的一个重大的好处是， 自己的内容输出的质量会越来越高，这其实和写程序在某些方面其实很像，都有一个迭代的过程， 一个程序如果上来就想得十分完美，其实是非常困难的，但是如果不考虑太完美， 从基本得功能做起， 每天改进一点， 假以时日，这个东西就会看上去比较不错了。 后来写论文的时候，很多的文字性的材料， 文献， 甚至包括大脑里面的之前总结的一些观点， 都是可以拿过来直接用的， 如果真的要让我那么短的时间里面， 总结凝练出什么特别好的观点， 其实也是不现实的。\n\n写作， 相当与把思考阶段性备份下来， 如果不备份， 那么容量有限， 再有更多好的想法就丢失了\n\n工作到现在已经一年四个月了，实际上手头的工作压力还是比较大的， 但是自己心里面关于写作, 总结, 凝练这些事情， 都还是记着的， 但是由于工作压力还是比较大的， 很多时间都花在周边的学习上面了， 懒惰的我迟迟没有动笔。\n\n我觉得现在有下面一些东西需要持续进行更新和总结的：\n\n * 高性能计算编程\n * 分布式系统\n * 网络编程\n * 编译器\n * 操作系统\n * Web系统搭建\n   * 前端\n   * 后端\n   * 数据库\n\n暂时有一些内容， 是希望能够长期更新， 并弄成一个系列文章或者手册教程， 或者项目实践的\n\n * 高性能计算， 理论与实践\n * 编译器中后端， 理论与实践\n * linux操作系统内核， 理论与实践\n * web系统（商城与宣传页）， 理论与实践，可视化分析\n * Quant与时间序列分析\n\n一些前沿一些的survey工作， 希望聚焦在：\n\n * AI sys / Distributed system / HPC\n * CV / NLP / Timeseries Analysis & Computing\n * Computational Social Science\n * 以及上面各个方向研究组的世界分布\n\n其余的内容， 希望关注认知科学， 心理学， 社会，政治， 经济和金融上面， 这些软科学其实更深层次地揭露了世界的运行规律， 所以更加需要了解， 这些可能就会作为笔记内容， 出现在博客生面了， 因为确实自己是一个小白， 需要从最基本的一些概念和知识入手。\n\n程序员和博客\n\n我觉得， 通过博客写作这件事情， 对程序员或者是其他相关的技术人员来说也是是很重要的， 但是为什么很多程序员没有开始自己的写作路途呢？ 我想这是很多方面的原因， 从大的方面到小的方面，都有很多原因，但是我想，对于程序员来说， 有一个很重要的原因是， 由于职业的属性他们在博客系统上面， 折腾了太多了， 相反你看看大牛的博客， 真正写起来的经营还不错并且有一定影响力的博客， 设计上面感觉都是上古画风。\n\n程序员自己可以从头到尾搭建一个web系统， 来打造自己的博客系统，但是实际上， 给别人用的技术， 和给自己用的平台，需要区分开， 不能够因为自己掌握了手机制造的所有技术， 就选择自己从头造一个iphone出来， 这是不划算的， 博客的核心思想， 应该是写作，归纳，展示， 要专注在内容上面， 反而如果博客系统弄得非常华丽， 内容又没有什么干货的话， 其实是非常典型的让人诟病的的一点。\n\n我想这一点，可能阻挡了将近1/3的人， 其他关于为什么想做而迟迟没做的理由， 可能需要另外开辟一个主题来讨论了。',normalizedContent:'为什么你应该把脑子里面的东西写下来? 脑子里面会有一闪而过的一些很棒的想法?\n为什么你想了那么多，却不能把自己的想法绑定成一个有意义的事物?\n有些事情你真的想透了吗？为什么有些事情你总是想不透？\n\n> if you learn to write and to edit, you will also be able to tell the difference between good ideas, intelligently presented, and bad ideas put forth by murky and unskilled thinkers. that means that you will be able to separate the wheat from the chaff (look it up). then you can be properly influenced by profound and solid ideas instead of falling prey to foolish fads and whims and ideologies, which can range in their danger from trivial to mortal.\n> \n> those who can think and communicate are simply more powerful than those who cannot, and powerful in the good way, the way that means “able to do a wide range of things competently and efficiently.” furthermore, the further up the ladder of competence you climb, with your well-formulated thoughts, the more important thinking and communicating become. at the very top of the most complex hierarchies (law, medicine, academia, business, theology, politics) nothing is more necessary and valuable. if you can think and communicate, you can also defend yourself, and your friends and family, when that becomes necessary, and it will become necessary at various points in your life.\n> \n> finally, it is useful to note that your mind is organized verbally, at the highest and most abstract levels. thus, if you learn to think, through writing, then you will develop a well organized, efficient mind – and one that is well-founded and certain. this also means that you will be healthier, mentally and physically, as lack of clarity and ignorance means unnecessary stress. unnecessary stress makes your body react more to what could otherwise be treated as trivial affairs. this makes for excess energy expenditure, and more rapid aging (along with all the negative health-related consequences of aging)\n> \n> -- essay writing guide by jordan b. peterson\n\n\n\n自己关于写作的记忆, 最早的一件事情应该是小学三年级的时候, 那时候我的语文老师姓余, 也是我们的班主任, 三年级有一个期末考试, 期末考试的语文作文, 我拿了一个满分, 小学三年级语文期末考试, 也是第一次有作文出现的期末考试,在这之前的语文,就只有句子和字词的题目, 人生第一场语文期末考试, 作文拿了满分,与老师表扬了我, 我想我妈妈应该也是知道的, 当时并不觉得这有什么特别的含义, 只是觉得, 这是一个好的开始, 以及小孩子拿了第一名的那种喜悦.\n\n(我记得那个时候, 不记得是二年级还是三年级了, 但还是在小学老教学楼时候, 有一年好像语文数学的期末考试考得很好, 但是没有到双百,没有达成和爸妈的约定,所以也让爸妈给买一个什么东西, 具体约定的内容, 已经不记得是什么了)\n\n我们家以前是住在小县城的一个比较拐角的地方, 高一那年我们家从县城的南面靠山的地方, 搬到了县城比较靠中间的地方, 也就是说, 小学六年级和初中的绝大部分时间, 我们家都住在以前爷爷留下来的老房子里面, 房子是以前爷爷单位的员工宿舍， 后来由于单位破产, 改为私人拥有, 所以职工的宿舍也就便宜卖给了各家各户.\n\n我们初中那个时候, 其实郭敬明和韩寒的小说, 应该是最火的时候, 那时候有最小说, 最小说旗下是有不少新生代的作者, 有落落, 安东尼等等, 说到这里,大家可能会觉得我会说和他们之间产生了某种联系,\n\n其实不是, 很自然的时候,那个时候大家都是情窦初开, 多愁善感的年纪里面, 总是会莫名奇妙地产生很多很多情愫, 我真的不记得是六年级, 还是初中的时候, 想开始自己写点东西, 因为六年级和初中, 都是在旧房子里面度过的, 所以这一块的时间节点, 有点模糊了, 但是我猜想应该是初一或者是初二, 虽然那时候自己想写的还是类似于郑渊洁作品那样的现代童话, 但是有一些场景, 比如县城的大桥, 东方红广场之类的, 应该是初中时候比较常去的地方了.\n\n那时候就想自己写点东西, 希望能有自己的一些作品出来, 我想这里面很大一部分原因是那个时候其实初中生或者六年级学生, 并没有多少的课外消遣活动, 那个时候电脑其实也还不怎么普及,整个班上, 家里有电脑的同学其实也还是不多的, 即使有电脑, 但是网络上面的娱乐内容, 也没有现在这样泛滥. 那个时候, 像我这样, 家境一般, 父母又管的严的孩子, 其实唯一"合法", 又有资源的, 就是阅读了, 所以大家对与读物中的作者, 其实是有很多很多类似于现在追星的那种情感, 之所以我想写点东西, 更多可能是因为希望同龄人能够读到自己的东西, 想在同龄人里面脱颖而出. (大学之后, 基本上大家就开始崇拜学习好,成绩优秀,以及平时活动表现突出的这种典型了,好像阅读的人越来越少, 另外,追星的潮流也比之前更加涌动了).\n\n当时想写点东西, 还得是用笔去写, 电脑都不普及,更不用说是笔记本电脑了,我记得, 那个时候还缠着母亲在县城的超市,专门买了一本比较厚的本子, 母亲说很薄的本子就可以了, 当时不乐意, 最终还是缠着母亲买了很厚的一个本子, 回来准备写一个一众朋友结伴去探险的故事, 我想那个时候应该是读了很多淘气包马小跳， 皮皮鲁之类的故事， 所以特别想自己写一个， 把自己和要好的朋友带入进去， 一定是很酷的一件事情，\n\n很有意思的是， 在写作之前， 花了很多时间在纠结要选择身边哪些朋友和自己一起开始“我们的旅途”这件事情上面，带哪些朋友一起上路在这件事情上面成为了一个问题。\n\n小孩子身上， 我想最可贵的一些品质是持之以恒， 尤其是在心性的磨练上面，对于自己越做越痛苦， 或者不太愿意取做，但是知道是对的事情，训练自己的心性如何坚持下去， 是非常重要的， 而就在这件事情上面，我就表现得特别不能持之以恒， 写这个故事前后应该也没有坚持一个星期，最后也就不了了之了， 但是那个本子， 似乎很久之后都还有看到，现在不知道还在不在了， 希望有一天能够回去找到这个东西，拿出来翻一翻看一看， 这应该是自己关于写作最后一次回忆起来较为舒适的会议了。\n\n上了高中之后， 语文成绩极度不理想， 好像整个高中语文成绩及格的次数，应该是一双手能够数的出来的， 其实高一的时候身边很多同学都会觉得高中语文比初中语文难很多， 所以高一的时候大家语文成绩都会有一个明显的塌陷， 有的人适应得快， 有的人适应得很慢， 而我好像一直适应到了高三。\n\n高中语文对我很难， 一方面自己并没有什么意识，一方面也没有什么努力，一直到高考前夕，才进行有针对性地学习， 我记得高三已经到比较紧张的时候， 我们的语文老师在一次卷子点评上面，在批评同样班里语文最差劲的几位同学的时候，说就连我的作文都开始看得懂了， 不像以前那样一塌糊涂了，有进步了， 为什么他们几个还是不见起色呢。那个时刻， 我是以反面角色出现地比较多。\n\n再之后， 就没有之后了， 之后就是大学上的是理工科， 写的报告几乎都是固定的格式，流程， 所以大学时候很多的实验报告，有的是抄的，有的是组队参赛其他组员写的， 再之后就是本科毕业论文， 研究生发表论文， 研究生毕业论文。\n\n研究生需要发表论文才能够毕业， 那段时间开始用英文写作， 才发现自己其实根本没有逻辑， 其实我们中的大多数人， 写东西说话， 都十分缺乏逻辑。\n\n如果不相信， 你可以试一试， 找人以对方的标准改一改， 我想你会相信的。你不仅会相信自己没有逻辑，而且你会相信不同人之间的逻辑，差别大得惊人。\n\n研究生的时候， 我的导师有一个习惯，就是每次找他问问题， 都需要准备一个ppt，即使是两个人一对一地交谈， 也需要一个ppt， 我一开始其实是十分不理解，也十分厌烦的， 这中间没有少吐槽我的导师， 但是积累时间长了之后， 大概过了一年到两年之后， 我意识到了这么做的一个重大的好处是， 自己的内容输出的质量会越来越高，这其实和写程序在某些方面其实很像，都有一个迭代的过程， 一个程序如果上来就想得十分完美，其实是非常困难的，但是如果不考虑太完美， 从基本得功能做起， 每天改进一点， 假以时日，这个东西就会看上去比较不错了。 后来写论文的时候，很多的文字性的材料， 文献， 甚至包括大脑里面的之前总结的一些观点， 都是可以拿过来直接用的， 如果真的要让我那么短的时间里面， 总结凝练出什么特别好的观点， 其实也是不现实的。\n\n写作， 相当与把思考阶段性备份下来， 如果不备份， 那么容量有限， 再有更多好的想法就丢失了\n\n工作到现在已经一年四个月了，实际上手头的工作压力还是比较大的， 但是自己心里面关于写作, 总结, 凝练这些事情， 都还是记着的， 但是由于工作压力还是比较大的， 很多时间都花在周边的学习上面了， 懒惰的我迟迟没有动笔。\n\n我觉得现在有下面一些东西需要持续进行更新和总结的：\n\n * 高性能计算编程\n * 分布式系统\n * 网络编程\n * 编译器\n * 操作系统\n * web系统搭建\n   * 前端\n   * 后端\n   * 数据库\n\n暂时有一些内容， 是希望能够长期更新， 并弄成一个系列文章或者手册教程， 或者项目实践的\n\n * 高性能计算， 理论与实践\n * 编译器中后端， 理论与实践\n * linux操作系统内核， 理论与实践\n * web系统（商城与宣传页）， 理论与实践，可视化分析\n * quant与时间序列分析\n\n一些前沿一些的survey工作， 希望聚焦在：\n\n * ai sys / distributed system / hpc\n * cv / nlp / timeseries analysis & computing\n * computational social science\n * 以及上面各个方向研究组的世界分布\n\n其余的内容， 希望关注认知科学， 心理学， 社会，政治， 经济和金融上面， 这些软科学其实更深层次地揭露了世界的运行规律， 所以更加需要了解， 这些可能就会作为笔记内容， 出现在博客生面了， 因为确实自己是一个小白， 需要从最基本的一些概念和知识入手。\n\n程序员和博客\n\n我觉得， 通过博客写作这件事情， 对程序员或者是其他相关的技术人员来说也是是很重要的， 但是为什么很多程序员没有开始自己的写作路途呢？ 我想这是很多方面的原因， 从大的方面到小的方面，都有很多原因，但是我想，对于程序员来说， 有一个很重要的原因是， 由于职业的属性他们在博客系统上面， 折腾了太多了， 相反你看看大牛的博客， 真正写起来的经营还不错并且有一定影响力的博客， 设计上面感觉都是上古画风。\n\n程序员自己可以从头到尾搭建一个web系统， 来打造自己的博客系统，但是实际上， 给别人用的技术， 和给自己用的平台，需要区分开， 不能够因为自己掌握了手机制造的所有技术， 就选择自己从头造一个iphone出来， 这是不划算的， 博客的核心思想， 应该是写作，归纳，展示， 要专注在内容上面， 反而如果博客系统弄得非常华丽， 内容又没有什么干货的话， 其实是非常典型的让人诟病的的一点。\n\n我想这一点，可能阻挡了将近1/3的人， 其他关于为什么想做而迟迟没做的理由， 可能需要另外开辟一个主题来讨论了。',charsets:{cjk:!0},lastUpdated:"2022/07/18, 01:15:26",lastUpdatedTimestamp:1658078126e3},{title:"时间的力量--惯性以及大尺度的延迟",frontmatter:{title:"时间的力量--惯性以及大尺度的延迟",date:"2021-08-05T00:00:00.000Z",sidebar:!1,categories:["writing"],tags:["sayhi"],permalink:"/pages/dcdff1/",author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}},regularPath:"/_posts/Writing/thePowerOfTime.html",relativePath:"_posts/Writing/thePowerOfTime.md",key:"v-f6245f3a",path:"/pages/dcdff1/",headers:[{level:4,title:"一件坏的事情发生，往往都是一点一点慢慢变坏的",slug:"一件坏的事情发生-往往都是一点一点慢慢变坏的",normalizedTitle:"一件坏的事情发生，往往都是一点一点慢慢变坏的",charIndex:2},{level:3,title:"你知道的越多， 不知道的也就越多",slug:"你知道的越多-不知道的也就越多",normalizedTitle:"你知道的越多， 不知道的也就越多",charIndex:311},{level:3,title:"拥抱生活， 拥抱快乐",slug:"拥抱生活-拥抱快乐",normalizedTitle:"拥抱生活， 拥抱快乐",charIndex:664}],excerpt:'<h4 id="一件坏的事情发生-往往都是一点一点慢慢变坏的"><a class="header-anchor" href="#一件坏的事情发生-往往都是一点一点慢慢变坏的">#</a> <strong>一件坏的事情发生，往往都是一点一点慢慢变坏的</strong></h4>\n',headersStr:"一件坏的事情发生，往往都是一点一点慢慢变坏的 你知道的越多， 不知道的也就越多 拥抱生活， 拥抱快乐",content:"# 一件坏的事情发生，往往都是一点一点慢慢变坏的\n\n可能是随着年龄变大，也有可能是自己solo的时间过长，其实你是能够感觉到时间的力量的，比如说一件坏的事情发生，往往都是一点一点慢慢变坏的，这中间有对自己的纵容，有对自己时间的纵容，有对自己情绪的纵容，但终归这种纵容，会带来坏的结果\n\n但是你又急不得改正，因为即使去改正，也不会立马有什么效果，现实中，当你想纠正错误的时候，不会立即蹦出来一个机会让你验证，你已经改正了，\n\n而且，当过了许久机会来了的时候，往往自己又已经忘了上次的教训\n\n当你知道生命没有意义的时候， 生命要如何继续下去？生命的意义是一团熊熊燃烧的欲望。真的是形而上的吗？真的全部都是理性主义吗？\n\n\n# 你知道的越多， 不知道的也就越多\n\n不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n\n# 拥抱生活， 拥抱快乐\n\n> 当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n> \n> 不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n> \n> 所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n> \n> 如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n> \n> 所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n> \n> 摘录自:B站视频《罗翔说刑法》，链接https://b23.tv/K8ulrE",normalizedContent:"# 一件坏的事情发生，往往都是一点一点慢慢变坏的\n\n可能是随着年龄变大，也有可能是自己solo的时间过长，其实你是能够感觉到时间的力量的，比如说一件坏的事情发生，往往都是一点一点慢慢变坏的，这中间有对自己的纵容，有对自己时间的纵容，有对自己情绪的纵容，但终归这种纵容，会带来坏的结果\n\n但是你又急不得改正，因为即使去改正，也不会立马有什么效果，现实中，当你想纠正错误的时候，不会立即蹦出来一个机会让你验证，你已经改正了，\n\n而且，当过了许久机会来了的时候，往往自己又已经忘了上次的教训\n\n当你知道生命没有意义的时候， 生命要如何继续下去？生命的意义是一团熊熊燃烧的欲望。真的是形而上的吗？真的全部都是理性主义吗？\n\n\n# 你知道的越多， 不知道的也就越多\n\n不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n\n# 拥抱生活， 拥抱快乐\n\n> 当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n> \n> 不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n> \n> 所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n> \n> 如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n> \n> 所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n> \n> 摘录自:b站视频《罗翔说刑法》，链接https://b23.tv/k8ulre",charsets:{cjk:!0},lastUpdated:"2023/03/11, 02:29:02",lastUpdatedTimestamp:1678472942e3},{title:"Home",frontmatter:{home:!0},regularPath:"/",relativePath:"index.md",key:"v-e5b4aac8",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/11, 02:20:56",lastUpdatedTimestamp:1678472456e3}],themeConfig:{nav:[{text:"Home",link:"/"},{text:"Wiki",link:"/wiki/",items:[{text:"Program",items:[{text:"Lean in C++",link:"/wiki/lean_in_c++/"}]},{text:"Perfromance Engineering",items:[{text:"[>>>>>]",link:"/wiki/Performance_Engineering/"}]},{text:"Reading Note",items:[{text:"[>>>>>]",link:"/wiki/Reading_Notes/"}]},{text:"ComputeArch",items:[{text:"[_]"}]},{text:"Compiler",items:[{text:"[_]"}]},{text:"System",items:[{text:"[_]"}]}]},{text:"Authoring",link:"/authoring/"},{text:"Archives",link:"/archives/",items:[{text:"Categories",link:"/categories/"},{text:"Tags",link:"/tags/"}]}],sidebar:{"/00.NavBar/":[["01.Wiki.md","Wiki","/wiki/"],["02.Authoring.md","Authoring","/authoring/"]],catalogue:{Wiki:"/wiki/",Authoring:"/authoring/"},"/01.Wiki/":[{title:"Lean in c++",collapsable:!0,children:[["01.Lean in c++/00.ReadMe.md","Lean in C++","/wiki/lean_in_c++/"],{title:"Phase_0:Glimpse",collapsable:!0,children:[["01.Lean in c++/01.Phase_0:Glimpse/00.C++ Glimpse.md","C++ Glimpse","/pages/8744f7/"],["01.Lean in c++/01.Phase_0:Glimpse/01.type cast.md","type cast","/pages/409de3/"],["01.Lean in c++/01.Phase_0:Glimpse/02.typedef.md","typedef","/pages/ab4daf/"],["01.Lean in c++/01.Phase_0:Glimpse/03.typename vs class.md","class vs. typename","/pages/2b0a8f/"],["01.Lean in c++/01.Phase_0:Glimpse/04.const.md","const","/pages/b9de04/"],["01.Lean in c++/01.Phase_0:Glimpse/05.extern.md","extern","/pages/5bac8e/"],["01.Lean in c++/01.Phase_0:Glimpse/06.pointer.md","pointer","/pages/c08a6e/"],["01.Lean in c++/01.Phase_0:Glimpse/07.static.md","static","/pages/9b131d/"],["01.Lean in c++/01.Phase_0:Glimpse/08.volatile.md","volatile","/pages/598385/"],["01.Lean in c++/01.Phase_0:Glimpse/09.inline.md","inline","/pages/91242f/"],["01.Lean in c++/01.Phase_0:Glimpse/10.assert.md","assert","/pages/efbaf4/"],["01.Lean in c++/01.Phase_0:Glimpse/11.void.md","void","/pages/b4d0b6/"],["01.Lean in c++/01.Phase_0:Glimpse/12.__global__.md","__global__","/pages/fc5419/"]]}]},{title:"Performance Engineering",collapsable:!0,children:[["02.Performance Engineering/01.Perf.md","Comming soon","/wiki/Performance_Engineering/"]]},{title:"Misc",collapsable:!0,children:[["10.Misc/01.Chrome.md","Chrome 非常规操作","/pages/41a6c9/"],["10.Misc/02.VsCode.md","VsCode 常用插件","/pages/6f0fa2/"]]},{title:"Reading Notes",collapsable:!0,children:[{title:"Effective C++",collapsable:!0,children:[["19.Reading Notes/01.Effective C++/01.习惯C++.md","习惯C++","/pages/f9e729/"],["19.Reading Notes/01.Effective C++/02.构造_析构_运算符重载.md","构造，析构， 和重载赋值运算符","/pages/0d9870/"],["19.Reading Notes/01.Effective C++/03.资源管理.md","资源管理","/pages/ad8b8b/"],["19.Reading Notes/01.Effective C++/04.设计与声明.md","设计与声明","/pages/e85768/"],["19.Reading Notes/01.Effective C++/05.实现.md","实现Implementations","/pages/fb96c7/"],["19.Reading Notes/01.Effective C++/06.继承与OOP.md","继承与OOP","/pages/81fe36/"],["19.Reading Notes/01.Effective C++/07.模板.md","模板，Templates and GP","/pages/61c62c/"],["19.Reading Notes/01.Effective C++/08.定制new和delete.md","定制new和delete","/pages/875a85/"],["19.Reading Notes/01.Effective C++/09.杂项_Misc.md","杂项, Misc","/pages/589042/"]]},{title:"More Effective C++",collapsable:!0,children:[["19.Reading Notes/02.More Effective C++/01.基础议题.md","基础议题","/pages/ce94a9/"],["19.Reading Notes/02.More Effective C++/02.操作符.md","操作符（operators）","/pages/225e98/"],["19.Reading Notes/02.More Effective C++/03.异常.md","异常（exceptions）","/pages/3e106f/"],["19.Reading Notes/02.More Effective C++/04.性能.md","效率（efficiency）","/pages/24653b/"],["19.Reading Notes/02.More Effective C++/05.技术.md","技术（techniques, idioms, patterns）","/pages/b26674/"],["19.Reading Notes/02.More Effective C++/06.杂项.md","杂项讨论，Misc","/pages/b3853a/"]]},["19.Reading Notes/03.C++性能优化指南.md","《C++ 性能优化指南》","/wiki/Reading_Notes/"]]}]},sidebarDepth:2,repo:"Quincy-J",searchMaxSuggestions:10,lastUpdated:"Last updated",docsDir:"docs",editLinks:!1,editLinkText:"Edit",pageStyle:"line",defaultMode:"read",bodyBgImg:["https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200507175846.jpeg"],bodyBgImgOpacity:.6,updateBar:{showToArticle:!1,moreArticle:"/archives"},author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"},blogger:{avatar:"/img/github_profile_2_1.jpg",name:"Quincy Jet",slogan:"We are."},social:{icons:[{iconClass:"icon-youjian",title:"E-Mail",link:"mailto:quincy_jet@outlook.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/Quincy-J"}]},footer:{createYear:2017,copyrightInfo:'Quincy Jet | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a>'},extendFrontmatter:{author:{name:"Quincy Jet",link:"https://github.com/Quincy-J"}}},locales:{"/":{lang:"en-US",title:"1ms Faster",description:"Software performace profile/analysis/optimization",path:"/"}}};var Xs=t(92),nc=t(93),ec=t(11);var tc={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:i}}=n;return!(e||!1===t||!0===i)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,i=e.frontmatter.sticky;return t&&i?t==i?Object(ec.a)(n,e):t-i:t&&!i?-1:!t&&i?1:Object(ec.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(ec.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let i=0,r=n.length;i<r;i++){const{frontmatter:{categories:r,tags:a}}=n[i];"array"===Object(ec.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[i]))}),"array"===Object(ec.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[i]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Ar.component(Xs.default),Ar.component(nc.default);function ic(n){return n.toString().padStart(2,"0")}t(235);Ar.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,92))),Ar.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,93))),Ar.component("Badge",()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,367)));t(236);var rc=[({Vue:n,options:e,router:t,siteData:i})=>{},({Vue:n,options:e,router:t,siteData:i})=>{i.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${ic(n.getUTCMonth()+1)}-${ic(n.getUTCDate())} ${ic(n.getUTCHours())}:${ic(n.getUTCMinutes())}:${ic(n.getUTCSeconds())}`}(e)),t?n.author=t:i.themeConfig.author&&(n.author=i.themeConfig.author)}),n.mixin(tc)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],ac=[];class oc extends class{constructor(){this.store=new Ar({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Ar.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(oc.prototype,{getPageAsyncComponent:No,getLayoutAsyncComponent:Do,getAsyncComponent:Bo,getVueComponent:Wo});var sc={install(n){const e=new oc;n.$vuepress=e,n.prototype.$vuepress=e}};function cc(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var lc={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return Fo("pageKey",e),Ar.component(e)||Ar.component(e,No(e)),Ar.component(e)?n(e):n("")}},uc={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},pc={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},dc=(t(237),t(238),Object(Ys.a)(pc,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),fc={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Ar.config.productionTip=!1,Ar.use(Co),Ar.use(sc),Ar.mixin(function(n,e,t=Ar){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const i=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),a={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const i in n)"/"===i?t=n[i]:0===this.$page.path.indexOf(i)&&(e=n[i]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,i=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?i?i+" | "+t:t:i||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const i=n[t];if(i.path.toLowerCase()===e.toLowerCase())return i}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},Zs)),Ar.component("Content",lc),Ar.component("ContentSlotsDistributor",uc),Ar.component("OutboundLink",dc),Ar.component("ClientOnly",fc),Ar.component("Layout",Do("Layout")),Ar.component("NotFound",Do("NotFound")),Ar.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"f0aa619"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Zs.routerBase||Zs.base,t=new Co({base:e,mode:"history",fallback:!1,routes:Ks,scrollBehavior:(n,e,t)=>t||(n.hash?!Ar.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,i)=>{if(cc(n,e.path))i();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";cc(n,t)?i(t):i()}else i();else{const t=e.path+"/",r=e.path+".html";cc(n,r)?i(r):cc(n,t)?i(t):i()}})}(t);const i={};try{await Promise.all(rc.filter(n=>"function"==typeof n).map(e=>e({Vue:Ar,options:i,router:t,siteData:Zs,isServer:n})))}catch(n){console.error(n)}return{app:new Ar(Object.assign(i,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},ac.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);