<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《Effective C++》 | 1ms Faster</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/more.png">
    <meta name="description" content="Software performace profile/analysis/optimization">
    <meta name="keywords" content="optimization, analysis, profile, performance, latency, throughput, metrics, linux, cache, CPU, architecture">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.e5fe63c7.css" as="style"><link rel="preload" href="/assets/js/app.d9e23042.js" as="script"><link rel="preload" href="/assets/js/2.0eed2333.js" as="script"><link rel="preload" href="/assets/js/3.1c18827c.js" as="script"><link rel="preload" href="/assets/js/25.d9836ed1.js" as="script"><link rel="prefetch" href="/assets/js/10.20339081.js"><link rel="prefetch" href="/assets/js/11.9e667a20.js"><link rel="prefetch" href="/assets/js/12.e10ed919.js"><link rel="prefetch" href="/assets/js/13.5b153336.js"><link rel="prefetch" href="/assets/js/14.c9818bab.js"><link rel="prefetch" href="/assets/js/15.e1d4e55a.js"><link rel="prefetch" href="/assets/js/16.b5733294.js"><link rel="prefetch" href="/assets/js/17.080af967.js"><link rel="prefetch" href="/assets/js/18.33384b3a.js"><link rel="prefetch" href="/assets/js/19.e79925d2.js"><link rel="prefetch" href="/assets/js/20.8bcfd87e.js"><link rel="prefetch" href="/assets/js/21.44ef1fb7.js"><link rel="prefetch" href="/assets/js/22.4a720245.js"><link rel="prefetch" href="/assets/js/23.65bc160b.js"><link rel="prefetch" href="/assets/js/24.c1071b43.js"><link rel="prefetch" href="/assets/js/26.1b0e28dd.js"><link rel="prefetch" href="/assets/js/27.2352de48.js"><link rel="prefetch" href="/assets/js/28.727c4028.js"><link rel="prefetch" href="/assets/js/29.e4acda9d.js"><link rel="prefetch" href="/assets/js/30.fba95149.js"><link rel="prefetch" href="/assets/js/31.d0f1a75b.js"><link rel="prefetch" href="/assets/js/32.d67d090d.js"><link rel="prefetch" href="/assets/js/33.ab0cea95.js"><link rel="prefetch" href="/assets/js/34.aaf5074b.js"><link rel="prefetch" href="/assets/js/4.5c1dc4ce.js"><link rel="prefetch" href="/assets/js/5.d89070b9.js"><link rel="prefetch" href="/assets/js/6.1e60fa96.js"><link rel="prefetch" href="/assets/js/7.77c61ade.js"><link rel="prefetch" href="/assets/js/8.9251176b.js"><link rel="prefetch" href="/assets/js/9.77bda456.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e5fe63c7.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">1ms Faster</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Wiki" class="dropdown-title"><a href="/wiki/" class="link-title">Wiki</a> <span class="title" style="display:none;">Wiki</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Program</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/lean_in_c++/" class="nav-link">Lean in C++</a></li></ul></li><li class="dropdown-item"><h4>Perfromance Engineering</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/Performance_Engineering/" class="nav-link">[&gt;&gt;&gt;&gt;&gt;]</a></li></ul></li><li class="dropdown-item"><h4>Reading Note</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/Reading_Notes/" class="nav-link">[&gt;&gt;&gt;&gt;&gt;]</a></li></ul></li><li class="dropdown-item"><h4>ComputeArch</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/293b84/404" class="nav-link">[_]</a></li></ul></li><li class="dropdown-item"><h4>Compiler</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/293b84/404" class="nav-link">[_]</a></li></ul></li><li class="dropdown-item"><h4>System</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/293b84/404" class="nav-link">[_]</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/authoring/" class="nav-link">Authoring</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Archives" class="dropdown-title"><a href="/archives/" class="link-title">Archives</a> <span class="title" style="display:none;">Archives</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">Categories</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">Tags</a></li></ul></div></div> <a href="https://github.com/Quincy-J" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/github_profile_2_1.jpg"> <div class="blogger-info"><h3>Quincy Jet</h3> <span>We are.</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Wiki" class="dropdown-title"><a href="/wiki/" class="link-title">Wiki</a> <span class="title" style="display:none;">Wiki</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Program</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/lean_in_c++/" class="nav-link">Lean in C++</a></li></ul></li><li class="dropdown-item"><h4>Perfromance Engineering</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/Performance_Engineering/" class="nav-link">[&gt;&gt;&gt;&gt;&gt;]</a></li></ul></li><li class="dropdown-item"><h4>Reading Note</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/Reading_Notes/" class="nav-link">[&gt;&gt;&gt;&gt;&gt;]</a></li></ul></li><li class="dropdown-item"><h4>ComputeArch</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/293b84/404" class="nav-link">[_]</a></li></ul></li><li class="dropdown-item"><h4>Compiler</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/293b84/404" class="nav-link">[_]</a></li></ul></li><li class="dropdown-item"><h4>System</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/293b84/404" class="nav-link">[_]</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/authoring/" class="nav-link">Authoring</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Archives" class="dropdown-title"><a href="/archives/" class="link-title">Archives</a> <span class="title" style="display:none;">Archives</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">Categories</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">Tags</a></li></ul></div></div> <a href="https://github.com/Quincy-J" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Lean in c++</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Performance Engineering</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Misc</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Reading Notes</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/293b84/" aria-current="page" class="active sidebar-link">《Effective C++》</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/293b84/#习惯c" class="sidebar-link">习惯C++</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item01-view-c-as-a-federation-of-languages-视c-为一个语言联邦" class="sidebar-link">Item01：View C++as a federation of languages.  视C++为一个语言联邦</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item02-prefer-consts-enums-and-inlines-to-defines-尽量以const-enum-inline替换-define" class="sidebar-link">Item02：Prefer consts，enums，and inlines to＃defines.  尽量以const，enum，inline替换＃define</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item03-use-const-whenever-possible-尽可能使用const" class="sidebar-link">Item03：Use const whenever possible.  尽可能使用const</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item04-make-sure-that-objects-are-initialized-before-they-re-used-对象在使用前已先被初始化" class="sidebar-link">Item04：Make sure that objects are initialized before they're used.      对象在使用前已先被初始化</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/293b84/#构造-析构-和重载赋值运算符" class="sidebar-link">构造，析构， 和重载赋值运算符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item05-know-what-functions-c-silently-writes-and-calls-了解c-默默编写并调用哪些函数" class="sidebar-link">Item05：Know what     functions C++silently writes and calls. 了解C++默默编写并调用哪些函数</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item06-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want-若不想使用编译器自动生成的函数-就该明确拒绝" class="sidebar-link">Item06：Explicitly     disallow the use of compiler-generated functions you do not want. 若不想使用编译器自动生成的函数，就该明确拒绝</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item07-declare-destructors-virtual-in-polymorphic-base-classes-为多态基类声明virtual析构函数" class="sidebar-link">Item07：Declare destructors virtual in polymorphic base classes. 为多态基类声明virtual析构函数</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item08-prevent-exceptions-from-leaving-destructors-别让异常逃离析构函数" class="sidebar-link">Item08：Prevent     exceptions from leaving destructors. 别让异常逃离析构函数</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item09-never-call-virtual-functions-during-construction-or-destruction-绝不在构造和析构过程中调用virtual函数" class="sidebar-link">Item09：Never call virtual functions during construction or destruction. 绝不在构造和析构过程中调用virtual函数</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item10-have-assignment-operators-return-a-reference-to-this-令operator-返回一个-reference-to-this" class="sidebar-link">Item10：Have assignment     operators return a reference tothis. 令operator=返回一个     reference to this</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item11-handle-assignment-to-self-in-operator-在operator-中判断-自我赋值" class="sidebar-link">Item11：Handle assignment to self in operator=. 在operator=中判断“自我赋值”</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item12-copy-all-parts-of-an-object-复制对象时勿忘其每一个成分" class="sidebar-link">Item12：Copy all parts of an object. 复制对象时勿忘其每一个成分</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/293b84/#resource-management-资源管理" class="sidebar-link">Resource Management， 资源管理</a></li><li class="sidebar-sub-header level2"><a href="/pages/293b84/#item13-以对象管理资源-use-objects-to-manage-resources" class="sidebar-link">Item13：以对象管理资源 Use objects to   manage resources.</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item14-在资源管理类中小心copying行为-think-carefully-about-copyingbehavior-in-resource-managing-classes" class="sidebar-link">Item14：在资源管理类中小心copying行为 Think     carefully about copyingbehavior in resource-managing classes.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item15-在资源管理类中提供对原始资源的访问-provide-access-to-raw-resources-in-resource-managing-classes" class="sidebar-link">Item15：在资源管理类中提供对原始资源的访问 Provide access to raw resources in resource-managing classes.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item16-成对使用new和delete时要采取相同形式-use-the-same-form-in-corresponding-uses-of-new-and-delete" class="sidebar-link">Item16：成对使用new和delete时要采取相同形式 Use the same form in corresponding uses of new and delete.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item17-以独立语句将newed对象置入智能指针-store-newed-objects-in-smart-pointers-in-standalone-statements" class="sidebar-link">Item17：以独立语句将newed对象置入智能指针 Store newed objects in smart pointers in standalone statements.</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/293b84/#design-and-declarations-设计与声明" class="sidebar-link">Design and Declarations, 设计与声明</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item18-让接口容易被正确使用-不易被误用-make-interfaces-easy-to-usecorrectly-and-hard-to-use-incorrectly" class="sidebar-link">Item18：让接口容易被正确使用，不易被误用 Make interfaces easy to usecorrectly and hard to use incorrectly.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item19-设计class犹如设计type-treat-class-design-as-type-design" class="sidebar-link">Item19：设计class犹如设计type Treat class design as type design.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item20-宁以pass-by-reference-to-const替换pass-by-value-prefer-pass-by-reference-to-const-to-pass-by-value" class="sidebar-link">Item20：宁以pass-by-reference-to-const替换pass-by-value     Prefer pass-by-reference-to-const to pass-by-value.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item21-必须返回对象时-别妄想返回其reference-don-t-try-to-return-a-reference-when-you-must-return-an-object" class="sidebar-link">Item21：必须返回对象时，别妄想返回其reference     Don't try to return a reference when you must return an object.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item22-将成员变量声明为private-declare-data-members-private" class="sidebar-link">Item22：将成员变量声明为private Declare     data members private.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item23-宁以non-member、non-friend替换member函数-prefer-non-member-non-friend-functions-to-member-functions" class="sidebar-link">Item23：宁以non-member、non-friend替换member函数     Prefer non-member non-friend functions to member functions.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item24-若所有参数皆需类型转换-请为此采用non-member函数-declarenon-member-functions-when-type-conversions-should-apply-to-all-parameters" class="sidebar-link">Item24：若所有参数皆需类型转换，请为此采用non-member函数 Declarenon-member functions when type conversions should apply to all parameters.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item25-考虑写出一个不抛异常的swap函数-consider-support-for-a-non-throwing-swap" class="sidebar-link">Item25：考虑写出一个不抛异常的swap函数 Consider support for a non-throwing swap.</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/293b84/#implementations-实现" class="sidebar-link">Implementations, 实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item26-尽可能延后变量定义式的出现时间-postpone-variable-definitionsas-long-as-possible" class="sidebar-link">Item26：尽可能延后变量定义式的出现时间 Postpone variable definitionsas long as possible.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item27-尽量少做转型动作-minimize-casting" class="sidebar-link">Item27：尽量少做转型动作 Minimize casting.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item28-避免返回handles指向对象内部成分-avoid-returning-handles-toobject-internals" class="sidebar-link">Item28：避免返回handles指向对象内部成分 Avoid returning&quot;handles&quot;toobject internals.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item29-为-异常安全-而努力是值得的-strive-for-exception-safe-code" class="sidebar-link">Item29：为“异常安全”而努力是值得的 Strive for exception-safe code.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item30-透彻了解inlining的里里外外-understand-the-ins-and-outs-of-inlining" class="sidebar-link">Item30：透彻了解inlining的里里外外     Understand the ins and outs of inlining.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item31-将文件间的编译依存关系降至最低-minimize-compilation-dependencies-between-files" class="sidebar-link">Item31：将文件间的编译依存关系降至最低 Minimize compilation dependencies between files.</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/293b84/#继承与面向对象的设计" class="sidebar-link">继承与面向对象的设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item32-确定你的public继承塑模出is-a关系-make-sure-public-inheritancemodels-is-a" class="sidebar-link">Item32：确定你的public继承塑模出is-a关系 Make sure public inheritancemodels&quot;is-a.&quot;</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item33-避免遮掩继承而来的名称-avoid-hiding-inherited-names" class="sidebar-link">Item33：避免遮掩继承而来的名称 Avoid hiding inherited names.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item34-区分接口继承和实现继承-differentiate-between-inheritance-of-interface-and-inheritance-of-implementation" class="sidebar-link">Item34：区分接口继承和实现继承 Differentiate     between inheritance of interface and inheritance of implementation.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item35-考虑virtual函数以外的其他选择-consider-alte-rnatives-to-virtual-functions" class="sidebar-link">Item35：考虑virtual函数以外的其他选择 Consider alte rnatives to virtual functions.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item36-绝不重新定义继承而来的non-virtual函数-never-redefine-an-inherited-non-virtual-function" class="sidebar-link">Item36：绝不重新定义继承而来的non-virtual函数 Never redefine an inherited non-virtual function.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item37-绝不重新定义继承而来的缺省参数值-never-redefine-a-function-s-inherited-default-parameter-value" class="sidebar-link">Item37：绝不重新定义继承而来的缺省参数值 Never redefine a function's inherited default parameter value.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item38-通过复合塑模出has-a或-根据某物实现出-model-has-a-or-is-implemented-in-terms-of-through-composition" class="sidebar-link">Item38：通过复合塑模出has-a或“根据某物实现出” Model&quot;has-a&quot;or&quot;is-implemented-in-terms-of&quot;through composition.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item39-明智而审慎地使用private继承-use-private-inheritance-judiciously" class="sidebar-link">Item39：明智而审慎地使用private继承 Use     private inheritance judiciously.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item40-明智而审慎地使用多重继承-use-multiple-inheritance-judiciously" class="sidebar-link">Item40：明智而审慎地使用多重继承 Use multiple inheritance judiciously.</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/293b84/#模板-gp" class="sidebar-link">模板，GP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item41-了解隐式接口和编译期多态-understand-implicit-interfaces-and-compile-time-polymorphism" class="sidebar-link">Item41：了解隐式接口和编译期多态 Understand     implicit interfaces and compile-time polymorphism.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item42-了解typename的双重意义-understand-the-two-meanings-of-typename" class="sidebar-link">Item42：了解typename的双重意义 Understand     the two meanings of typename.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item43-学习处理模板化基类内的名称-know-how-to-access-names-in-templatized-base-classes" class="sidebar-link">Item43：学习处理模板化基类内的名称 Know how to     access names in templatized base classes.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item44-将与参数无关的代码抽离templates-factor-parameter-independent-code-out-of-templates" class="sidebar-link">Item44：将与参数无关的代码抽离templates Factor     parameter-independent code out of templates.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item45-运用成员函数模板接受所有兼容类型-use-member-function-templates-to-accept-all-compatible-types" class="sidebar-link">Item45：运用成员函数模板接受所有兼容类型 Use member     function templates to accept&quot;all compatible types.&quot;</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item46-需要类型转换时请为模板定义非成员函数-define-non-member-functions-inside-templates-when-type-conversions-are-desired" class="sidebar-link">Item46：需要类型转换时请为模板定义非成员函数 Define     non-member functions inside templates when type conversions are desired.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item47-请使用traits-classes表现类型信息-use-traits-classes-for-information-about-types" class="sidebar-link">Item47：请使用traits classes表现类型信息 Use     traits classes for information about types.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item48-认识template元编程-be-aware-of-template-metaprogramming" class="sidebar-link">Item48：认识template元编程 Be aware of     template metaprogramming.</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/293b84/#定制new和delete" class="sidebar-link">定制new和delete</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item49-了解new-handler的行为-understand-the-behavior-of-the-new-handler" class="sidebar-link">Item49：了解new-handler的行为 Understand  the behavior of the new-handler.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item50-了解new和delete的合理替换时机-understand-when-it-makes-sense-to-replace-new-and-delete" class="sidebar-link">Item50：了解new和delete的合理替换时机     Understand when it makes sense to replace new and delete.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item51-编写new和delete时需固守常规-adhere-to-convention-when-writing-new-and-delete" class="sidebar-link">Item51：编写new和delete时需固守常规 Adhere     to convention when writing new and delete.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item52-写了placement-new也要写placement-delete-write-placement-delete-if-you-write-placement-new" class="sidebar-link">Item52：写了placement new也要写placement delete Write placement delete if you write placement new.</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/293b84/#一些杂项" class="sidebar-link">一些杂项</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item53-不要轻忽编译器的警告-pay-attention-to-compiler-warnings" class="sidebar-link">Item53：不要轻忽编译器的警告 Pay attention to compiler warnings.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item54-让自己熟悉包括tr1在内的标准程序库-familiarize-yourself-with-the-standard-library-including-tr1" class="sidebar-link">Item54：让自己熟悉包括TR1在内的标准程序库     Familiarize yourself with the standard library，including TR1.</a></li><li class="sidebar-sub-header level3"><a href="/pages/293b84/#item55-让自己熟悉boost库-familiarize-yourself-with-boost" class="sidebar-link">Item55：让自己熟悉Boost库 Familiarize yourself with Boost.</a></li></ul></li></ul></li><li><a href="/pages/07fccd/" class="sidebar-link">《More Effective C++》</a></li><li><a href="/wiki/Reading_Notes/" class="sidebar-link">《C++ 性能优化指南》</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/wiki/#Wiki" data-v-06970110>Wiki</a></li><li data-v-06970110><a href="/wiki/#Reading Notes" data-v-06970110>Reading Notes</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/Quincy-J" target="_blank" title="作者" class="beLink" data-v-06970110>Quincy Jet</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2022-06-27</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">Content</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">《Effective C++》<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="effective-c"><a href="#effective-c" class="header-anchor">#</a> Effective C++</h1> <h2 id="习惯c"><a href="#习惯c" class="header-anchor">#</a> 习惯C++</h2> <h3 id="item01-view-c-as-a-federation-of-languages-视c-为一个语言联邦"><a href="#item01-view-c-as-a-federation-of-languages-视c-为一个语言联邦" class="header-anchor">#</a> Item01：View C++as a federation of languages.  视C++为一个语言联邦</h3> <ol><li><p>C++是一个语言联邦， 有多种编程范式: procedural （面向过程）, OOP（面向对象）， GP（泛型编程）,  Functional Programming（函数式编程），metaprograming(元编程），但差不多有四个主要的部分：</p> <ol><li>C：数组， 指针， 预处理， 程序员的自我修养</li> <li>Object oriented C++： classs, encapsulation, ingeritance, polymorphism,  virtual function的动态绑定；（模板， 异常， 重载）</li> <li>Template C++ (template metaprogramming, 模板元编程)</li> <li>STL： container, iterator, algorithms, function objects</li></ol></li></ol> <h3 id="item02-prefer-consts-enums-and-inlines-to-defines-尽量以const-enum-inline替换-define"><a href="#item02-prefer-consts-enums-and-inlines-to-defines-尽量以const-enum-inline替换-define" class="header-anchor">#</a> Item02：Prefer consts，enums，and inlines to＃defines.  尽量以const，enum，inline替换＃define</h3> <ol start="2"><li><p>用const， enum， inline代替 #define</p> <ol><li><p>const 能够更好地控制指针和指针所指变量的const属性， 并且#define对作用域不敏感，const可以定义某个类专属的常量；</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> GamePlayer<span class="token double-colon punctuation">::</span>NumTurns<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>enum是不可以取地址的，enum hack是模板原编程的基础技术，见item48</p></li> <li><p>#define带来的安全性可以使用模板inline函数实现， 见item30</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token comment">// 暂时用模板的typename代替</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">callWithMax</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ol></li></ol> <h3 id="item03-use-const-whenever-possible-尽可能使用const"><a href="#item03-use-const-whenever-possible-尽可能使用const" class="header-anchor">#</a> Item03：Use const whenever possible.  尽可能使用const</h3> <ol start="3"><li><p>该用const的地方，尽可能使用const</p> <ol><li>类内的变量是否为const?</li> <li>指针的双重const， 在什么之前就修饰什么， 指针为const， 还是指针指向的值为</li> <li>函数的参数是否传const引用？ 使用const修饰， 会明示参数是否被改变（引用不改变， 要加const表示出来）；</li> <li>成员函数后是否要加const？ 看成员函数是否会修改类内的值；</li> <li>返回值是否要成为const（为什么？）， 看返回值类型是否是需要const不允许变动(防止用户自身的村务使用， 不放弃高效性)， 其次是避免成为左值被修改；</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>a<span class="token punctuation">.</span><span class="token function">get_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment">// 返回一个const， 这种操作就是不合法的；</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="6"><li><p>mutable释放掉non-static成员变量的bitwise constness约束；</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">CTextBlock</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    	std<span class="token double-colon punctuation">::</span>size_t <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span><span class="token operator">:</span>
    	<span class="token keyword">char</span><span class="token operator">*</span> pText<span class="token punctuation">;</span>
    	<span class="token keyword">mutable</span> std<span class="token double-colon punctuation">::</span>size_t textLength<span class="token punctuation">;</span> <span class="token comment">//这些变量可能总是会被改变</span>
	    <span class="token keyword">mutable</span> <span class="token keyword">bool</span> lengthIsValis<span class="token punctuation">;</span>
<span class="token comment">// 在length()中， 会频繁改变上述的两个变量；  </span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Key:</p> <ul><li><p>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</p></li> <li><p>编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”（conceptual constness）。</p></li> <li><p>当const和non-const成员函数有着实质等价的实现时(确实是要有两个版本)，令non-const版本调用const版本可避免代码重复。因为const可以兼容non-const的输入， 但是non-const不可以兼容const的输入</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t position<span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// do bounds checking</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// log access data</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// verify data integrity</span>
        <span class="token keyword">return</span> text<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t position<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// do bounds checking</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// log access data</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// verify data integrity</span>
        <span class="token keyword">return</span> text<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string text<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div></li></ul></li></ol></li></ol> <h3 id="item04-make-sure-that-objects-are-initialized-before-they-re-used-对象在使用前已先被初始化"><a href="#item04-make-sure-that-objects-are-initialized-before-they-re-used-对象在使用前已先被初始化" class="header-anchor">#</a> Item04：Make sure that objects are initialized before they're used.      对象在使用前已先被初始化</h3> <ol><li><p>没有初始化的值，在读它的时候会导致不明确的行为， 变量里面包含的内容都是半随机状态；</p></li> <li><p>在初始化列表里面， 列出所有的成员变量， 免得遗漏， 除非记得住哪些不用初始值；</p> <ol><li>实在太多的话， 用一个private函数包一下能够赋值处理的， 也可以；</li> <li>初始化的顺序总是按照声明顺序来， 不是按照初始化列表的顺序</li></ol></li> <li><p>成员变量是const或者reference， 就一定要初始化， 因为后面不能再被赋值了；</p></li> <li><p>如果有一个non-local static对象， 没有办法保证是否使用的时候已经初始化， 那就在本地搞一个static函数（处理static对象的函数叫做static的函数）把这个对象包起来，返回一个指向这个对象的reference， 这样， 外部的static对象就变成了本地的static对象， 这也是singleton模式的一个常见实现手法（这种手法叫做reference returning）</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Directory<span class="token operator">&amp;</span> <span class="token function">tempDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">static</span> Directory<span class="token operator">&amp;</span> td<span class="token punctuation">;</span> <span class="token comment">// more effective c++里面， 限制对象数目的方式， 好像是一样的</span>
	<span class="token keyword">return</span> td<span class="token punctuation">;</span> <span class="token comment">// 还是把non-loca的static的对象，改变成local static的对象比较好；</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>任何一种non const static 对象，在多线程环境下， 都会有线程安全的问题；non const代表了可以被改变， 多线程可以同时改变它；</p></li></ol> <h2 id="构造-析构-和重载赋值运算符"><a href="#构造-析构-和重载赋值运算符" class="header-anchor">#</a> 构造，析构， 和重载赋值运算符</h2> <h3 id="item05-know-what-functions-c-silently-writes-and-calls-了解c-默默编写并调用哪些函数"><a href="#item05-know-what-functions-c-silently-writes-and-calls-了解c-默默编写并调用哪些函数" class="header-anchor">#</a> Item05：Know what     functions C++silently writes and calls. 了解C++默默编写并调用哪些函数</h3> <ol start="5"><li><p>C++ 自动生成的ctor，dtor， copy assignment（op=重载），(big three, 除此之外还有移动构造， 移动赋值， 不过这需要自己的写）</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Empty</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    	<span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    	<span class="token function">Empty</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    	<span class="token operator">~</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

	    Empty<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    Empty e1<span class="token punctuation">;</span>
    Empty <span class="token function">e2</span><span class="token punctuation">(</span>e1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    e2 <span class="token operator">=</span> e1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ol><li><p>默认的构造， 析构函数， 只能是浅复制， 值的复制， 如果有指针， 只能指向同一个地址， 而不能有两份内存出来；</p></li> <li><p>对const成员变量， reference变量， 自动生成的copy assignment是不能对这些东西进行赋值和拷贝操作的</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Timekeeper</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Timekeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>经验： class里面如果有一个virtual的函数， 就为这个类弄一个virtual的析构函数；</p></li> <li><p>纯虚函数？纯虚函数会带来一个抽象基类， 抽象基类不能实例化；但是抽象基类要有一个纯虚的析构函数，需要在H文件里面单独提供一份定义；这样在析构的时候就不会显式运行到在这个纯虚函数；</p> <p>让其他的子类在析构的时候， 会使用到子类自己的析构函数， 而不是默认的析构， 或者是纯虚基类的析构（纯虚基类的纯虚析构函数， 是空的）</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">AWOV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">AWOV</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">AMOV</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">AMOV</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment">// 在.h文件里面单独提供一份定义， 因为虽然是纯虚函数， 但是子类在析构的时候，还是会调用到这个</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ol> <h3 id="item06-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want-若不想使用编译器自动生成的函数-就该明确拒绝"><a href="#item06-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want-若不想使用编译器自动生成的函数-就该明确拒绝" class="header-anchor">#</a> Item06：Explicitly     disallow the use of compiler-generated functions you do not want. 若不想使用编译器自动生成的函数，就该明确拒绝</h3></li> <li><p>如何拒绝使用这些自动生成的函数，</p> <ol><li>使用=delete来禁止使用拷贝构造， 拷贝赋值，</li> <li>以前在没有=delete关键字的时候， 可以把这些函数放在private里面</li></ol> <h3 id="item07-declare-destructors-virtual-in-polymorphic-base-classes-为多态基类声明virtual析构函数"><a href="#item07-declare-destructors-virtual-in-polymorphic-base-classes-为多态基类声明virtual析构函数" class="header-anchor">#</a> Item07：Declare destructors virtual in polymorphic base classes. 为多态基类声明virtual析构函数</h3></li> <li><p>多态基类的析构函数最好弄成virtual的， 如果是non-virtual的，那么借由基类指针传进来的对象， 析构的时候， 派生出来的部分会被漏掉</p> <ol><li>如果析构函数不是virtual的， 那么delete基类指针来进行析构的话。derived部分偶尔会被遗漏掉；</li> <li>为什么不是virtual的构造函数？因为我们构造的时候， 基本上都是用derived类来进行构造的；</li></ol> <p>问题： 对于virtual function， 如何进行派生使用， 如何借由virtual函数来进行多态？</p> <h3 id="item08-prevent-exceptions-from-leaving-destructors-别让异常逃离析构函数"><a href="#item08-prevent-exceptions-from-leaving-destructors-别让异常逃离析构函数" class="header-anchor">#</a> Item08：Prevent     exceptions from leaving destructors. 别让异常逃离析构函数</h3></li> <li><p>析构函数不要吐出异常（别让异常逃离析构函数）, <strong>为什么?</strong></p> <ol><li>如果不处理异常， 会带来一些不明确的行为， 或者程序半路断掉</li> <li>所以要好好善后；怎么办，如果析构函数真的抛出异常， 就在析构函数里面进行try{} catch{} , 要么记录下来，立即停止程序，不重要的异常可以不停下来， 让程序继续进行；也可以用单独的函数来处理异常， 但总之就是在类内部， 处理好异常， 不要让异常逃出析构， 这样可以封装得更完整</li></ol></li></ol> <h3 id="item09-never-call-virtual-functions-during-construction-or-destruction-绝不在构造和析构过程中调用virtual函数"><a href="#item09-never-call-virtual-functions-during-construction-or-destruction-绝不在构造和析构过程中调用virtual函数" class="header-anchor">#</a> Item09：Never call virtual functions during construction or destruction. 绝不在构造和析构过程中调用virtual函数</h3> <ol start="9"><li><p>构造和析构函数中， 不要调用virtual函数， <strong>为什么?</strong>， <strong>static函数相关的使用场景和效果？</strong></p> <ol><li>构造的时候， derived对象还没有生成， 所以这个时候还用不到自身特化的virtual function， 只能用base class里面的版本；</li> <li>析构的时候， 只要一开始析构， 对象内的derived class成员变量就是未定义值， 所以这个时候virtual function还是会跑到父类里面去；</li> <li>父类里面的static函数， 有什么作用？ 是在函数编译的时候， 放在什么段里面？（很大程度和python的static method类似， 能通过类名调用）
static函数里面不能调用non-static成员变量， 也不能调用non-static成员函数; static函数没有<em>this指针</em></li></ol></li></ol> <h3 id="item10-have-assignment-operators-return-a-reference-to-this-令operator-返回一个-reference-to-this"><a href="#item10-have-assignment-operators-return-a-reference-to-this-令operator-返回一个-reference-to-this" class="header-anchor">#</a> Item10：Have assignment     operators return a reference to*this. 令operator=返回一个     reference to *this</h3> <ol start="10"><li><p>operator= 最好是返回一个 reference to *this,</p> <ol><li>因为这样可以拥有连续赋值的特性， 例如： x = y = z = 15</li></ol></li> <li><h3 id="item11-handle-assignment-to-self-in-operator-在operator-中判断-自我赋值"><a href="#item11-handle-assignment-to-self-in-operator-在operator-中判断-自我赋值" class="header-anchor">#</a> Item11：Handle assignment to self in operator=. 在operator=中判断“自我赋值”</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Widget<span class="token operator">&amp;</span> Widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token keyword">delete</span> pb<span class="token punctuation">;</span>
	pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span>rhs<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="item12-copy-all-parts-of-an-object-复制对象时勿忘其每一个成分"><a href="#item12-copy-all-parts-of-an-object-复制对象时勿忘其每一个成分" class="header-anchor">#</a> Item12：Copy all parts of an object. 复制对象时勿忘其每一个成分</h3></li> <li><p>自定义<strong>拷贝构造</strong>函数的时候， 要复制所有local的变量， 可以使用基类的一些拷贝构造函数对一些成员拷贝；</p> <p>因为有一些基类对象的拷贝， 必须要通过<strong>基类的拷贝构造</strong>函数来进行深度拷贝；</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>PriorityCustomer<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">logCall</span><span class="token punctuation">(</span><span class="token string">&quot;......&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Customer<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里直接调用了base class的拷贝构造函数来进行；</span>
    priority <span class="token operator">=</span> rhs<span class="token punctuation">.</span>priority<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>不要使用copy assignment 来调用copy constructor; 反过来也不建议， 因为这就像对一个构造好的对象进行操作， 先有鸡还是先有蛋？</p> <p>最终还是要将他么共同的一些实际操作放到函数里面， 因为只要使用上面两种函数， 都会要实现构造一个临时的对象， 但对象在这些函数运行过程中都是没有构造好的；</p></li></ol> <h2 id="resource-management-资源管理"><a href="#resource-management-资源管理" class="header-anchor">#</a> Resource Management， 资源管理</h2> <h2 id="item13-以对象管理资源-use-objects-to-manage-resources"><a href="#item13-以对象管理资源-use-objects-to-manage-resources" class="header-anchor">#</a> Item13：以对象管理资源 Use objects to   manage resources.</h2> <ol start="13"><li><p>用对象的形式管理资源 (RAII， Resource Acquisition Is Initialization)，所以要特别注意构造和析构函数，在使用对象的时候可以使用shared_ptr之类的智能指针来管理每个对象的实例；</p> <ol><li>返回没有加工的指针， 容易造成资源泄露， 忘记delete</li> <li>手动释放资源， 可能会跑不到释放的那个地方， 也有可能造成double release；</li> <li>不要多个auto_ptr()指向同一个对象， 不然对象可能会被多次删除， 程序就会有未定义行为；</li> <li>使用factory设计模式来供给需要的Invest对象</li> <li>copy assignment要让原来的指针变成null</li> <li>使用reference counting smart pointer, 使用<strong>shared_ptr()</strong> 相关的实现；</li></ol></li></ol> <h3 id="item14-在资源管理类中小心copying行为-think-carefully-about-copyingbehavior-in-resource-managing-classes"><a href="#item14-在资源管理类中小心copying行为-think-carefully-about-copyingbehavior-in-resource-managing-classes" class="header-anchor">#</a> Item14：在资源管理类中小心copying行为 Think     carefully about copyingbehavior in resource-managing classes.</h3> <ol start="14"><li><p>虽然都是RAII原则， 但是要特别注意拷贝构造的行为，</p> <ol><li>一些复制行为明显是没有意义， 不合理的， 书里面用linux中的mutex的lock和unlock函数来举例子， 这个时候要禁止复制的行为；--&gt; uncopyable(陈硕muduo库里面， 好像也有类似的指定操作)， 或者把这些copy assignment设为private或者=delete</li> <li>底层资源使用reference-count的方式；</li> <li>要清楚自己做的是深拷贝还是浅拷贝，要确保自己是在做深拷贝， 不仅拷贝指针， 也拷贝指针所指的内存块；</li> <li>有时候拷贝其实是一种转移， 要确保系统中给目前只有这一个对象， 从一个地方转移到另外一个地方--&gt; auto_ptr， shared_ptr(), 对这些指针的内部构造要很熟悉。【rebuild the auto ptr code demo】</li> <li>自动生成的拷贝函数不一定能够满足需求；</li></ol></li></ol> <h3 id="item15-在资源管理类中提供对原始资源的访问-provide-access-to-raw-resources-in-resource-managing-classes"><a href="#item15-在资源管理类中提供对原始资源的访问-provide-access-to-raw-resources-in-resource-managing-classes" class="header-anchor">#</a> Item15：在资源管理类中提供对原始资源的访问 Provide access to raw resources in resource-managing classes.</h3> <ol start="15"><li><p>资源管理类中， 提供对原始资源的访问接口， 例如x.get， get_instance这种接口, 让类有接口返回内部资源</p> <ol><li><p>返回数字，</p></li> <li><p>返回一个instance</p></li> <li><p>singleton的设计模式是怎么做的?</p></li> <li><p>factory模式是怎么做的？</p></li> <li><p>操作符重载, 这是一种隐式转换的方法， 客户使用起来比较方便，但是显示转换会比较安全（使用xxxx.get()的模式）</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Font</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">operator</span> <span class="token function">FontHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token comment">//也可以重载类型转换函数；</span>
    	<span class="token keyword">return</span> f<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ol></li></ol> <h3 id="item16-成对使用new和delete时要采取相同形式-use-the-same-form-in-corresponding-uses-of-new-and-delete"><a href="#item16-成对使用new和delete时要采取相同形式-use-the-same-form-in-corresponding-uses-of-new-and-delete" class="header-anchor">#</a> Item16：成对使用new和delete时要采取相同形式 Use the same form in corresponding uses of new and delete.</h3> <ol start="16"><li><p>new和delete使用的时候要成对使用， 并且注意区别数组和对象的delete</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> stringPtr1 <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> stringPtr2 <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">delete</span> stringPtr1<span class="token punctuation">;</span> <span class="token comment">// 删除一个对象， 一个指针；</span>
<span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> stringPtr2<span class="token punctuation">;</span> <span class="token comment">// 删除一个数组， 一块内存</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>operator new, new operator的区别？</li> <li>placement new / new placement区别？[item49之后有一些解释]</li></ul> <h3 id="item17-以独立语句将newed对象置入智能指针-store-newed-objects-in-smart-pointers-in-standalone-statements"><a href="#item17-以独立语句将newed对象置入智能指针-store-newed-objects-in-smart-pointers-in-standalone-statements" class="header-anchor">#</a> Item17：以独立语句将newed对象置入智能指针 Store newed objects in smart pointers in standalone statements.</h3></li> <li><p>要保证new这个语句是单独执行的， 先于智能指针的赋值操作；</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>tr1<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 万一priority()这个函数抛出执行异常会怎样？</span>

<span class="token comment">// 用一个单独的语句来构造shared_ptr变量; 保证这行代码是单独执行的;</span>
std<span class="token double-colon punctuation">::</span>tr1<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">&gt;</span> <span class="token function">pw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">processWidget</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol> <h2 id="design-and-declarations-设计与声明"><a href="#design-and-declarations-设计与声明" class="header-anchor">#</a> Design and Declarations, 设计与声明</h2> <h3 id="item18-让接口容易被正确使用-不易被误用-make-interfaces-easy-to-usecorrectly-and-hard-to-use-incorrectly"><a href="#item18-让接口容易被正确使用-不易被误用-make-interfaces-easy-to-usecorrectly-and-hard-to-use-incorrectly" class="header-anchor">#</a> Item18：让接口容易被正确使用，不易被误用 Make interfaces easy to usecorrectly and hard to use incorrectly.</h3> <ol start="18"><li>接口设计简明， 不要让用户对其有歧义
<ol><li><p>建立新类型，限制类型上的操作， 束缚对象值，消除客户的资源管理责任, 一个new type的案例,(enum会带来类型安全的问题? 什么是类型安全?)</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Month</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> Month <span class="token function">Jan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">Month</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">//见下文为什么使用函数，不使用对象</span>
    <span class="token keyword">static</span> Month <span class="token function">Feb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">Month</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">static</span> Month <span class="token function">Dec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">Month</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> 
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">Month</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//explicit禁止参数隐式转换，private禁止用户生成自定义的月份</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Date <span class="token function">d</span><span class="token punctuation">(</span><span class="token class-name">Month</span><span class="token double-colon punctuation">::</span><span class="token function">Mar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Day</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Year</span><span class="token punctuation">(</span><span class="token number">1995</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//正确</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div></li> <li><p>好好设计程序的类型系统， 使用class， template， typedef， struct， enum等等(类型系统的C++最佳实践方式?)</p></li></ol></li></ol> <h3 id="item19-设计class犹如设计type-treat-class-design-as-type-design"><a href="#item19-设计class犹如设计type-treat-class-design-as-type-design" class="header-anchor">#</a> Item19：设计class犹如设计type Treat class design as type design.</h3> <ol start="19"><li><p><strong>设计class的时候， 就好比设计type（一系列要注意的事项）</strong></p> <ul><li><strong>新类型的对象要如何创建和销毁?</strong></li></ul> <p>这决定了要如何写构造函数和析构函数，包括要使用什么内存分配和释放函数，即new还是new[]，delete还是delete[]，见<a href="https://zhuanlan.zhihu.com/p/74067275" target="_blank" rel="noopener noreferrer">第16章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><strong>对象初始化要如何区别于赋值?</strong></li></ul> <p>这决定了你如何写，如何区别构造函数和赋值运算符，以及不要把初始化与赋值混淆，因为它们的语义不同，构造函数适用于未创建的对象，赋值适用于已创建的对象，这也是为什么我们要在构造函数中使用初始化列表而不使用赋值的原因，见<a href="https://zhuanlan.zhihu.com/p/64141116" target="_blank" rel="noopener noreferrer">第4章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="https://zhuanlan.zhihu.com/p/68633893" target="_blank" rel="noopener noreferrer">第12章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <ul><li><strong>新类型的对象传值有什么意义?</strong></li></ul> <p>要记住拷贝构造函数决定了你的类型是如何被传值的，因为传值会生成本地的拷贝。</p> <ul><li><strong>新类型的合法数值有什么限制?</strong></li></ul> <p>通常情况下，并不是成员的任何数值组合都是合法的。要让数据成员合法，我们需要根据合法的组合，在成员函数中对数值进行检测，尤其是构造函数，赋值运算符和setter。这也会影响到使用它的函数会抛出什么异常。</p> <ul><li><strong>新类型属于某个继承层次吗?</strong></li></ul> <p>如果你的新类型继承自某个已有的类，你的设计将被这些父类影响到，尤其是父类的某些函数是不是虚函数。如果你的新类型要作为一个父类，你将要决定把哪些函数声明为虚函数，尤其要注意析构函数，见<a href="https://zhuanlan.zhihu.com/p/65257902" target="_blank" rel="noopener noreferrer">第7章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <ul><li><strong>新类型允许什么样的转换?</strong></li></ul> <p>新类型的对象将会在程序的海洋中与其它各种各样的类型并用，这时你就要决定是否允许类型的转换。如果你希望把T1隐式转换为T2，你可以在T1中定义一个转换函数，例如operator T2，或者在T2中定义一个兼容T1的不加explicit修饰的构造函数。</p> <p>如果希望使用显式转换，你要定义执行显示转换的函数，详见<a href="https://zhuanlan.zhihu.com/p/73563364" target="_blank" rel="noopener noreferrer">第15章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <ul><li><strong>什么运算符和函数对于你的新类型是有意义的?</strong></li></ul> <p>这决定了你要声明哪些函数，包括成员函数，非成员函数，友元函数等。</p> <ul><li><strong>你要禁止哪些标准函数?</strong></li></ul> <p>如果不希望使用编译器会自动生成的标准函数，把它们声明为私有，见<a href="https://zhuanlan.zhihu.com/p/64638672" target="_blank" rel="noopener noreferrer">第6章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><strong>谁可以接触到成员?</strong></li></ul> <p>这影响到哪些成员是公有的，哪些是保护的，哪些是私有的。这也能帮你决定哪些类和函数是友元的，以及要不要使用嵌套类(nested class)。</p> <ul><li><strong>新类型的&quot;隐藏接口&quot;是什么?</strong></li></ul> <p>新类型对于性能，异常安全性，资源管理(例如锁和内存)有什么保障? 哪些问题是自动解决不需要用户操心的? 要实现这些保障，自然会对这个类的实现产生限制，例如要使用智能指针而不要使用裸指针。</p> <ul><li><strong>新类型有多通用?</strong></li></ul> <p>如果想让你的新类型通用于许多类型，定义一个类模板(class template)，而不是单个新类型。</p> <ul><li><p><strong>新类型真的是你需要的吗?</strong></p> <p>如果定义一个子类只是为了给基类增加某些新功能，定义一些非成员的函数或者函数模板更加划算。</p></li> <li><p>如何创建和销毁， operator new, operator new[]. operator delete, operator delete[],</p></li> <li><p>对象初始化和对象的赋值有什么区别？ copy constructor 和copy assignment之间有什么区别？</p></li></ul></li></ol> <p>对一个新对象来说， pass by value意味着什么？因为要重载操作符， 函数， 和重载内存的分配和归还，</p> <p>type cast的我呢提要怎么处理， 类型转换函数， operator T</p> <h3 id="item20-宁以pass-by-reference-to-const替换pass-by-value-prefer-pass-by-reference-to-const-to-pass-by-value"><a href="#item20-宁以pass-by-reference-to-const替换pass-by-value-prefer-pass-by-reference-to-const-to-pass-by-value" class="header-anchor">#</a> Item20：宁以pass-by-reference-to-const替换pass-by-value     Prefer pass-by-reference-to-const to pass-by-value.</h3> <ol start="20"><li><p>函数的参数使用pass by reference to const替换pass by value，（内置类型， 其实pass by value也比较合适）</p> <ol><li>效率会比较高, 因为pass by value会产生临时对象, 对于非内置类型, 会调用copy constructor来进行构造</li> <li>pass by reference to const 实际上传递的是指针, 能够支持继承类的多态特性.</li> <li>内置类型, STL迭代器和一些函数对象, 其实pass by value并不昂贵</li></ol> <h3 id="item21-必须返回对象时-别妄想返回其reference-don-t-try-to-return-a-reference-when-you-must-return-an-object"><a href="#item21-必须返回对象时-别妄想返回其reference-don-t-try-to-return-a-reference-when-you-must-return-an-object" class="header-anchor">#</a> Item21：必须返回对象时，别妄想返回其reference     Don't try to return a reference when you must return an object.</h3></li> <li><p>如果必须返回一个对象，  不要返回他的reference， 因为可能会返回一个local的对象，local对象的renference是没有用的；</p> <h3 id="item22-将成员变量声明为private-declare-data-members-private"><a href="#item22-将成员变量声明为private-declare-data-members-private" class="header-anchor">#</a> Item22：将成员变量声明为private Declare     data members private.</h3></li> <li><p>成员变量声明为private</p> <ol><li>public成员全部都是函数, 有利于语法一致性</li> <li>使用函数来对成员变量进行精确的访问控制， 这样能够给类更好的封装性</li> <li>protect成员其实也是没有封装的, 因为如果在后续版本的代码里面,删除了这个protect成员, 其子类一样也需要修改</li></ol> <h3 id="item23-宁以non-member、non-friend替换member函数-prefer-non-member-non-friend-functions-to-member-functions"><a href="#item23-宁以non-member、non-friend替换member函数-prefer-non-member-non-friend-functions-to-member-functions" class="header-anchor">#</a> Item23：宁以non-member、non-friend替换member函数     Prefer non-member non-friend functions to member functions.</h3></li> <li><p>使用non member, non friend来替换member函数</p> <ol><li>对于private成员, 能够接触它的就是成员函数+友元函数</li> <li>为的是增加封装性， 增加扩充的弹性，可以使用一个完全的第三方全局的function来进行, 称之为便携函数;</li> <li>可以把这个全局函数放在一个命名空间里面， 稍微约束一下它的作用域</li></ol> <h3 id="item24-若所有参数皆需类型转换-请为此采用non-member函数-declarenon-member-functions-when-type-conversions-should-apply-to-all-parameters"><a href="#item24-若所有参数皆需类型转换-请为此采用non-member函数-declarenon-member-functions-when-type-conversions-should-apply-to-all-parameters" class="header-anchor">#</a> Item24：若所有参数皆需类型转换，请为此采用non-member函数 Declarenon-member functions when type conversions should apply to all parameters.</h3></li> <li><p><strong>如果某个函数所有的参数都需要类型转换， 这个函数必须弄成non merber函数</strong></p> <ol><li><p>隐式转换总体上会给程序带来隐患，因为如果出现了类型错误，编译器是不会报错的。</p></li> <li><p><strong>只有在参数表里出现的参数才可以进行隐式转换</strong>。例如operator*()这个函数, 局部的重载, 其实只能是X * 2这种形式, 但如果是要支持2 * x这种, 就需要全局的operator*()函数来支持;</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">// 成员函数</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//编译通过</span>
result <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> oneHalf<span class="token punctuation">;</span> <span class="token comment">//编译错误</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                  lhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token comment">//作为非成员函数, 两个参数都需要支持隐式转换</span>
Rational <span class="token function">oneFourth</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Rational result<span class="token punctuation">;</span>
result <span class="token operator">=</span> oneFourth <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//可以编译</span>
result <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> oneFourth<span class="token punctuation">;</span> <span class="token comment">//可以编译</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ol> <h3 id="item25-考虑写出一个不抛异常的swap函数-consider-support-for-a-non-throwing-swap"><a href="#item25-考虑写出一个不抛异常的swap函数-consider-support-for-a-non-throwing-swap" class="header-anchor">#</a> Item25：考虑写出一个不抛异常的swap函数 Consider support for a non-throwing swap.</h3></li> <li><p>给自己的类写的swap函数，不要抛出异常， 这是为了和STL库一样支持swap的异常安全；</p> <ol><li><p>friend可以方位private变量和函数；</p></li> <li><p>使用<strong>pimpl</strong>(the &quot;pimpl&quot; idiom，即&quot;pointer to implementation&quot;), 这样一来，要调换两个对象，直接交换指针就行了</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//这个类包含Widget类的数据</span>
<span class="token keyword">class</span> <span class="token class-name">WidgetImpl</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span> <span class="token comment">//高成本拷贝警告！</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//使用pimpl手法的类</span>
<span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">{</span>  
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//赋值运算符的实现见ch 10,11,12</span>
    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      <span class="token operator">*</span>pImpl <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">private</span><span class="token operator">:</span>
    WidgetImpl<span class="token operator">*</span> pImpl<span class="token punctuation">;</span> <span class="token comment">//使用pimpl指针来指向我们的数据</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div></li> <li><p>如果默认的std::swap不会对效率产生比较大的影响，例如对象的成员数据不多，直接使用是没有问题的，就不用大费周章搞这些了</p> <p>如果默认的std::swap会对你的函数/类模板产生效率影响: 给你的类使用pimpl手法，然后给它写一个只交换指针的swap成员函数，而且这个函数禁止抛出异常，然后:</p> <p>对于类模板，要在类模板相同的名空间下写一个自定义的swap，在里面调用swap成员函数</p> <p>对于类(不是类模板)，还要给std::swap进行特殊化，也在它里面调用swap成员函数</p> <p>调用swap的时候确保加上using语句来让std名空间里面的swap对编译器可见，然后swap函数前不要加任何名空间资格限制(qualification)</p></li> <li><p>当默认的std::swap可能会拉低你自己的类的效率时，在自己的类里写一个swap成员函数，而且要保证它不会抛出异常</p> <p>写了swap成员函数，按照编程惯例还要写一个非成员swap函数，放在类或者类模板的名空间下，用它来调用成员swap函数。对于类(非模板)，还要特殊化std::swap</p> <p>在调用swap时，要加上一句using std::swap，然后调用时不需要再加任何名空间资格限制,  否则可能会调用到私有的swap函数里面去</p> <p>为了自定义的类而完全特殊化std模板是没问题的，但千万不要给std里添加任何东西。</p> <p>再或者, 直接使用类自带的namespace, 来重写swap函数;</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span> <span class="token comment">// 这句稍后解释</span>
      <span class="token function">swap</span><span class="token punctuation">(</span>pImpl<span class="token punctuation">,</span> other<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行真正的swap，只交换指针</span>
    <span class="token punctuation">}</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">namespace</span> std<span class="token punctuation">{</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token comment">// 完全特殊化的std::swap</span>
  <span class="token keyword">void</span> <span class="token generic-function"><span class="token function">swap</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> Widget<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div></li></ol></li></ol> <h2 id="implementations-实现"><a href="#implementations-实现" class="header-anchor">#</a> Implementations, 实现</h2> <h3 id="item26-尽可能延后变量定义式的出现时间-postpone-variable-definitionsas-long-as-possible"><a href="#item26-尽可能延后变量定义式的出现时间-postpone-variable-definitionsas-long-as-possible" class="header-anchor">#</a> Item26：尽可能延后变量定义式的出现时间 Postpone variable definitionsas long as possible.</h3> <ol start="26"><li><p>延迟变量定义的出现时间， 尽量<strong>用到的时候再定义；</strong></p> <ol><li><p>每当定义一个变量时，就会带来构造和析构的运行成本，因为代码运行到定义时会调用对象的构造函数，当离开作用域时便会调用析构函数。</p></li> <li><p>把它的定义尽量往后推迟，直到我们100%确定要用到:</p></li> <li><div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//用:</span>
string <span class="token function">encrypted</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//替换掉:</span>
string encrypted<span class="token punctuation">;</span>
encrypted <span class="token operator">=</span> password<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们不仅仅需要把变量的定义推迟到<strong>100%要用到</strong>的地方，还要把它推迟到<strong>100%有构造参数可用</strong>的时候。这样做既可以避免不必要的构造和析构过程，也能节省默认构造再赋值的成本。而且这样的代码也更可读，因为变量定义在了真正需要它的环境下。</p> <p>对于一个变量只在循环里用到，把它定义在循环外面然后每次在里面赋值好，即代码A，还是直接在里面定义呢，即代码B?</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//代码A，在外面定义</span>
Widget w<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  w<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">//代码B，在里面定义</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  Widget <span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>那么我们就来分析一下A和B各自的运行成本:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>A<span class="token operator">:</span> <span class="token number">1</span>个构造 <span class="token operator">+</span> n个赋值 <span class="token operator">+</span> <span class="token number">1</span>个析构
B<span class="token operator">:</span> n个构造 <span class="token operator">+</span> n个析构
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>对于赋值成本低于(构造+析构)的类，A是更高效的选择，尤其是当n很大的时候。反之如果赋值成本大于(构造+析构)，B则是更好的选择。但是对象在A的作用域比在B要大，有时是不利于程序的可读性和可维护性的。因此<strong>除非</strong>你知道赋值成本低于(构造+析构)，而且这段代码要更注重效率，那么我们应该默认使用B。</p></li></ol> <h3 id="item27-尽量少做转型动作-minimize-casting"><a href="#item27-尽量少做转型动作-minimize-casting" class="header-anchor">#</a> Item27：尽量少做转型动作 Minimize casting.</h3></li> <li><p>少做cast转型动作， 即使要用也尽量使用C++自己的那四个转型, 这里涉及几种C++形式的转换的作用和相关的优缺点</p> <ol><li>C++的类型转换有3种方式，C风格，函数风格和C++风格:</li></ol></li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token punctuation">(</span>T<span class="token punctuation">)</span>expression  <span class="token comment">//C风格</span>
<span class="token function">T</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span> <span class="token comment">//函数风格</span>

<span class="token comment">//C++风格</span>
<span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span>
<span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span>     <span class="token comment">//T必须是指向多态类型的指针或引用</span>
<span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span>       <span class="token comment">//T必须是指针或引用</span>
<span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span> <span class="token comment">//T必须是指针或引用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如果一定要转型， 请放在函数里面， 不要让用户在使用这个函数的时候还要惦记转型的事情；</p> <h3 id="item28-避免返回handles指向对象内部成分-avoid-returning-handles-toobject-internals"><a href="#item28-避免返回handles指向对象内部成分-avoid-returning-handles-toobject-internals" class="header-anchor">#</a> Item28：避免返回handles指向对象内部成分 Avoid returning&quot;handles&quot;toobject internals.</h3> <ol start="28"><li><p>避免返回一个handler， 这个handler却有指向对象的内部成分，</p> <ol><li><p>如果一个函数返回了指向<strong>储存在对象外部</strong>的数据成员的引用，即使这个函数声明为了const，调用这个函数的人也能修改这个成员(见<a href="https://zhuanlan.zhihu.com/p/63609476" target="_blank" rel="noopener noreferrer">第3章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>bitwise constness的局限性)</p></li> <li><p>避免返回的是一个空悬的指针；</p></li> <li><p>避免可以使用调用的操作来对函数内部的元素进行修改， 可以指定返回值是一个const， 这样用户就不能修改了；</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Rectangle</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>   
    <span class="token comment">//现在返回的是const Point&amp;   </span>
    <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> <span class="token function">upperLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span><span class="token keyword">return</span> pData<span class="token operator">-&gt;</span>ulhc<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> <span class="token function">lowerRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span><span class="token keyword">return</span> pData<span class="token operator">-&gt;</span>lrhc<span class="token punctuation">;</span><span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p>避免返回指向内部成员的&quot;句柄&quot;，包括指针，引用，迭代器。不返回&quot;句柄&quot;能增强封装性，让const函数真正const，也能减少&quot;野句柄&quot;。</p></li></ol></li></ol> <h3 id="item29-为-异常安全-而努力是值得的-strive-for-exception-safe-code"><a href="#item29-为-异常安全-而努力是值得的-strive-for-exception-safe-code" class="header-anchor">#</a> Item29：为“异常安全”而努力是值得的 Strive for exception-safe code.</h3> <ol start="29"><li><p>注意异常安全， （exceptional C++里面有很多异常安全的相关介绍）</p> <ul><li><p>异常安全</p> <blockquote><p><em><strong>异常安全***的意思就是，<em><strong>当程序在异常发生的时候，程序可以回退的很干净</strong></em>。什么是回退的很干净呢？其实就是函数在发生异常的时候***不会泄露资源***或者***不会发生任何数据结构的破坏</strong></em>。</p></blockquote> <p>不泄露任何资源</p> <p>不允许破坏任何数据</p></li></ul></li></ol> <ul><li><p>异常安全的函数即使在抛出异常时也不会泄露资源，损坏数据结构。这种安全性有三种级别，基本保证，强保证和不抛出保证</p> <ul><li>提供<strong>基本保证</strong>(basic guarantee)的函数可以保证即使抛出了异常，函数也能在有效的状态下运行，没有对象或数据损坏，所有对象也保持内部一致，依然满足类不变量(class invariant)，但是程序本身则可能处于不确定状态。例如用户使用我们changeBackground方法时抛出了异常，PrettyMenu对象可能依然持有原来的背景，或者持有默认的背景，但具体哪个则是不确定的。</li> <li>提供<strong>强保证</strong>(strong guarantee)的函数可以保证如果函数抛出了异常，程序的状态不会改变。这就意味着对强保证函数的调用是原子性的(atomic)，如果成功了就成功了，如果失败了就像什么都没有发生一样。强保证函数比基本保证函数更容易使用，因为强保证函数只能导致两种状态，成功或者不变，而基本保证的函数可能引向任何状态。</li> <li>提供<strong>不抛出保证</strong>(nothrow guarantee)的函数保证永远不会抛出异常。例如所有对于基本类型(int，指针等等)的操作都提供不抛出保证。它是异常安全代码的基础。</li></ul></li> <li><p>copy and swap是实现强保证的有效方法，但给所有的函数加上强保证显然也不是实际的选择</p></li> <li><p>函数的异常安全性遵循木桶原理，函数的最强安全性取决于它所调用操作的最弱安全性</p></li></ul> <h3 id="item30-透彻了解inlining的里里外外-understand-the-ins-and-outs-of-inlining"><a href="#item30-透彻了解inlining的里里外外-understand-the-ins-and-outs-of-inlining" class="header-anchor">#</a> Item30：透彻了解inlining的里里外外     Understand the ins and outs of inlining.</h3> <ol start="30"><li>对inline的里里外外需要透彻了解；</li></ol> <ul><li>尽量inline， 也许compiler就能够执行context相关的inline优化；</li> <li>定义在类里面的函数， 自动inline</li> <li>inline会让代码文件变大， 会导致更多的换页行为（paging），降低 i cache的命中率, 如果函数比较小， inline对 icache miss的影响会稍微比较小， 但是inline的函数比较大， 就有可能会得不偿失；</li> <li>虚函数的inline， 大多都不会生效</li> <li>inline不仅会导致代码变大， 而且一旦inline的函数发生改变， 所有用到inline function的地方都要重新编译</li> <li>inline函数一般放在头文件里面， template一般也都是发那个在头文件里面；</li> <li>template要避免无脑成为一个inline函数， 它的代价是很大的；因为可能程序中很多地方都用到了这个模板</li></ul> <h3 id="item31-将文件间的编译依存关系降至最低-minimize-compilation-dependencies-between-files"><a href="#item31-将文件间的编译依存关系降至最低-minimize-compilation-dependencies-between-files" class="header-anchor">#</a> Item31：将文件间的编译依存关系降至最低 Minimize compilation dependencies between files.</h3> <ol start="31"><li>尽量减少文件之间的编译依赖关系；不然修改之后编译， 会导致很多部件都一起编译了【缺demo】</li></ol> <ul><li>头文件应该仅有声明不要有定义；</li> <li>可以只有声明， 而没有定义， 这会导致一个方法： 前向声明， 前向声明只是把#include的内容， 放在代码的前面；</li> <li>一般使用pointer to implementation 和纯虚函数的工厂方法来解决， 前者叫handle class, 后者叫interface class;</li></ul> <h2 id="继承与面向对象的设计"><a href="#继承与面向对象的设计" class="header-anchor">#</a> 继承与面向对象的设计</h2> <ul><li><p>单一继承与多重继承</p></li> <li><p>public继承，private继承， protected继承</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>virtual / non-virtual 继承</p></li> <li><p>成员函数和其他语言特性的影响</p> <ul><li>缺省参数与virtual函数的影响？</li> <li>继承如何影响C++函数名臣的查找规则？</li> <li>设计选项</li> <li>class行为如果要修改， virtual函数是最佳选择吗？</li></ul></li></ul> <h3 id="item32-确定你的public继承塑模出is-a关系-make-sure-public-inheritancemodels-is-a"><a href="#item32-确定你的public继承塑模出is-a关系-make-sure-public-inheritancemodels-is-a" class="header-anchor">#</a> Item32：确定你的public继承塑模出is-a关系 Make sure public inheritancemodels&quot;is-a.&quot;</h3> <ol start="32"><li><p>public继承的时候， 确认两个对象是 is a的关系；多态通过虚函数来完成，</p> <ol><li>什么时候用虚函数？什么时候用纯虚函数？</li></ol></li></ol> <h3 id="item33-避免遮掩继承而来的名称-avoid-hiding-inherited-names"><a href="#item33-避免遮掩继承而来的名称-avoid-hiding-inherited-names" class="header-anchor">#</a> Item33：避免遮掩继承而来的名称 Avoid hiding inherited names.</h3> <ol start="33"><li>继承的时候，注意类内部的变量名称是否会被覆盖，</li></ol> <ul><li>即使是重载的函数，不管函数接口形式是否一样， 也会被子类的同名函数覆盖</li> <li>使用using Base::mf3() 可以指定在子类作用域范围里面使用base类的mf3函数，</li> <li>如果只想使用某一个mf3(),  只能是子类的函数里面， 再调用Base::mf3(); 这种方式叫forward functions;</li></ul> <h3 id="item34-区分接口继承和实现继承-differentiate-between-inheritance-of-interface-and-inheritance-of-implementation"><a href="#item34-区分接口继承和实现继承-differentiate-between-inheritance-of-interface-and-inheritance-of-implementation" class="header-anchor">#</a> Item34：区分接口继承和实现继承 Differentiate     between inheritance of interface and inheritance of implementation.</h3> <ol start="34"><li>什么是接口继承和实现继承？
<ol><li>pure virtual函数的目的就是接口继承， 但是也可以有一份基类实现，调用的时候只能通过子类指定父类名称的方式来调用（纯虚函数必须重写）；</li> <li>非纯虚函数是为了让子类继承接口 + 缺省实现， 这些都是自动继承的， 如果子类不override 虚函数的话（一般虚函数可以重写， 也可以不重写）；</li> <li>非虚函数的目的是强制让子类继承一个缺省的实现；（非虚函数，没有多态性，直接继承）</li> <li>接口和实现继承分开， 也就是把接口用一个纯虚函数来声明， 实现使用一个private或者protected的缺省实现来代替， 这样子类必须要重写纯虚函数，但是可以默认使用缺省的实现；</li> <li>也可以使用一个虚函数的非虚实现， 然后再在子类里面overide的时候调用这个函数；</li></ol></li></ol> <h3 id="item35-考虑virtual函数以外的其他选择-consider-alte-rnatives-to-virtual-functions"><a href="#item35-考虑virtual函数以外的其他选择-consider-alte-rnatives-to-virtual-functions" class="header-anchor">#</a> Item35：考虑virtual函数以外的其他选择 Consider alte rnatives to virtual functions.</h3> <ol start="35"><li>除了virtual函数之外，也可以考虑一下其他的选择
<ol><li>通过一个public函数， 调用自己的virtual函数， non-virtual interface（NVI）方法；（模板方法设计模式）， 子类就</li> <li>借助funciion pointer实现strategy模式</li> <li>使用各个库里面的function component来实现strategy模式， 例如std::function， 而且这个东西支持任何callable entities，包括运算符重载的struct和class</li> <li>标准设计模式， 古典的strategy模式， 就是使用pImple的方式来实现strategy， 来代替第一条里面的实现方式</li></ol></li></ol> <h3 id="item36-绝不重新定义继承而来的non-virtual函数-never-redefine-an-inherited-non-virtual-function"><a href="#item36-绝不重新定义继承而来的non-virtual函数-never-redefine-an-inherited-non-virtual-function" class="header-anchor">#</a> Item36：绝不重新定义继承而来的non-virtual函数 Never redefine an inherited non-virtual function.</h3> <ol start="36"><li>不要重新定义继承来的non virtual函数， 这其实是一种overloading， 并不能实现多态特性的overide， nonvirtual 函数其实是静态绑定的(dynamic binding)；virtual函数是动态绑定(dynamic binding)</li></ol> <h3 id="item37-绝不重新定义继承而来的缺省参数值-never-redefine-a-function-s-inherited-default-parameter-value"><a href="#item37-绝不重新定义继承而来的缺省参数值-never-redefine-a-function-s-inherited-default-parameter-value" class="header-anchor">#</a> Item37：绝不重新定义继承而来的缺省参数值 Never redefine a function's inherited default parameter value.</h3> <ol start="37"><li>不要重新定义继承来的缺省参数值， 因为可能会在调用子类的时候， 用到父类里面这个函数的默认值，（对于通过对象指针， 引用的方式都会有这个问题， 因为默认参数的绑定是一种静态绑定），子类就声明参数就可以了， 不需要有默认值</li></ol> <h3 id="item38-通过复合塑模出has-a或-根据某物实现出-model-has-a-or-is-implemented-in-terms-of-through-composition"><a href="#item38-通过复合塑模出has-a或-根据某物实现出-model-has-a-or-is-implemented-in-terms-of-through-composition" class="header-anchor">#</a> Item38：通过复合塑模出has-a或“根据某物实现出” Model&quot;has-a&quot;or&quot;is-implemented-in-terms-of&quot;through composition.</h3> <ol start="38"><li><p>通过composition实现has a, 或者根据某物实现的关系</p> <ol><li>要区分， composite和interitate之间的区别（复合与继承之间的关系）</li></ol></li></ol> <h3 id="item39-明智而审慎地使用private继承-use-private-inheritance-judiciously"><a href="#item39-明智而审慎地使用private继承-use-private-inheritance-judiciously" class="header-anchor">#</a> Item39：明智而审慎地使用private继承 Use     private inheritance judiciously.</h3> <ol start="39"><li>谨慎使用private继承，
<ol><li>编译器不会把一个private继承的子类，自动转换成一个基类</li> <li>private继承下来的所有成员， 在子类中都会变成private属性</li> <li>protect继承
<ol><li>默认的基本上都是public继承；</li> <li>尽可能使用compiosition， 必要的时候再使用private继承</li></ol></li></ol></li></ol> <h3 id="item40-明智而审慎地使用多重继承-use-multiple-inheritance-judiciously"><a href="#item40-明智而审慎地使用多重继承-use-multiple-inheritance-judiciously" class="header-anchor">#</a> Item40：明智而审慎地使用多重继承 Use multiple inheritance judiciously.</h3> <ol start="40"><li>谨慎使用多重继承（子类从多个父类继承而来）
<ol><li>可能对导致对基类函数调用的歧义，到底调用的是哪一个基类的成员函数？</li> <li>钻石形继承， 二级基类可以是虚基类(virtual继承)， 这样三级再继承的时候， 就不会重复出现两个爷爷类里面的成员函数了；</li> <li>virtual继承会带来更多大小，速度，初始化的成本。如果非要有一个virtual base class， 最好不要在虚基类里面放置数据；</li> <li>有一种情况， 比较适合多重继承，public继承某个interface class， private继承某个协助实现的class；帮助子类实现某些功能。但是还是谨记第一条吧；</li></ol></li></ol> <h2 id="模板-gp"><a href="#模板-gp" class="header-anchor">#</a> 模板，GP</h2> <h3 id="item41-了解隐式接口和编译期多态-understand-implicit-interfaces-and-compile-time-polymorphism"><a href="#item41-了解隐式接口和编译期多态-understand-implicit-interfaces-and-compile-time-polymorphism" class="header-anchor">#</a> Item41：了解隐式接口和编译期多态 Understand     implicit interfaces and compile-time polymorphism.</h3> <ol start="41"><li>隐式接口和编译期多态（和RTTI的区别？）</li></ol> <h3 id="item42-了解typename的双重意义-understand-the-two-meanings-of-typename"><a href="#item42-了解typename的双重意义-understand-the-two-meanings-of-typename" class="header-anchor">#</a> Item42：了解typename的双重意义 Understand     the two meanings of typename.</h3> <ol start="42"><li>typename和class关键字， typename关键字的双重定义</li></ol> <h3 id="item43-学习处理模板化基类内的名称-know-how-to-access-names-in-templatized-base-classes"><a href="#item43-学习处理模板化基类内的名称-know-how-to-access-names-in-templatized-base-classes" class="header-anchor">#</a> Item43：学习处理模板化基类内的名称 Know how to     access names in templatized base classes.</h3> <ol start="43"><li>如何处理模板化基类的里面的名称</li></ol> <h3 id="item44-将与参数无关的代码抽离templates-factor-parameter-independent-code-out-of-templates"><a href="#item44-将与参数无关的代码抽离templates-factor-parameter-independent-code-out-of-templates" class="header-anchor">#</a> Item44：将与参数无关的代码抽离templates Factor     parameter-independent code out of templates.</h3> <ol start="44"><li>参数无关的代码， 抽离template</li></ol> <h3 id="item45-运用成员函数模板接受所有兼容类型-use-member-function-templates-to-accept-all-compatible-types"><a href="#item45-运用成员函数模板接受所有兼容类型-use-member-function-templates-to-accept-all-compatible-types" class="header-anchor">#</a> Item45：运用成员函数模板接受所有兼容类型 Use member     function templates to accept&quot;all compatible types.&quot;</h3> <ol start="45"><li>使用成员函数模板来接受所有兼容的类型</li></ol> <h3 id="item46-需要类型转换时请为模板定义非成员函数-define-non-member-functions-inside-templates-when-type-conversions-are-desired"><a href="#item46-需要类型转换时请为模板定义非成员函数-define-non-member-functions-inside-templates-when-type-conversions-are-desired" class="header-anchor">#</a> Item46：需要类型转换时请为模板定义非成员函数 Define     non-member functions inside templates when type conversions are desired.</h3> <ol start="46"><li>需要类型转换的时候， 为模板定义一个非成员函数</li></ol> <h3 id="item47-请使用traits-classes表现类型信息-use-traits-classes-for-information-about-types"><a href="#item47-请使用traits-classes表现类型信息-use-traits-classes-for-information-about-types" class="header-anchor">#</a> Item47：请使用traits classes表现类型信息 Use     traits classes for information about types.</h3> <ol start="47"><li>使用traits来表现模板里面的类型信息</li></ol> <h3 id="item48-认识template元编程-be-aware-of-template-metaprogramming"><a href="#item48-认识template元编程-be-aware-of-template-metaprogramming" class="header-anchor">#</a> Item48：认识template元编程 Be aware of     template metaprogramming.</h3> <ol start="48"><li>什么是template元编程</li></ol> <h2 id="定制new和delete"><a href="#定制new和delete" class="header-anchor">#</a> 定制new和delete</h2> <h3 id="item49-了解new-handler的行为-understand-the-behavior-of-the-new-handler"><a href="#item49-了解new-handler的行为-understand-the-behavior-of-the-new-handler" class="header-anchor">#</a> Item49：了解new-handler的行为 Understand  the behavior of the new-handler.</h3> <ol start="49"><li>new handler的行为（处理new失败时候throw的异常）， 底层是怎样构成的？</li></ol> <h3 id="item50-了解new和delete的合理替换时机-understand-when-it-makes-sense-to-replace-new-and-delete"><a href="#item50-了解new和delete的合理替换时机-understand-when-it-makes-sense-to-replace-new-and-delete" class="header-anchor">#</a> Item50：了解new和delete的合理替换时机     Understand when it makes sense to replace new and delete.</h3> <ol start="50"><li>operator new和operator delete的合理替换时机；</li></ol> <h3 id="item51-编写new和delete时需固守常规-adhere-to-convention-when-writing-new-and-delete"><a href="#item51-编写new和delete时需固守常规-adhere-to-convention-when-writing-new-and-delete" class="header-anchor">#</a> Item51：编写new和delete时需固守常规 Adhere     to convention when writing new and delete.</h3> <ol start="51"><li>operator new和operator delete需要遵循的一些规则</li></ol> <h3 id="item52-写了placement-new也要写placement-delete-write-placement-delete-if-you-write-placement-new"><a href="#item52-写了placement-new也要写placement-delete-write-placement-delete-if-you-write-placement-new" class="header-anchor">#</a> Item52：写了placement new也要写placement delete Write placement delete if you write placement new.</h3> <ol start="52"><li>placement new和placement delete</li></ol> <h2 id="一些杂项"><a href="#一些杂项" class="header-anchor">#</a> 一些杂项</h2> <h3 id="item53-不要轻忽编译器的警告-pay-attention-to-compiler-warnings"><a href="#item53-不要轻忽编译器的警告-pay-attention-to-compiler-warnings" class="header-anchor">#</a> Item53：不要轻忽编译器的警告 Pay attention to compiler warnings.</h3> <h3 id="item54-让自己熟悉包括tr1在内的标准程序库-familiarize-yourself-with-the-standard-library-including-tr1"><a href="#item54-让自己熟悉包括tr1在内的标准程序库-familiarize-yourself-with-the-standard-library-including-tr1" class="header-anchor">#</a> Item54：让自己熟悉包括TR1在内的标准程序库     Familiarize yourself with the standard library，including TR1.</h3> <h3 id="item55-让自己熟悉boost库-familiarize-yourself-with-boost"><a href="#item55-让自己熟悉boost库-familiarize-yourself-with-boost" class="header-anchor">#</a> Item55：让自己熟悉Boost库 Familiarize yourself with Boost.</h3></div></div> <!----> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">Last updated:</span> <span class="time">2023/06/18, 16:23:56</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/6f0fa2/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">VsCode 常用插件</div></a> <a href="/pages/07fccd/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">《More Effective C++》</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/6f0fa2/" class="prev">VsCode 常用插件</a></span> <span class="next"><a href="/pages/07fccd/">《More Effective C++》</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:quincy_jet@outlook.com" title="E-Mail" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/Quincy-J" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
    Copyright © 2017-2023
    <span>Quincy Jet | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          Auto 
        </li><li class="iconfont icon-rijianmoshi">
          Light 
        </li><li class="iconfont icon-yejianmoshi">
          Dark 
        </li><li class="iconfont icon-yuedu">
          Read
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d9e23042.js" defer></script><script src="/assets/js/2.0eed2333.js" defer></script><script src="/assets/js/3.1c18827c.js" defer></script><script src="/assets/js/25.d9836ed1.js" defer></script>
  </body>
</html>
